메모 색인 태그
	~시작~
	~여기부터~

수기 메모 정리

// 오명운 강사님 : blockenters@gmail.com (강의 관련 문의)


// 강의 자료 공유 : http://github.com/blockenters/android


// 게임은 보통 윈도우즈 서버를 쓴다. 나머지는 보통 리눅스 서버 아니면 기타 다른 운영체제 서버를 씀.


// NULL : 널이라고 읽음. 중요한 용어.


// 우분투 : 리눅스 무료 개발 프로그램. 우분투 데스크탑.
  // 본 수업에서는 최신버전 받으면 기존 버전이 안 들어가질 수 있어서 일부러 한단계 아래 구버전을 설치해 사용함.


// JVM : 자바 버추얼 머신. 자바로 코딩한 언어를 여러 운영체제에서 돌아가게 만들어주는 도구. 다른 언어는 안되나?


// JAVA : 객체지향 프로그래밍, 객체지향 언어. 자바는 JVM 세팅이 되어있을 경우 플랫폼에 자유롭다.
  // 자바 실행코드는 JVM에서 실행된다.
  // 자바도 컴파일을 해야 한다.


// 설계 : 디자인 (ex. 소프트웨어 설계 = 소프트웨어 디자인)


// 안드로이드는 클라이언트다. (ex.클라이언트 개발은 안드로이드 개발일 수 있음)


// 서버 구축 : 네트워크 가능한 앱을 만들 수 있게 됨.


// 버추얼박스(VB) 다운로드, 설치, 우분투(리눅스OS) 가상머신 만들기, VB 가상머신 기본 세팅
  // 힘든 작업이라 요새는 원하는 기능만 뽑아서 쓸 수 있는 클라우드 유료 서비스를 잘 쓴다고 한다. 아래에 적는 방법은 컴퓨터에 직접 설치하는 방법임(하드웨어에 소프트웨어를 설치하는 방법).
  // 대표적인 클라우드 서비스 AWS(아마존), GCP(구글)
  // VirtualBox (윈도우즈 컴에서, 리눅스 환경 개발을 위해) 다운로드 & 설치
    // 다운로드하기 : 강의 자료 공유 페이지 > 개발 환경 설정 > 버추얼박스 링크 > 큰 다운로드 배너 > VirtualBox binaries > VirtualBox 6.1.6 platform packages(최신버전으로) > Windows hosts > 다운로드 > 실행파일 눌러서 설치
    // 가상 머신(리눅스 운영체제) 만들기 : 머신 > 새로만들기 > 머신 이름 적기(Ubuntu) > 종류, 버전은 Ubuntu를 적으면 자동으로 선택됨 > 메모리 할당 4096MB > 지금 새 가상 하드디스크 만들기 > VDI 선택 > 동적 할당 선택 > 200GB(용량 랜덤) > 가상 머신 생성됨
  // VB에서 기본 세팅하기(가상머신 첫 실행 전 세팅)
    // 네트워크 설정 : 좌측 가상머신 클릭 > 설정 > 네트워크 > 다음에 연결됨 : NAT(기본 설정임) > 확인
    // 우분투용 시동디스크 다운로드하기 : 강의 자료 공유 페이지 > 개발 환경 설정 > 우분투 설치 링크 중 두번째(첫번째 링크는 최신버전) 링크 > Past releases and other flavours > Ubuntu 18.04 LTS (Bionic Beaver) > 64-bit PC (AMD64) desktop image > 다운로드
    // 우분투 시동디스크(광학 드라이브) 세팅하기 : 좌측 가상머신 클릭 > 설정 > 저장소 > 컨트롤러: IDE 아래의 '비어있음' 선택 > 우측 디스크 모양 아이콘 클릭 > 첫번째 선택 > 추가 > 다운받은 우분투 iso파일 선택 > 열기 > 선택 > 확인


// 우분투(리눅스OS) 가상 머신 기본 세팅
  // 운영체제 설치시(처음 켰을 때) 기본 세팅 : 우분투(가상 머신) 실행 > 언어 선택 > 우측 Ubuntu 설치 선택 > 키보드 > 기본 세팅 선택 > 계속하기 > 일반 설치 > Ubuntu 설치 중 업데이트 다운로드 체크표시 > 계속하기 > 디스크를 지우고 Ubuntu 설치 선택 > 지금 설치 > '계속하시면~' 떴을 때 계속하기 선택 > 거주지 선택 > 이름, 컴퓨터 이름, 암호 등 입력 > 설치 > 설치 진행됨
  // vboxsf에 접근권한 주기(아마도) : 우분투(가상 머신) 실행 > 우분투 터미널(Ctrl+Alt+T) > $ sudo apt-get update > 엔터 > 운영체제 설치시 생성한 계정의 비밀번호 입력 > 엔터
    // 비밀번호 입력시 문자 표시 안 되는 것이 정상. 엔터 치고 맞으면 그냥 넘어가고, 틀렸으면 틀렸다고 메세지가 따로 뜸. 리눅스는 원래 그렇다고 함.
    // 터미널 편의성 꿀팁
      // 이전에 쓴 명령어 띄우기 : ↑(방향키) 누르면 됨. 이전에 이전에 이전에 이전 것도 계속 띄울 수 있음.
      // 실행파일명 자동완성 : tab키 누르기. 실행한(입력했던) 파일이나 폴더명이 있을 경우 파일명 맨 앞의 두세글자만 쓰고 탭키를 누르면 나머지 이름이 자동으로 완성된다. 터미널 끄고 켰을 때도 유지되는지는 테스트를 안 해봐서 모르겠음.
      // 터미널 화면 초기화 : clear 입력 후 엔터. 화면이 깨끗해짐.
  // Extension Pack 다운로드 & 설치하기 : 강의 자료 공유 페이지 > 개발 환경 설정 > 버추얼박스 링크 > 큰 다운로드 배너 > VirtualBox 6.1.6 Oracle VM VirtualBox Extension Pack > All supported platforms > 다운로드 > 실행파일 눌러서 VB에 등록 > 우분투 실행 > 상단 메뉴에서 장치 > 게스트 확장 CD 이미지 삽입... > 바탕화면에 CD모양 아이콘이 생기면서 'VBox_~~에는' 이라는 메세지가 뜨면 '실행'을 선택 > 계정 암호 입력 > 터미널 실행됨 > 다 실행되고 'Press~' 나오면 엔터 치고 재부팅하면 됨.
    // 여기서 설정 > 저장소에 갔을 때 저장소에 추가했던 우분투 부팅디스크 iso 이미지는 사라지고 VBoxGuestAdditions.iso로 바뀌어있어야 Extension Pack이 잘 설치된 것임.
  // 공유폴더 생성 & 등록하기 : D드라이브에 영문으로 폴더 생성 > 우분투 실행 > 상단 메뉴 > 장치 > 공유 폴더 > 공유 폴더 설정 > 우측 폴더 아이콘 클릭 > 폴더 경로 : D드라이브에 생성했던 폴더 선택 > 자동 마운트 클릭 > 마운트 지점 : /home/'우분투에 만든 계정 이름'/share 입력 > 하단 '항상 사용하기' 체크 > 확인 > 확인(설정 저장)
    // 공유폴더가 잘 생성되었는지 확인하는 방법 : 우분투 터미널 > $ ls(엘에스) 입력 후 엔터 > 이 목록 가운데 share 폴더가 보이면 제대로 잘 만들어진 것임.
  // 부가적 설정
    // 바깥 운영체제와 클립보드 공유 : 우분투 실행 > 상단 메뉴에서 장치 > 클립보드 공유 > 양방향 선택
      // 밖(ex.윈도우)에서 복사해서 가상 운영체제에 붙여넣을 수 있고, 반대로 가상 운영체제에서 밖으로 복사 붙여넣기 가능. 자매품 드래그 앤 드롭 양방향 설정.


// 안드로이드 스튜디오(줄여서 안스, as) 다운로드 & 설치
  // 우분투(리눅스)에서 설치
    // 안스 다운받기 : android studio 구글 검색 > 맨 위에 뜨는 링크 > 밑으로 스크롤해서 Android Studio downloads > Linux(64-bit) > android-studio-ide-192.6392135-linux.tar.gz 눌러서 다운받기
    // 안스 설치 : 우분투 터미널 > $ sudo apt-get update(우분투 내 소프트웨어 전체 업데이트) > 비밀번호 입력 > $ sudo apt install openjdk-8-jre openjdk-8-jdk(두가지를 설치해라라는 뜻) > y 누르고 엔터 > 설치됨 > $ sudo snap install android-studio --classic > 설치(다운로드?) 진행됨 > $ android-studio > 프로그램 설치(초기 설정) 시작
    // 관련 코드1 : 자바 버전 확인 : $ java -version 밑에 뜨는 세 줄의 코드는 밑의 세 코드 중에 아무거나 쓰라는 것. 업데이트를 위한 건지 설치를 위한 건지는 잘 모르겠음.
    // 관련 코드2 : snapd를 인스톨해라 : $ sudo apt install snapd
  // 윈도우용 다운로드 & 설치
    // android studio 구글 검색 > 맨 위에 뜨는 링크 > 메인 화면의 윈도우용 안스 다운받아 설치
  // 첫 실행시 설정(우분투, 윈도우 공통)
    // Do not~ 체크 후 OK > 구글에 오류 자료 등등 보낼 거냐 > Don't send 선택 > next > standard 누르고 next > UI 고르기 > next > 설치 진행 > finish
  // 안스 정보
    // 안스는 용량을 많이 차지한다.
    // VB와 같은 가상 머신에서 실행하면 프로그램이 좀 느리게 돌아갈 수 있음.


// 안스 새 프로젝트 만들기 & 기본 세팅
  // 안스 실행 > Start a new Android Studio project > Phone and Tablet 탭에서 Empty Activity 선택 후 Next > name에 앱 이름, package name에 패키지 이름, language 눌러서 Java 선택, Minimum SDK에 API 19: Android 4.4 (KitKat) 선택 > Finish
    // 프로젝트 파일 열 때마다 Indexing 작업을 한다. 시간 좀 걸림. 제일 처음 프로젝트를 만들었을 때에는 다른 작업까지 한다고 시간이 좀 더 오래 걸림.
    // 앱 이름(name)은 앱을 대표하는 말 그대로 앱 이름. 마켓에서 검색할 때 치는 바로 그 앱 이름.
    // Package name은 앱의 고유 주소(?). 앱마다 이 주소가 다 다르기(달라야하기) 때문에 세상에 하나뿐인 이름이다. 앱의 정체성을 나타내는 이름.
      // 자바의 패키지 네임 규칙 : 'com.회사명(닉네임).앱이름'의 형태를 띠고 있다. 일반적인 웹 주소를 거꾸로 바꿔 적어놓은 거라고 생각하면 쉽다. 중간과 끝 네임이 다른 제품(앱)과 겹치면 안 된다.
    // Minimum SDK의 의미 : 작성하려는 프로젝트가 최소 어느 버전의 안드로이드 API부터 지원할 것인지를 선택하라는 뜻이다. 최소 버전의 선택에 따라 앱이 구동되는 기기가 많거나 아주 적을 수도 있다.
      // API 19: Android 4.4 (KitKat) 버전이 제일 자주 널리 쓰인다고 한다.
  // 버추얼(가상) 시뮬레이터(AVD : Android Virtual Device) 만들기
    // 프로젝트 내에서 우측 상단 AVD Manager 버튼(폰 모양 아이콘) > 중간의 Create Virtual Device... > 기기와 기종 선택 > System Image Q 다운로드 후 선택 > Next > 가상기기 이름 입력하고 Finish
      // 기종 선택시 팁 : 해상도가 너무 높은 기종은 AVD를 돌릴 때 버벅거릴 수 있다.
  // 필요한 SDK 설치하기
    // AVD Manager 버튼 오른쪽에 있는 SDK Manager 버튼 > SDK Platforms 항목에서 필요한 플랫폼 다운로드 > 우측 SDK Tools 항목 눌러서 필요한 도구 체크표시 > OK누르면 선택한 SDK 다운로드 및 설치 시작 > Finish
      // SDK Platforms에서는 개발하고자 하는 안드로이드 버전을 고를 수 있음
      // SDK Tools에서 필수적으로 받아야(업데이트해야) 하는 도구
        // Android SDK ~~ (뒤에 뭐였는지 잘 기억 안 남)
        // CMake
        // Google Play services
  // 모듈(module) 만들기
    // 모듈의 사전적 의미
      // [컴퓨터] 프로그램을 기능별로 분할한 논리적인 일부분.
      // [컴퓨터] 특정 기능을 하는 컴퓨터 시스템이나 프로그램의 단위.
    // File > New > New module > Java or Kotlin Library 선택 > Next > 라이브러리 이름 입력(libjava) > Language항목 Java 확인 > SDK 버전 확인 > Next > Empty Activity 선택 > Next > Activity 이름 입력 > Finish
      // 라이브러리 패키지 네임 규칙 : com.회사명(닉네임).라이브러리이름(libjava)
      // 라이브러리(모듈) 폴더(앞서 설정한 라이브러리 이름을 가진 폴더) > src 폴더에 내가 만든 소스가 다 들어감.
        // src : source의 줄임말 표현
  // 추가 세팅
    // 시스템 폰트 바꾸기 : Settings > Appearance > Use custom font 체크표시 > 폰트 및 사이즈 변경
    // 에디터 폰트 바꾸기 : Editor > Font에서 에디터 내 폰트, 사이즈, 간격 설정 가능.
  // 윈도우용 안스에서 추가적으로 기본 세팅하기
    // 파일 > 설정 > 파일 인코딩 > 프로젝트 인코딩을 UTF-8로 변경 > 바로 아래 Properties Files 항목 디폴트 인코딩 포~도 UTF-8로 변경 > 맨 아래에 인코딩 설정하는 것까지 UTF-8로 변경해주면 됨. 이렇게 하면 된다고 했는데 슨생님은 왠지 안되심.


// 안드로이드 무겁다. 애플은 더 무겁다. 운영체제 말하는 건가..?


// 프로젝트 편집 화면에서 우측 에디터 화면을 (자바)소스코드(source code) 창이라고 부른다.


// 라이브러리(Library) : [IT사전] 복수의 모듈을 취급하기 쉽도록 하나로 일괄시킨 것을 라이브러리(library)라고 한다. 관련한 파일, 코드들의 집합이라고 생각하면 편할 듯.


// 안스 자바 연습 파일 경로 & 필수 입력 코드 psvm
  // 자바 연습 파일 경로
    // 안스 초기 설정들을 거치고 난 다음 메뉴바 좌측 아래아래에 있는 선택항목(기본 Android로 되어있음)을 눌러서 Packages 선택 > 첫 폴더를 열면 app, 라이브러리 이름 폴더, 앱 이름 폴더가 순서대로 나열되어 있는데 여기서 라이브러리 폴더 열기 > 동명의 하위 폴더 열기 > 라이브러리 패키지 이름 폴더 열기 > myclass1 파일을 더블클릭해서 에디터 창에 띄운다.
      // 더블클릭해서 public class ~까지만 있는 자바 파일이 없으면 마지막 폴더에서 우클릭해서 자바 파일 생성하면 됨.
      // myclass1이라는 자바 형식 파일이다. myclass1이라는 클래스를 정의하고 그 클래스의 속성과 내용들을 담고 있다.
  // 필수 입력 코드 psvm
    // public class ~ 문장 맨 끝에 커서 놓고 엔터 > psvm 치고 엔터 > public static void main(String[] args) {}로 자동 완성됨.
      // psvm은 main 메소드(함수)를 정의하면서 실행시켜주는 코드다. CPU가 가장 먼저 들어오는 진입로(엔트리 포인트)를 만들어준다.
      // main은 특수 메소드로, CPU는 main 메소드를 찾아서 여기에 속한 코드들을 실행시킨다. main 메소드는 가장 먼저 실행되어야 하므로 반드시 static(뒤에 붙은 메소드를 바로 실행하게 해줌)을 main 앞에 붙여줘야 한다.
        // 실행시키고 싶은 자바 코드가 있다면 main 안에 넣어주면 된다.
        // 실행을 목적으로 하는 모든 자바 클래스는 main 메소드가 필요하다. (목적이 실행이 아닌 경우 쓰지 않음)


// 자바 코딩 기본 정보 & 팁
  // 진한 글씨는 자바에서 기본적으로 정의되어 있는 용어들로, 변수 이름이나 메소드, 데이터 타입 등으로 사용할 수 없다.
  // CPU가 코드를 읽는 방향 : 기본적으로 왼쪽에서 오른쪽, 위에서 아래로 읽는다. 한 줄(블럭)이 끝나면 다음 줄(블럭)으로 간다. 데이터 타입이나 연산자에 따라서 읽는 방향이 달라질 수 있다.
  // '//'는 주석을 달 수 있는 코드로 연산되지 않고 출력되지 않는다.
  // 코드 블럭({}) : 한 데이터 타입의 중괄호 시작({)부터 끝(})까지를 코드 블럭이라고 한다.
  // 변수(=)의 정의와 설명
    // 코딩에서 변수를 정의할 때에는 '=' 기호를 쓰며, = 연산자는 수학에서 말하는 등호가 아니다.
    // 'fish'와 '고등어'가 있을 때 이 사이에 =를 적어 'fish = 고등어'를 만들면, 'fish'라는 이름의 변수가 만들어지고 '고등어'가 'fish'변수 안에 '기록(저장)'된다.
      // 여기서 'fish'는 변수 이름, '고등어'는 변수값이다.
      // 변수는 박스로 비유해 생각하면 편하다. fish라는 이름이 붙은 박스에 '고등어' 텍스트를 넣어놓는 것이다. 나중에 '고등어'를 꺼내고 싶으면 'fish' 박스를 찾아 꺼내면 된다.
    // 연산자 =의 CPU 연산 처리방식은 오른쪽에서 왼쪽이다. '오른쪽(변수값)을 왼쪽(변수)에 저장한다.'고 표현한다.
    // 하나의 변수에는 한가지 유형(ex.실수, 정수, 텍스트 등)밖에 저장하지 못한다.
    // 변수가 '기록(저장)'되는 곳은 램카드 메모리다.
      // 메모리에 저장되는 것은 변수뿐이다. <사실 여부 잘 모름..ㅎ
    // 변수 이름 규칙
      // 이름 맨 앞에 숫자를 붙이면 안된다. _(언더스코어)는 맨 앞에 붙여도 된다.
  // 명령 하나를 끝내면 끝에 꼭 ;(세미콜론)을 꼭 붙여줘야 한다. 한 문장의 끝을 의미한다.
  // 곱하기 연산 : *를 쓰면 됨.


// 기본 데이터 타입 몇가지
  // println(); : ()안에 내용을 넣으면 그 내용이 결과값 화면에 출력시켜준다.
    // ("")안에 내용을 넣으면 넣은 내용 그대로 출력되고, ""없이 내용을 넣으면 그 내용은 변수 이름으로 인식되어 변수값이 출력된다.
  // float : 변수값의 유형을 실수로 규정하는 데이터 타입. 이 데이터 타입 뒤에 입력한 변수값은 실수여야 한다. 입력할 수 있는 실수의 범위가 정해져있다.
    // ex. float silsu = 3000f 일 때 출력값 3000.0
      // float의 변수값을 적어줄 때에는 이 수가 실수임을 확실하게 해주는 f를 붙여주는 것이 좋다.
  // string : 문자열.. 뭐 메모하려고 한 건지 모르겠다. 설명 쓰려고 한 거 같긴 한데.
  // value : 데이터(데이터를 PC에 저장) 이라고 쓰여있는데 뭘 쓰려고 한 건지 역시 모르겠다.
  // int : 변수값의 유형을 정수로 규정하는 데이터 타입. 이 데이터 타입 뒤에 입력한 변수값은 정수여야 한다. 입력할 수 있는 정수의 범위가 정해져있다.


// 데이터 타입은 처음 만들 때만 메모리에다가 숟가락을 떠먹여줘야 한다.
  // 데이터 타입이 뭐더라. 책에 적혀있을 거임. 이제 알았다..
  // 자료형(資料形) 또는 데이터 타입(영어: data type)은 컴퓨터 과학과 프로그래밍 언어에서 실수치, 정수, 불린 자료형 따위의 "여러 종류의 데이터를 식별하는 분류"이다. 더 나아가 해당 자료형에 대한 가능한 값, 해당 자료형에서 수행을 마칠 수 있는 명령들, 데이터의 의미, 해당 자료형의 값을 저장하는 방식을 결정한다.


// 프로그램은 돌릴 때(run)마다 메모리가 생긴다.


// 프로그래밍은 검색 능력이 중요하다. 문제가 생겼을 때 혼자서만 해결하려고 하면 효율이 떨어진다.
  // 코딩은 검색이 50 설계가 20 타이핑이 30이다.


// 디버깅 : 문제를 찾는 행위. 디버깅 능력이 곧 연봉.


// 복습할 땐 자바 큰 책.

200507 수업 요약

// 입학식
  // 담당자분들 소개
  // 책 배부

// 동기부여 동영상 시청

// 자바에 대한 간단한 설명

// 간단 지식테스트(수준 참작용)

// 버추얼박스를 이용해 리눅스 운영체제(우분투)설치하기
  // 버추얼박스 설치
  // 가상머신 만들기
  // 우분투에서 접근권한 설정
  // Extention Pack 설치

// 안드로이드 스튜디오 설치
  // 우분투에서 안드로이드 스튜디오 설치하기
  // 윈도우에서 안드로이드 스튜디오 설치하기

// 안드로이드 스튜디오로 새 프로젝트 만들기(설정하기)
  // 버추얼 시뮬레이터(AVD) 만들기
  // SDK매니저에서 필요한 SDK파일 받거나 업데이트하기
  // 새로운 모듈(새로운 작업) 만들기(설정하기)

// 자바 클래스 파일 기본 설정
  // class 정의 중괄호 안에 PSVM 입력하기(main 메소드 생성)

// 변수의 정의

// 몇가지 데이터 타입과 연산자 설명

// JAVA 책 49페이지까지 진도나감(위 내용들 포함됨).

200508 수업 요약

// 조건문, 반복문 설명

// a++

// 유용한 단축키

// 코딩 팁

// 메소드
  // char
  // String
  // print와 println의 차이
  // 조건문 - 메소드
    // break;
    // continue;
    // if
      // if - then
      // if - then - else
      // if - then - else if - then - else
    // switch(value) - case n: - default

  // 반복문(loop)
    // for
    // while
    // 중첩 루프

// 연산자★
  // 조건문 - 연산자
    // ==, !=, >, >=, <, <=
  // 논리 연산자
    // &&, ||
  // % : 나머지★

// 데이터 처리★
  // 배열 코드
    // 배열 선언, 배열 초기화
      // [], new, {}설명
      // 주의사항

200508 수업 요약


// 유용한 단축키
  // 영역 잡은 후 Ctrl+/ : 잡아놓은 영역이 자동으로 주석 처리가 된다.
  // Ctrl+Alt+L : 함수 배열 자동 정리


// 변수는 중요하니까
  // 변수 선언은 데이터 타입과 함께 사용한다.★
    // int a = 1에서 int는 "데이터 타입", a는 변수 이름, 1은 변수값.
      // int a; <-변수 선언 : int(정수)유형의 변수a를 선언했다는 뜻.
      // a = 1 <-변수 초기화(초기값 지정) : 정수 1을 변수 a에 저장한다는 뜻.
        // =은 오른쪽 먼저 계산한다. CPU의 처리 순서가 →에서 ←으로 바뀐다.
  // CPU는 =를 '변수를 저장하라'는 명령으로 받아들인다.
    // CPU는 명령에 따라 컴퓨터 메모리에 변수를 저장하고 불러올 수 있다.
    // 변수를 저장한다는 것은 곧 기억하려고(기억하게하려고) 한다는 것.
    // '저장(기억, 기록)'은 곧 '변수'. 이 반대로 기억해도 됨.★
  // 변수를 만든 다음 데이터를 가공하거나 연산을 한다.
  // (변수)값을 바꾼다 -> 메모리 내용을 바꿔 저장한다.


// 코딩 팁
  // 자바에는 제곱을 표현하는 연산자가 없다. 제곱을 쓰고싶으면 라이브러리에서 사용해야 한다.
    // 자바 말고 다른 언어에서 일반적으로 쓰이는 제곱 용어는 ^이다.
  // 출력문(println)에 문자열과 변수를 함께 나타내기 위해서는 +로 문자열과 변수를 연결시켜주면 된다.
  // 클래스 이름, 프로그램(앱) 이름, 라이브러리 이름, 메소드 이름 다 다른 거임.
  // 주로 앞에 쓰이는 굵은 글씨는 "예약어" 코드로서, 변수 이름으로 쓸 수 없다.
  // '}'를 보는 CPU의 해석 : 이제 할 거 없넹.
  // 문법은 이해하지 말고 외울 것.
  // 안에 넣을 코드랑 밖에 넣을 코드랑 잘 구분하기.
  // 보통 데이터(변수) 정의 먼저 하고 나중에 그 변수를 활용해 만들고 싶은 걸 만든다. 이 때 데이터를 정의(저장)할 때와 똑같은 수식이 쓰일 수도 있다.
    // 이런 경우, 데이터 정의를 활용한 수식을 바로 테스트해보고 싶다면 이중으로 같은 수식을 적을 필요없이 데이터 정의 바로 밑에 써봐도 된다.
    // 예시 : 6의 배수 for함수 예문(정의와 활용을 따로 쓴 예문)
  // 그냥 정보 : 프로그래밍은 0부터 시작한다. 컴퓨터 용어가 0,1이라서.


// 개발자는 ~
  // 해석보다는 만드는 걸 잘해야한다.
  // 사람의 언어를 프로그래밍 언어로 잘 해석(번역)해야 한다.
    // 그러기 위해서는 CPU의 시선(처리 방식)으로 볼 줄 알아야 한다.
      // CPU의 연산 순서를 기억하자.
  // 질문을 하면(식을 만들면) (원하는)답이 나올 수 있도록 자신에게 묻기.
  // 실습을 많이 하면 실력이 늘어난다.★


// 연산자★
  // 논리 연산자 ((and, or))
    // a && b ((앤드and 연산자 : '그리고')) - 부정적
      // a와 b가 둘 다 true일 때만 true로 연산된다. false가 하나라도 끼어있으면 false로 연산됨.
    // a || b ((오어or 연산자 : '하거나')) - 긍정적
      // a와 b가 둘 다 false일 때만 false로 연산된다. true가 하나라도 끼어있으면 true로 연산됨.
    // 부가 설명
      // 두 연산자 모두 각각 4개씩의 조합을 갖고, 결과는 true or false 두 개만 나온다.
      // true와 false를 컴퓨터 언어로 바꾸면 true는 1, false는 0이 된다.
      // 연산 순서는 논리 연산자를 기준으로 a, b가 먼저 수행(처리)된 다음 마지막으로 논리 연산자가 작동된다.
      // 논리 연산자의 기호는 자료 링크 참고.
  // y % x : 나머지 구하기
    // y를 x로 나눴을 때 나머지가 얼마나 남는지 그 수를 구해주는 연산자.
    // 홀수, 짝수, 배수 등을 이용해야 할 때에는 % 연산자를 활용하면 된다.
  // a++
    // a = a+1이라는 뜻.


// 데이터 타입
  // 데이터 타입의 정의(출처 : 위키백과)
    // 자료형(資料形) 또는 데이터 타입(영어: data type)은 컴퓨터 과학과 프로그래밍 언어에서 실수치, 정수, 불린 자료형 따위의 "여러 종류의 데이터를 식별하는 분류"이다. 더 나아가 해당 자료형에 대한 가능한 값, 해당 자료형에서 수행을 마칠 수 있는 명령들, 데이터의 의미, 해당 자료형의 값을 저장하는 방식을 결정한다.
  // char
    // char를 써서 한 글자만 저장할 수 있다. ''안에 저장할 글자 하나를 적으면 된다.
    // 예) char a = 'e'
  // String
    // String을 써서 글자 여러개를 저장할 수 있다. ""안에 입력하고 싶은 단어 등을 적으면 된다.
    // 예) String b = "string"
    // String은 '문자열'이라는 뜻이다.
  // print와 println의 차이
    // println : ln은 line의 축약어로, 뒤에 오는 값을 출력하고 라인을 바꿔주는 기능을 갖고있다.
    // print : 라인을 바꿔주는 기능 없이 값을 출력한다. print가 여러개 이어져 있으면 출력값들은 한 줄에 다닥다닥 붙어서 나온다.


// 조건문, 반복문 설명 & 팁
  // 공통
    // 조건문, 방법문은 '로직'이다. 조건문, 방법문을 작성할 때 '로직을 짠다'라고 한다.
      // 같은 출력물이라도 사람 따라 로직을 작성하는 게 다르다.
    // 코딩에서는 조건문, 반복문으로 거의 모든 작업이 해결된다.
  // 조건문
    // 조건문은 CPU의 흐름을 바꾸는 사례 중 하나이다. 다른 하나(배운 것 중)는 변수 초기화이다.
    // 조건문을 만들 때에는 조건문이 트루냐 펄스냐를 결정할 수 있게 만들어야 한다.★
    // 애초에 그런 기능으로 써먹기 위해 조건문을 쓰는 것이다.
  // 반복문
    // 반복문은 패턴이 반복되는 긴 작업을 짧은 줄로 줄여서 돌아가게 해주는 효율적인 문장이다.
      // 반복문을 만들려면 반복되는 패턴(일정한 규칙)을 먼저 찾아야 한다. 
        // 정확히는 변하는 부분(변수로 만들 수 있음)과 변하지 않는 부분을 잘 구분해 나눠야 한다.


// 조건문 - 연산자★
  // a == b : a와 b가 같냐
  // a != b : a와 b가 다르냐. 기호 순서 바꾸면 안됨.
  // a > b : 일반 부등호
  // a >= b : 일반 부등호. 기호 순서 바꾸면 안됨.
  // a < b : 일반 부등호.
  // a <= b : 일반 부등호. 기호 순서 바꾸면 안됨.
  // 조건문 출력 예시) System.out.println(a == b);일 때 출력값
    // a=b이면 true, a≠b이면 false로 출력됨.


// 조건문
  // break; 빠져나가기
    // break;은 해당 블록을 더이상 진행하지 않고 한 단계 밖으로 빠져나가도록 해준다.
    // 주로 반복문에 쓰이며 반복문을 빠져나가야 할 때 쓰인다.
    // 중첩 반복문인 경우 안쪽 반복문에서 break;이 실행되면 해당 반복문만 빠져나온다.
      // 빠져나오면 제일 가까운 블럭을 실행한다.
    // 반복문{조건문}인 경우에는 조건문이 아니라 반복문을 빠져나온다. ☆???
    // break; 바로 밑줄에 뭘 적으면 에러가 뜬다. break; 아래의 수식은 실행되지 않기 때문이다.
    // 이 break;이 소속된 블럭들 가운데 특정 블럭으로 빠져나오고(이동하고) 싶을 땐 'break 라벨이름;'을 쓰면 된단다.
  // continue; 건너뛰기
    // continue;는 컨티뉴 이후의 문장을 실행하지 않고 제일 가까이에 있는 조건식이나 반복문으로 이동한다.
    // 제일 가까운 블럭이 for문인 경우에는 조건식()의 증감식(세번째)으로 이동하게 된다.
    // continue; 바로 밑줄에는 문장을 적을 수 있다.
    // break;과 마찬가지로 이 continue;가 소속된 블럭들 가운데 특정 조건문/반복문으로 이동하고 싶을 땐 continue label;을 쓴다.
  // if (( if(A){B} ))
    // if 옆에는 반드시 ()가 붙는다. 괄호 안에는 조건문을 넣는다. 예) if(조건문)
      // else 옆에는 ()가 안 붙는다.
    // if(A){B}
      // A하면 B해라
      // 조건 A가 성립되면 B를 연산한다.
      // 조건 A가 성립되지 않으면 이 if블록은 건너뛰게 된다. 출력값 요청시 아무 것도 출력되지 않는다.
    // if(A){B}else{C}
      // A하면 B하고 아니면 C해라
      // 조건 A가 성립되면 B를 연산하고, 조건 A가 성립되지 않는 모든 경우는 C로 연산된다.
    // if(A){B}else if(C){D}else{E}
      // A하면 B하고, 그게 아니라 C면 D하고, 그것도 아니면 E해라
      // 조건 A가 성립되면 B를 연산하고, 그렇지 않으면 바로 E를 연산하는 것이 아니라 두번째 조건인 else if의 조건 C로 가게 된다. 조건 C가 성립하면 D를 연산하고, if블록 안의 모든 if(조건문)이 성립하지 않을 경우 else{E}를 연산한다.
      // else if는 필요한 만큼 추가할 수 있다.
    // if블록의 범위를 잘 파악해야 한다. CPU는 뭐든지 블록 단위로 구분해 실행하기 때문이다.
    // 조건문의 결과값은 숫자, 문자, true or false 등등이 될 수 있다.
      // 조건문 결과가 원하는 값이 출력될 수 있도록 수식을 잘 만들어야 한다.
  // switch(value){case n: A break; default: B break;}
    // value값이 n에 해당하면 'case n:'을 연산한다. 해당하는 n이 없으면 'default:'를 연산한다.
    // case n:은 필요한 만큼 추가할 수 있다.
    // default는 if문의 else와 같은 역할을 수행한다.
      // if와 마찬가지로 value값이 모든 n에 해당하지 않는데 default를 적어놓지 않는 경우 이 swtch블록은 건너뛰게 된다. 출력값 요청시 아무 것도 출력되지 않는다.
    // 중간의 break;을 지우면, value에 해당하는 case n아래부터 이 블록 안에서 마지막 break;가 나오기 전까지의 모든 값이 연산된다.
      // value에 해당하는 값이 없는 default의 경우 default만 출력되긴 한다.


// 반복문(loop)★
  // for
    // 기본 형태 : for(변수조건A; 반복조건B; 반복패턴C){실행문D}
    // 주로 반복 '횟수'를 알고있을 때 사용
    // 연산 순서
      1) A 연산
      2) A의 결과값이 B의 조건에 부합하는지 체크
      3) 부합하면 D를 연산, 부합하지 않으면 for블록 종료.
      4) D를 연산한 경우 다시 돌아와서 C를 연산.
      5) C의 결과값이 B의 조건에 부합하는지 체크
      6) 부합하면 D를 연산, 부합하지 않으면 for블록 종료.
      7) 조건이 B에 부합하지 않을 때까지 4)~6) 반복
        // A에 있는 변수가 반복으로 인해 변하는 경우, 이 for블록이 종료되기 전까지 조건A로는 초기화되지 않음. 변수조건A는 for블록의 '시작' 기준일 뿐이다.
    // 예문
        for(int a = 0; a <= 10; a++){
            System.out.println(a);
        }
        의 연산 순서
        1) a=0으로 저장.
        2) a<=10확인.
        3) 일단 기존 a먼저(0) 한번 출력. 그 다음에 다시 돌아옴.
        3) a=a+1 연산.
        4) a<=10 확인.
        5) a 출력.
        6) a가 10이하일 때까지만 출력.
    // 정리 : ABD/CBD/CBD/CBD.../CB(종료) 순서로 돌아감.★
  // while
    // 기본 형태 : while(조건식){실행문}
    // '조건'에 따라 반복시키고 싶을 때 사용
    // 조건식에는 주로 비교 또는 논리 연산식을 사용 (결과값이 true or false로 나오는 연산식)
      // 논리연산식은 대부분을 for문보다 while문에서 사용한다.
    // while문에 사용되는 변수는 while문 밖에서(위에서) 선언된다.
      // 변수를 사용하는 데에 있어 유용하다. (while문 안에서 필요한 변수를 선언한 경우는 제외)
  // 중첩 루프
    // 루프(반복문)은 블록이 중첩되서 쓰이는 경우가 많다. 이를 중첩 루프라고 한다.
    // for루프가 중첩되어 쓰이는 경우가 많다.
    // 중첩 루프 중 하위 루프는 한 번 돌고 상위 루프로 올라갔다가 다시 내려와서 시작할 때 조건값이 초기화된다.


// 데이터 처리★
  // 데이터를 효율적으로 처리하는 방법. 데이터 분석이나 빅데이터와 관련이 있다.
  // 배열 코드
    // 변수 여러개를 변수 하나로 처리(선언 및 초기화)할 수 있도록 만든 코드.
    // 배열 방법은 여러가지가 있다.
  // 배열 선언, 배열 초기화
    // int[] arr;는 배열 선언, arr = new int[숫자];은 배열 초기화.
      // 합쳐 쓰면 int[] arr = new int[숫자];
      // []의 명칭은 '배열', 영어 표현은 array다.
        // []안의 숫자를 인덱스라고 한다. 실제로 인덱스 역할을 한다.★
      // arr은 array의 약어로, 위 문장에서는 배열 변수 이름이다.
      // new는 문법. 여기서는 정수(int) 속성을 가진 '숫자'개의 새 변수를 선언한다는 뜻.
      // 배열을 선언만 한다고 해서 다른 수식 등에 바로 적용할 수는 없다.★
        // 변수값을 각 인덱스에 넣어줘야 써먹을 수 있다.
        // 예시) arr[0] = 100; "정수 100을 변수arr의 0번째 자리(인덱스)에 저장한다."
    // 배열 선언 & 초기화에서부터 변수값 직접 지정하기
      // int[] arr = {1, 2, -3};
        // 여기서 배열 개수는 3개가 되고, 변수값은 각각 1, 2, -3이 된다.
        // 변수값을 바로 지정할 때에는 배열 초기화에 new int[]가 쓰이지 않고 바로 {}로 넘어간다.
    // 주의사항★
      // 배열 변수를 불러올 때 인덱스 순서는 무조건 0부터 시작한다.
        // 예시) int[] arr = new int[3]일 때 변수는 총 3개지만, 배열 변수를 호출할 땐 순서대로 arr[0], arr[1], arr[2]로 불러와야 한다. 1, 2, 3으로 불러오면 안 됨.
    // 배열 변수가 메모리에 입력되는 예
      // arr : 100, 88, 70, 99, 66 (arr[1] : 100, arr[2] : 88, ... 이런 식이 아님)
         arr1 : 1, 2, 3 (0번째, 1번째, 2번째. 1번째, 2번째, 3번째가 아니다.)
         arr2 : _ _ _ _ _ _ _ _ _ _ _ _ _ _(만들어놓고 저장해놓은 값이 없을 때)

200508 금요일 수업에 쓰인 함수


변수 선언(오류문)
        int a;

        System.out.println(a);
변수 선언 & 변수값 저장
        int a;
        a = 2

        System.out.println(a);
변수 선언 & 변수값 저장2
        int a = 2;

        System.out.println(a);


★조건문 연산자 - 등호, 부등호
        int a = 10;
        int b = 20;

        System.out.println(a == b);
        System.out.println(a != b);
        System.out.println(a > b);
        System.out.println(a >= b);
        System.out.println(a < b);
        System.out.println(a <= b);

연산자 출력값
> Task :libjava:MyClass.main()
false
true
false
false
true
true


Scanner 함수(보류중)
        Scanner sc = new Scanner(System.in);
        String name;
        int Math;

        System.out.println("name : ");
        name = sc.next();

        System.out.println("math score : ");
        Math = sc.nextInt();

        System.out.println(name + " : " + Math);


★논리연산자 - and(&&), or(||)
        int a = 10;
        int b = 20;

        System.out.println(a == 10 && b == 20); //and//
        System.out.println(a > 10 && b == 20);
        System.out.println(true && false);

        System.out.println(a == 10 || b == 20); //or//
        System.out.println(a < 10 || b > 20);

===============

        age >= 30 && price >= 300000

	//나이가 30 이상이고(and) 지출이 30만원 이상인 사람(조건)

===============

        children >= 2 || parent == 2

	// 아이가 둘 이상이거나(or) 부모가 두명인 사람(조건)

★조건문 연산자 - if : ~하면 ~한다.
        //if - else if - else if - ... - else//
        int a = 3;
        int b = 20;
        if(a>20){
            System.out.println("a is bigger.");
            System.out.println("Hello");
        }else if(a>10){
            System.out.println("a is middle");
        }else if(a>5){
            System.out.println("a is not bigger");
        }else{
            System.out.println("else");
        }
연산자 출력값
> Task :libjava:MyClass.main()
else


if 연산자(과제)
        int score = 70;

        //score>90, print A//
        //score>=70, <90, print B//
        //score>=50, <70, print C//
        //score<50, print F//
        if(score>=90){
            System.out.println("A");
        }else if(score>=70){
            System.out.println("B");
        }else if(score>=50){
            System.out.println("C");
        }else{
            System.out.println("F");
        }

        //or//

        if(score>=90){
            System.out.println("A Grade");
        }else if(score>=70 && score<90){
            System.out.println("B Grade");
        }else if(score>=50 && score <70){
            System.out.println("C Grade");
        }else{
            System.out.println("F Grade");
        }
	//F등급 출력은 else if로 만들고 (score>=0)으로 해도 된다.

연산자 출력값
> Task :libjava:MyClass.main()
B Grade
B Grade

if로 짝수 홀수 판별하기 & 변수값 출력하기
        int number = 1223;
        System.out.println(number%2);

        //number = J, print "even number"//
        //number = H, print "odd number"//

        if(number%2==0){
            System.out.println("even number");
        }else{
            System.out.println("odd number");
        }
연산자 출력값
> Task :libjava:MyClass.main()
1
odd number


switch 함수
        //switch - case - case - ... - default//
        int a = 3;
        switch(a){
            case 1:
                System.out.println("1");
                break;
            case 3:
                System.out.println("3");
                break;
            case 5:
                System.out.println("5");
                break;
            default:
                System.out.println("default");
                break;
        }
출력값
> Task :libjava:MyClass.main()
3


반복문 : 0부터 10까지 출력하기(노가다버전)
        int a = 0;
        System.out.println(a);
        a = a+1;
        System.out.println(a);
        a = a+1;
        System.out.println(a);
        a = a+1;
        System.out.println(a);
        a = a+1;
        System.out.println(a);
        a = a+1;
        System.out.println(a);
        a = a+1;
        System.out.println(a);
        a = a+1;
        System.out.println(a);
        a = a+1;
        System.out.println(a);
        a = a+1;
        System.out.println(a);
        a = a+1;
        System.out.println(a);
출력값
> Task :libjava:MyClass.main()
0
1
2
3
4
5
6
7
8
9
10


반복문 : 0부터 10까지 출력하기, 짝수만 출력하기, 0에서 100까지 더한 값 출력하기
        int a;
        for(a = 0; a <= 10 ; a++) {
            System.out.println(a); //old type//
        }

        for(int b = 0; b <= 10; b++){
            System.out.println(b);
        }

        //짝수만 출력하기//
        for(int i = 0; i < 5; i = i + 2){
            System.out.println(i);
            System.out.println("Hello");
        }

        //0에서 100까지 더한 값 출력하기1 - for//
        int sum = 0; 
        for(int c = 1; c <=100; c = c + 1){
            sum = sum + c;
        }
        System.out.print(sum);

        //0에서 100까지 더한 값 출력하기2 - while//
        int sum = 0;
        int i = 1;
        while(i <= 100){
            sum = sum + i;
            i++;
        }
        System.out.println(sum);
결과값


1부터 100까지 홀수만 더하기
        //0에서 100까지 홀수만 더한 값 출력하기//
        int sum = 0; 
        for(int c = 1; c <=100; c = c + 2){
            sum = sum + c;
        }
        System.out.print(sum);
방법2(if사용)
        int sum = 0;
        for(int i = 1; i <=100; i = i + 1){
            if(i % 2 == 1){
                sum = sum + i;
            }
        }
        System.out.print(sum);

while문(for과 비슷한 것)
        int i = 1;
        while( i < 6 ){
            System.out.println(i);
            i++;
        }
출력값
> Task :libjava:MyClass.main()
1
2
3
4
5


a의 cnt승을 구하는 프로그램
        int a = 2;
        int cnt = 4;
        int data = 1;
        for(int b = 0; b <= cnt; b++) {
            data = data * a;
        }
        System.out.println(data);
결과값
> Task :libjava:MyClass.main()
32


구구단 출력하기
        for(int step = 2; step <= 9; step++){
            for(int i = 1; i <= 9; i++){
                System.out.println(step+"X"+i+"="+(step*i));
            }
        }
결과값
> Task :libjava:MyClass.main()
2X1=2
2X2=4
2X3=6
2X4=8
2X5=10
...
9X3=27
9X4=36
9X5=45
9X6=54
9X7=63
9X8=72
9X9=81


1에서 100 출력하기 - if, while, continue 예시
	//방법1//
        int i = 1;
        while(i < 100){
            System.out.println(i);
            i++;
        }

	//방법2//
        int i = 1;
        while(i < 100){
            if(i == 10){
                System.out.println("Hello");
                i = 99;
                continue;
            }
            System.out.println(i);
            i++;
        }


1부터 10000까지 수를 곱하고, 곱한 값이 7000보다 크면 곱한 값을 출력하고 종료.
        double value = 1; //곱한 값 기록용//
        for(int i = 1; i <= 10000; i++){
            value = value * i;
            if(value > 7000){
                System.out.println(value);
                break; //루프를 나와라//
출력값
> Task :libjava:MyClass.main()
40320.0


배열 선언&배열 초기화
        int[] arr = new int[5];
        int[] arr2 = {1,2,3};

        arr[0] = 100;
        arr[1] = 88;
        arr[2] = 70;
        arr[3] = 99;
        arr[4] = 66;

        System.out.println(arr[2]);
        System.out.println(arr2[2]);
        System.out.println(arr[0]);

        System.out.println(arr[4]);
        arr[4] = 10;
        System.out.println(arr[4]);
결과값
> Task :libjava:MyClass.main()
70
3
100
66
10


array배열로 학생 20명(변수)의 점수)를 관리하려한다. 반복문을 사용해 모든 학생의 점수를 30점(정해진 수)으로 만들어야 한다.
        int[] score_arr = new int[20]; //20명의 배열(박스)을 만듦.
        for(int i = 0; i <= 19; i++) {
            score_arr[i] = 30; 
        }
	//변하는 학생 수를 i 변수로 표현. int[]와 score_arr[]는 의미가 다르다. 안에 들어가는 수도 의미가 달라진다.int[]는 정수 타입을 저장한다는 의미(숫자 저장 공간 n개를 만들겠다)이고, score_arr[]는 변수에 들어가는 수를 지정하는 용도로 쓰인다. int[]에는 0을 쓰는 것이 의미가 없지만(0개), score_arr(변수)에는 0이 들어갈 수 있다.

        score_arr[0] = 30; //30은 점수
        score_arr[1] = 30; //이하 노가다
        score_arr[2] = 30;
        score_arr[3] = 30;
        score_arr[4] = 30;
이걸 화면에 출력한다.
        int[] score_arr = new int[20];
        for(int i = 0; i <= 19; i++) {
            score_arr[i] = 30;
            System.out.println(score_arr[i]); //맨 위 함수에서 이 줄만 추가됨.
        }
            //19를 20으로 적으면 인덱스 범위를 벗어났다는 오류가 생긴다. 없는 걸 달라고 하는 거다.
6의 배수가 되는 학생들에게는 가산점을 준다. 6의 배수가 되는 학생들 점수는 40점을 준다.
>>0이 40점이 되는 경우
        int[] score_arr = new int[20];
        for(int i = 0; i <= 19; i++) {
            if (i % 6 == 0) { //이럴 때 1도 40점이 된다.
                score_arr[i] = 40;
            }else{
                score_arr[i] = 30;
            }
        }

        for(int i = 0; i <= 19; i++) {
            System.out.println(score_arr[i]);
        }
>>제대로 고쳐서 0도 40점으로 만들자
        int[] score_arr = new int[20];
        for(int i = 0; i <= 19; i++) {
            if (i == 0) {
                score_arr[i] = 30;
            }else if(i % 6 == 0){
                score_arr[i] = 40;
            }else{
                score_arr[i] = 30;
            }
        }

        for(int i = 0; i <= 19; i++) {
            System.out.println(score_arr[i]);
        }
변수 숫자가 많은 경우 - 변수.length : 배열 길이를 알아서 맞춰줌
        int[] score_arr = new int[20];
        for (int i = 0; i < score_arr.length; i++) { //=를 빼줘야 에러가 안 난다. 여기서 score_arr.length는 20을 의미하기 때문.
            if (i == 0) {
                score_arr[i] = 30;
            } else if (i % 6 == 0) {
                score_arr[i] = 40;
            } else {
                score_arr[i] = 30;
            }
        }

        for (int i = 0; i < score_arr.length; i++) {
            System.out.println(score_arr[i]);
        }


변수의 개수를 알고 싶을 때
        int[] arr1 = new int[34];
        short[] arr2 = new short[10];

        System.out.println(arr1.length);
        System.out.println(arr2.length);


음수 개수만 출력하기
        int[] number_arr = {6,7,-33,123,-1,0,392,-742};
        //음수 개수 출력
        int minus_cnt = 0; //0개부터 시작. 손가락. 마이너스 개수 세는 용도.
        for(int i = 0; i < number_arr.length; i++){ //상자 인덱스 만들어주기(정의). for를 쓴 이유는 루프를 돌리면서 마이너스 개수를 세기 위해서.
            if(number_arr[i] < 0){ //마이너스 변수값 여부
                minus_cnt = minus_cnt + 1; //손가락 1개 추가
            }
        }
        System.out.println("minus count : " + minus_cnt);


변수 역순으로 출력하기
        int[] number_arr = {6,7,-33,123,-1,0,392,-742};
        //역순으로 출력하기
        for(int i = 7; i >=0; i--) { //i-- : i = i - 1
            System.out.println(number_arr[i] + " ");


변수 최대값 구하기(출력하기)
        System.out.println(); //줄바꿈 코드
        int[] number_arr = {6,7,-33,123,-1,0,392,-742}; //비교할 때 숫자를 가져오는 작업을 반복.
        int max = 0; //처음 비교값(임의 설정), 나중 최대값
        for(int i = 0; i < number_arr.length; i++){
            if(i == 0) {
                max = number_arr[i];
            }else{
                if(number_arr[i] > max){
                    max = number_arr[i];
                }
            }
        }
        System.out.println(max);

200511 월요일 수업 요약

// 도움되는 말

// 기본 정보(복습)
  // 변수
  // boolean
  // 논리곱 논리합(and or)
  // for/while

// 다차원 배열(array)
  // 2차원 배열
  // 3차원 배열

// 함수
  // 함수의 정의(설명)
  // 함수 관련 용어★
    // 함수의 이름
    // 파라미터
    // return
    // return의 데이터 타입
  // 예시200511 월요일 수업 메모 정리

// 도움되는 말
  // 복습하십쇼~
  // 반복 학습이 제일 좋아요~
  // 프로그래밍은 검색과 설계가 7할. 타이핑이 3할.
  // 무슨 작업을 해야하는지 알아낸 다음, 거기서 무슨 작업이 반복될지 잘 모르겠다면 작업 과정을 일일히 다 적어보면 된다.
  // CPU의 흐름을 제대로 읽을 줄 알아야 한다.
  // 함수를 할 줄 알아야 앱을 만들 수 있다.
  // 사람이 쓰는 문장(언어)를 컴퓨터 문법으로 바꾸는 과정을 잘 하려면, 많이 해보면서 경험치를 쌓는 방법밖에 없다.
  // 코딩하다가 잘 모르겠으면 눈으로만 보고 생각하지 말고, 직접 하나하나 짚어보고 적어가고 하면서 해결해보자.
    // 코딩이나 디버깅을 할 때 CPU 흐름을 손가락으로 짚어가며 보다보면 문제 해결이 잘 된다.

// 기본 정보 & 복습
  // 변수
    // 변수 관련해서 헷갈리면 =에 붙은 변수와 변수값을 메모장 등에 하나하나 적어본다.
    // 메모리에 어떤 값을 저장하는 기능을 하는 것은 =밖에 없다.
    // CPU는 =에서 변수를 저장하거나 읽는다.
    // 변수로 원하는 결과를 도출하려면 무슨 값이 얼마나(몇개나) 필요하고 어디다 저장해야 하느냐를 먼저 생각해야 한다.
  // boolean
    // 논리형 시스템 타입
  // 논리곱 논리합(and or)
    // &&논리곱 ||논리합
  // for/while
    // 반복문의 사용처
      // 반복되는 것이 있을 때.
      // 많은 데이터(ex.배열)를 활용할 때. '많은 데이터를 다루는 코드'들과 반복문은 같이 잘 쓰인다.
    // for
      // 똑같이 처리되는 것은 실행문 안에서, 변수나 조건, 변하게 해주는 식 등은 조건문에서 작성.
      // 반복 횟수가 정해져 있을 때 주로 씀.
  // switch
    // switch(){}에서 ()안에는 범위가 넓은 조건문이 아닌 하나의 숫자값(정수? 타입의 변수)가 들어간다.
    // 중괄호 안의 case를 처리할 때 CPU는 해당 숫자값으로 한번에 넘어가지 않고, case의 시작부터 순서대로 다 훑어본다.
      // case나 default 마지막에 break;이 들어가있지 않으면, 맞는 케이스를 찾고 나서부터 멈추지 않고 끝까지 다 처리한다.
  // 기타 기본 정보
    // 진한 글씨는 죄다 예약어
    // '연산'은 사칙연산 할 때의 그 연산. CPU가 코드를 '처리'하는 작업과는 다르다.
      // CPU코드는 '처리', 1+1같은 게 '연산'
    // 우리는 20.4와 20을 바로 구분할 수 있지만 컴퓨터는 안됨.
      // 저거는 실수타입이고 저거는 정수타입이라고 떠먹여줘야 됨.
    // i는 보통 인덱스(index)의 줄임말.
    // 자바는 객체지향. 원하는대로 코드를 불러다가 쓸 수 있는 구조.

// 다차원 배열(array)
  // 기본 설명
    // 기본 형태 예시 : int[][] arr = new int[][];
      // 여기서 int는 데이터 타입, arr은 배열 변수 이름, new는 문법.
        // new int[][]은 새로운 int[][](다차원 배열)을 만들겠다는 뜻.
      // 보통 [][]에서 첫 번째 []는 행, 두 번째 []는 열. 행은 가로, 열은 세로.
    // 2차원 배열([][]), 3차원 배열([][][])이 있다.
      // 1열(한줄)짜리 박스와 2열(두줄)짜리 박스, 3열(세줄)짜리 박스라고 생각하면 이해하기 쉽다.
        // 1열짜리 박스로 해결이 안 될 때는 줄을 더 만들어서 2열, 3열 박스를 쓰면 된다.
        // 배열은 행렬을 만드는 것과 같다. (1열 역시 1열짜리 행렬)
    // 실제 코딩할 때 엄청나게 쓴다고 한다.
    // 여기서 저장되는 데이터를 행렬데이터..라고 하나보다. [][]여기 안에 적히는 숫자를 말하는 것 같음.
  // 예시 : int[][] arr = new int[2][3] 일 때(2행 3열) 메모리 배열
    // arr : [ 0, 0, 0 ]
	  [ 0, 0, 0 ]

// 함수(메소드 : method)
  // 함수의 정의(설명)
    // 어떤 취해야 할 액션!들을 묶음으로 묶어놓은 것. 코드의 묶음, 코드 블럭.
      // 주로 자주 사용하는 코드 묶음(액션들)을 편하게 사용하기 위해서 만든다.
    // 함수는 옆에 ()를 붙이고 있다.
    // 함수도 CPU의 흐름 순서에 영향을 준다.
    // 함수도 데이터 타입을 쓴다.
    // 함수를 호출하면 CPU는 기본적인 흐름을 바꿔 해당 함수가 있는 곳으로 점프한다.
    // 함수의 형태는 다양하다.
    // 함수를 만들다 = 함수를 정의(선언?)하다
  // 함수 관련 용어★
    // 예시로 설명 >> int num(int a, b){int c = a + b; return c;}
    // 함수의 이름 : num()
      // 함수 이름 옆에는 꼭 옆에 ()가 있어야한다. 받아야 하는 값이 있는 함수라면 ()안에 파라미터를 넣어야 한다. 없으면 파라미터를 안 넣어도 되지만 ()는 꼭 있어야 함.
      // int 옆에 괄호()를 붙임으로서 CPU는 int를 함수라고 인식한다.
    // 파라미터 : (int a, int b)
      // 괄호 안의 내용을 '함수의 파라미터(parameters, arguments)'라고 한다.
      // 정보를 받아야 하는 함수를 만들 때 그 정보를 받는 곳이며, 어떤 형태로 얼마나 받을지 적는 공간이다. 보통 변수 선언처럼 작성한다.
        // 줄여서 쓰자면 "넘겨받는 값"
      // ','로 복수개를 추가할 수 있다. 이 함수를 호출할 때에도 ','를 써서 구분한다.
      // 받은 파라미터 값은 소속된 함수 안에서 a, b로 선언되어 다양하게 활용할 수 있다.
      // 데이터를 받을 필요가 없으면 함수를 작성할 때 파라미터 작성 없이 ()만 적는다.
      // 받아야 할 값을 만들었는데(파라미터를 작성) 호출할 때 그 값을 쓰지 않으면(()만 적으면) 에러가 난다.
    // return : return c;
      // return은 '값을 돌려준다'는 의미이다. 해당 함수를 호출한 곳에 return값(예시에서는 c)을 돌려준다.
      // void 타입이 아닌 나머지 함수에는 마지막에 return value; <<을 써줘야한다. 여기서 value = 특정 값 or 변수
        // value(예시에서 c), 즉 return값은 "돌려주는 값"이다.
      // return "abc"; 이렇게 문자열을 리턴하는 것도 가능.
    // return의 데이터 타입
        // 함수와 return의 데이터 타입을 정하는 기준은 돌려주려는 값(return값)의 타입이다.
          // 상단 예시에서 c는 int 타입으로 선언되었으므로 함수와 return의 속성은 int가 되어야 한다.
      // "return의 (데이터)타입은 int"라고 표현한다.
    // void
      // return을 하지 않는(return이 필요없는) 함수를 만들 때 쓰는 코드.
      // 마지막에 return을 적지 않는다. 이럴 때 해당 함수를 처리한 다음엔 호출한 곳에 "아무 것도 돌려주지 않는다."
      // 변수 선언을 하려는데 우측에 void를 써서 만든 함수가 쓰이면 에러가 난다.
        // 돌려줄 것이 없는데(void) 변수를 만들겠다고 값을 달라고 하니까 그렇다.
      // 보통 함수를 호출해서 뭔가를 출력하려고 할 때 쓰인다. ex) void print(){}
    // 코드 블럭
      // 코드의 묶음. 중괄호 사이에 코드를 담아놓은 것을 말한다.
    // 함수를 활용할 때, 함수를 호출한다, 콜한다, 가져다 쓴다고 표현한다.
  // 예시
    // '물 마시기' 작업 : 컵을 가져온다 > 컵에 정수기 물을 따른다 > 컵에 담은 물을 마신다 (액션 예시)
    // println()이나 print()도 함수. Java에서 미리 만들어 놓은 함수이다.
    //  static int add(int a, int b){
        int c = a + b;
        return c;
        }
       ----------------------------
        public static void main(String[] args) {

        int ret = add(3,4);
        System.out.println(ret);

        }일 때 메모리 예시
        -----add----- // add()함수를 호출하면 main 위에 add 메모리가 생성됨
        a : 3 // main 함수의 add(3,4)에서 준 값을 받은 add 함수에서 a와 b가 "변수 선언됨".★중요
        b : 4
        c : 7 // add에서 변수 c를 선언하고, 이 값을 main으로 다시 return함. return하고 역할을 끝낸 add함수 영역은 메모리에서 지워짐.★
        -----main-----
        ret : 7 // add를 처리하고 return받은 값 c가 변수 ret값으로 초기화됨.
        // 여기서 main과 add는 다른 영역이어서, 만약 각 영역에서 같은 a(ex.변수)를 쓴다고 해도 다르게 적용된다.★200511 월요일 수업에 쓰인 함수



// 복습(String)
        int a = 10;

        String sns = "hello world";
        System.out.println(sns);

        String word = "Welcome";

        String sum_string = sns + " " + word;
        System.out.println(sum_string);

        System.out.println(sns + " " + word);

        System.out.println(sns + a);

        System.out.println(5+4);
// 결과값
> Task :libjava:MyClass.main()
hello world
hello world Welcome
hello world Welcome
hello world10
9



// 복습2
        int result = 1 + 2;
        System.out.println("1 + 2 = " + result);

        result = result - 1;
        System.out.println("3 - 1 = " + result);

        result = result % 2;

        System.out.println("2 % 2 = " + result);

        result++;
        System.out.println(result);
        result++;
        System.out.println(result);
// 결과값
> Task :libjava:MyClass.main()
1 + 2 = 3
3 - 1 = 2
2 % 2 = 0
1
2



// 복습3
        int result = 3;

        result += 3;
        System.out.println(result);

        result -= 2;
        System.out.println(result);
        
        result *= 4;
        System.out.println(result);
        
        result /=3;
        System.out.println(result);
// 결과값
> Task :libjava:MyClass.main()
6
4
16
5



// boolean & if
        boolean isAlien = true;

        if(isAlien == false){
            System.out.println("It is not an alien.");
        }else{
            System.out.println("It is an alien.");
        }
// 결과값
> Task :libjava:MyClass.main()
It is an alien.



// if문
        int score = 77;

        if(score > 100 || score < 0){
            System.out.println("Input correct number.");
        }else if(score <=100 && score >=90){
            System.out.println("A Grade");
        }else if(score >= 80){
            System.out.println("B Grade");
        }else if(score == 77){
            System.out.println("Lucky number!");
        }else{
            System.out.println("C Grade");
        }
// 결과값
> Task :libjava:MyClass.main()
Lucky number!



// 0부터 100까지 짝수의 합을 구하시오(복습)
        int sum = 0;
        for(int a = 0; a <= 100; a = a + 2){  //a = 0(시작점), a = a + 2가 짝수를 구하는 것.
            sum = sum + a;
            }
            System.out.println(sum);
        
        int sum1 = 0; // 합계를 표시할 함수
        int i = 2; // 시작 변수, 더하는 변수
        while(i <= 100) {
            sum1 = sum1 + i;
            i = i +2;
        }
        System.out.println("sum1 is : " + sum1);
// 결과값
> Task :libjava:MyClass.main()
2550
sum1 is : 2550



// 혼자 만들어본 코드(성공) & 배열 예시(아래)
        int[] student_score_arr = new int[100];

        student_score_arr[0] = 100;
        student_score_arr[1] = 28;
        student_score_arr[2] = 30;
        student_score_arr[3] = 50;
        //...

        String[] student_name = new String[100];

        student_name[0] = "KKH";
        student_name[1] = "SSL";
        student_name[2] = "OKT";
        student_name[3] = "SGD";

        for(int number = 0; number < 4; number++){
            System.out.println(student_name[number] + "'s score : " + student_score_arr[number]);
        }

        for(int a = 0; a < 100; a++){
            student_score_arr[a] = 50;
        }
        System.out.println(student_score_arr[5]);
// 결과값
> Task :libjava:MyClass.main()
KKH's score : 100
SSL's score : 28
OKT's score : 30
SGD's score : 50
50



// 2차원 Array 예시
        // 7개반, 반별 15명 학생들의 평균점수들을 저장
        double[][] average_score_arr = new double[7][15];
        // 학생 수 20명, 국어, 영어, 수학 점수를 저장
        // 1명당 3과목, 즉 3개의 데이터를 저장
        int[][] student_score_arr = new int[20][3];
        // 쇼핑몰 회원수 100명, 장바구니에 물건 25개까지 보관 가능
        // 1명당 25개까지 보관 가능
        int[][] pack_arr = new int[100][25];
        // 사진파일 가로100 세로100픽셀, 3개의 색깔로 저장함(저장은0~255까지의 숫자)
        // 100행 100열짜리가 3개씩. 3차원 배열. 이미지 연산은 3차원 배열을 씀.
        short[][][] picture_color = new short[100][100][3];
        // 학생20명, 국어,영어,수학점수 저장, 과목마다 중간,기말 저장
        // 학생 1명당 과목3개, 과목당 2개(중간,기말)씩
        int[][][] middle_score = new int[20][3][2];



// 2행 3열 array
        // int i, j; 로 정의하고 각각 따로 초기화시켜줘도 된다.
        int[][] arr = new int[2][3];
        for(int i = 0; i < 2; i++){
            for(int j = 0; j < 3; j++){
                arr[i][j] = 10;
            }
        }



// 함수 만들기(add)
package com.tenisme.libjava;

public class MyClass {

    int add(int a, int b){
        int c= 0;
        c = a + b;
        return c;
    }
    public static void main(String[] args) {
        
    }
}
// 결과값
이 때 CPU는 아무 작업도 안 한다. psvm에 할 게 없기 때문이다.



// 함수 만들기(호출하기)2
package com.tenisme.libjava;

public class MyClass {

    static int add(int a, int b){ // int a = 3; int b = 4;로 바로 적용된다.
        int c = 0;
        c = a + b;
        return c;
    }
    public static void main(String[] args) {

        int ret = add( 3, 4 );
        System.out.println(ret);

    }
}



// 함수 만들기(호출하기)3-1 에러문구
package com.tenisme.libjava;

public class MyClass {

    static void say_hello(){
        System.out.println("Hello~");
    }
    public static void main(String[] args) {

        int ret = say_hello(); // 여기서 에러남.

// 3-2 정상문구
package com.tenisme.libjava;

public class MyClass {

    static void say_hello(){
        System.out.println("Hello~");
    }
    public static void main(String[] args) {

        say_hello();

    }
}

//3-3 오류문구
package com.tenisme.libjava;

public class MyClass {

    static void say_hello(String name){
        System.out.println("Hello~");
    }
    public static void main(String[] args) {

        say_hello(); // 함수는 String 문자열을 받겠다는데 얘 괄호 안에는 뭐가 없어서 에러남.

    }
}

//3-4 파라미터 두개(두 항목을 받겠다) 하나는 문자열, 하나는 정수를 받음.
package com.tenisme.libjava;

public class MyClass {

    static void say_hello(String name, int age){
        System.out.println("Hello My name is " + name + " I'm " + age + "years old");
    }
    public static void main(String[] args) {

        say_hello("Mike",30);

    }
}



// 과제 : 1. 숫자 3개의 평균을 리턴하는 함수를 만드세요. 2. 3개의 숫자 345, 6783, 12345의 평균을 구해서 출력하세요. (성공 :3)
삐. 결과값이 소수점이 나올 수 있으므로 정수 결과값만 보여주는 int가 아니라 실수 속성인 double을 써야함.
package com.tenisme.libjava;

public class MyClass {

    static int average(int a, int b, int c){
      int d = 0;
      d = (a + b + c)/3;
    return d;

    }
    public static void main(String[] args) {

        System.out.println(average(345,6783,12345));

    }
}
// 결과값
> Task :libjava:MyClass.main()
6491.0

// 정정받은 것
package com.tenisme.libjava;

public class MyClass {

    static double get_average(double a, double b, double c){
      double d = 0; // 강사님은 여기에 double average = (a + b + c) / 3 밑줄에 return average; 이렇게만 적으셨음.
      d = (a + b + c)/3;
    return d;

    }
    public static void main(String[] args) {

        double ret = get_average(345, 6783, 12345);
        System.out.println(ret);

    }
}
// 결과값
> Task :libjava:MyClass.main()
6491.0 // 똑같은 거 아녀...? 차피 딱 떨어지긴 하네 평균이



// 과제2 : 숫자를 파라미터로 받으면, 해당 숫자만큼 "Hello"를 출력하는 함수
// 숫자 5를 입력하여 해당 함수를 호출합니다. (Hello를 5번 호출) > 위의 함수가 5번(카운트번)을 찍어야 함. 
package com.tenisme.libjava;

public class MyClass {

    static void say_hello_cnt(int cnt){
        for(int i = 0; i < cnt; i++){
            System.out.println("hello");
        }
    }


    public static void main(String[] args) {

        say_hello_cnt(5);

    }
}
// 결과값
> Task :libjava:MyClass.main()
hello
hello
hello
hello
hello



// 실습3 : 과일 등급을 반환하는 함수를 작성하세요. 과일 크기를 입력으로 받으면, 등급을 리턴하는 함수.
과일 크기 등급 16~30 A 8~15 B 1~7 C
package com.tenisme.libjava;

public class MyClass {

    static String get_fruit_grade(int size) {
        if (size >= 16 && size <= 30) {
            return "A";
        } else if (size >= 8 && size <= 15) {
            return "B";
        } else if (size >= 1 && size <= 7)
            return "C";
    
        return "Size is Wrong."  < 꼭적어주기
    }

    public static void main(String[] args) {

 


    }
}



// 숫자 2개를 함수입력 받으면, 앞 숫자에 숫자승을 하여, 결과를 리턴하는 함수를 만드세요.
 숫자 2, 3을 넣으면 2의 3승을 하는 함수, 5, 6을 넣으면 5의 6승을 하는 함수. (빗금친 거 내가 하다 만 거)
package com.tenisme.libjava;

public class MyClass {

//    static int result(int a, int b){
//        for(int c = 1; c <= b; c++){
//             a = a * c;
//        }
//        return a;
//    }

    static double get_pow(int num, int cnt){ ★★다시보기
        double result = 1;
        for(int i = 0; i < cnt ; i++){
            result = result * num; // i는 카운트해주는 역할만 함
        }
        return result;
    }


    public static void main(String[] args) {

//        int d = result(2,3);
//        int e = result(5,6);
//
//        System.out.println(d);
//        System.out.println(e);

        System.out.println("2^3 = " + get_pow(2,3));
// 돌아가는 코드는 최대한 위에 끌어올려야겠다. 밑에서는 간단해지게. 위에처럼.

    }
}



// 실습4 : 숫자 배열을 입력받으면, 이 중에 음수의 개수가 몇개인지 리턴하는 함수를 만드세요.
// 파라미터로 넘어온 배열에서, 음수의 개수를 카운팅해 리턴한다.
package com.tenisme.libjava;

public class MyClass {

    static int get_minus_cnt(int[] arr){
        int minus_cnt = 0;
        for(int i = 0; i < arr.length; i++){
            if(arr[i] < 0){ // 배열 불러오기, 마이너스 값을 구해야 하기 때문에 < 0
                minus_cnt = minus_cnt + 1; //마이너스 카운트 추가
            }
        }

        return minus_cnt;

    }

    public static void main(String[] args) {

        int[] arr = {5,7,-23,-1,99,321,-99};
        int ret = get_minus_cnt(arr);
        System.out.println("minus cnt is : " + ret);
        
    }
}
// 결과값
> Task :libjava:MyClass.main()
minus cnt is : 3



// 예문(질문에 대한 대답)
package com.tenisme.libjava;

public class MyClass {

    static int add(int x, int y, int z({
        int sum = x+y+z;
        return sum;
    }) // 리턴 있는 거

    static void say(int x){
        int z = x * 100;
    } // void 있는 거

    public static void main(String[] args) {

        int ret = add(3,4,5); // 변수에 저장
        add(3,4,5); // 저장 안됨 차이
        System.out.println(ret); // add는 정의를 안 했기 때문에 못 넣음.

    }
}



// switch 예문
        int a = 3;
        switch(a){
            case 1:
                System.out.println("Hello");
                break;
            case 2:
                System.out.println("Cat");
                break;
            case 3:
                System.out.println("dog");
                break;
            default:
                System.out.println("nothing");
                break;
// 결과값
> Task :libjava:MyClass.main()
dog200512 화요일 수업 내용 요약

// 함수(메소드)
  // 함수의 속성
  // 함수 설명
  // 파라미터
  // 주의사항
  // void
  // main

// 클래스(틀)
  // 클래스의 정의
  // 클래스의 속성
  // 클래스 생성
  // 객체(인스턴스, 오브젝트, 실물) : 상태(구성요소), 동작(액션, 행동)
    // 객체의 생성 과정
  // Stack, Heap
  // 클래스 내 함수(액션) 활용시 CPU의 흐름

  // 기타 기본 설명

// 기본 지식200512 화요일 수업 메모 정리



// 함수(메소드)
  // 함수의 속성
    // 함수를 호출하면 해당 함수를 찾아서 처리한다.
    // 함수는 해당 함수를 불러들일 때에만 메모리 영역이 잡힌다. 그 전에는 영역을 할당하지 않는다.
    // 함수끼리는 서로 상대방 영역을 침범하지 않는다.
      // 헷갈릴 일만 없으면 변수의 이름이 같다거나 해도 서로 간섭하지 않는다.
    // 처리가 다 끝난 함수는 메모리에서 지워진다. (메모리 영역이 생겼다가 없어진다)
    // 메인과 다른 함수가 있으면 메인 먼저 처리하기 시작한다.
      // 다른 함수는 호출할 때만 처리된다.
  // 함수와 함수의 관계
    // 보낼 거 있으면 보내되 돌아오는 값이 없을 수도 있고(void)
    // 보낼 것도 받을 것도 없을 수도 있고(void)
    // 보낼 건 없는데 돌려받는 건 있을 수 있고(void 외 타입)
    // 값을 위로 올리고 밑으로 돌려받을 수도(void 외 타입) 있다.
  // 파라미터
    // 파라미터 안에 있는 변수는 해당 함수의 메모리 영역이 "생겼을 때" "그 영역 안에서" 파라미터의 개수만큼 선언된다.
      // 이 때 a와 b의 타입은 함수 타입이 아니라 파라미터 내에서 지정했던 타입이다.
  // 주의사항
    // 함수는 호출하는 것. 안 부르면 안 옴. 처리 할 거 다 하면 메모리 사라짐.
  // void
    // 리턴이 없으면 돌아오는 값이 없다. 돌아오는 게 없으면 CPU는 할 일이 없다. 그냥 넘어간다.
    // void 타입 함수여도 printnl()은 실행되는 이유
      // void는 돌려주는 값만 없다 뿐이지 불러진 이상 자신의 코드 블럭을 전부 실행하고 끝난다. void 타입 함수 안에서 println()이 실행되었으므로 출력값을 보이고 끝나게 된다.
        // 다른 함수의 어느 위치에서 불러졌어도 마찬가지.
    // void 타입 함수는 다 처리되고 나서 메인으로 가도 돌려준 데이터가 없기 때문에 CPU 입장에서는 add();에서 ;만 남게 된다.
  // main



// 클래스(틀)
  // 클래스의 정의
    // 클래스는 틀.
      // 객체들의 공통점을 찾아내서, 하나의 틀로만든 것. 틀. 그것이 클래스.★
    // 클래스는 코드의 묶음.
      // 코드를 짤 때 클래스라는 묶음으로 묶어서 짠다.
      // 클래스의 집합들(함수와 변수)를 잘 이용해서 앱을 돌아가게끔 프로그래밍하는 것.
    // 구성요소와 행동, 이 두가지 요소를 만족시키는 것이 클래스.
    // (예시) 어떤 사물을 코드로 옮길 때 클래스를 만들어서 코드를 짜볼 수 있다.
      // 클래스 이름 : 책상 / 클래스 구성요소 : 받침대, 다리, 바퀴, 서랍 등 / 행동 : 받침대로 물건을 받침, 바퀴로 굴러갈 수 있음, 엎드릴 수 있음 등
    // 구성요소와 행동이 있을 때 완성된 클래스라고 함.
    // 표현 : 클래스는 생성(하면서 정의)된다, 객체는 저장(선언)된다.
    // 클래스 안의 구성요소(변수)를 이 클래스의 멤버 변수라고 부른다.
    // 클래스 안의 행동을 담당하는 함수는 메소드(method)라고 부른다.
  // 클래스의 속성(규칙)
    // 함수 위에 있는 것이 클래스.
    // 클래스의 행동은 "함수".
      // 클래스가 할 수 있는 행동. 함수! 여기에는 static이 없음.
    // 클래스 이름의 첫 시작은 무조건 대문자여야 한다.
    // 패키지 > 클래스 > 함수(메소드) > 코드 블록
    // 클래스는 '클래스이름' 클래스라고 부른다.
    // 각각의 클래스는 서로 다른 클래스에서 구성요소나 행동을 불러와 실행시킬 수 있다.
    // CPU는 무조건 main함수에서 시작.
      // 클래스 파일이 몇개여도 시작은 main함수가 있는 파일부터 시작된다.
    // 클래스의 함수 호출! p1.print(); << Product에 연결된 변수 p1을 호출하고, Product에 있는 print()함수를 호출한다. print()는 p1을 호출한다. ★
    // new가 있을 때마다 클래스(틀)을 새로 찍음. 같은 클래스여도 새로 찍음. 똑같은 제품의 틀로 같은 실물을 여러 개 찍어내듯이.
    // Student 클래스에 sum 함수를 만들면, "sum은 Student의 메소드"라고 말할 수 있다.
    // 한 클래스 안에서는 멤버 변수를 그대로 메소드에 가져다 쓸 수 있음.★
  // 클래스 생성
    // 클래스의 기본 형태
       class(클래스명{

	멤버 변수1; // 클래스의 구성요소
	멤버 변수2;

	멤버 메소드(){} // 클래스의 행동
       }
    // 클래스 예시 (메소드 생성)의 메모리 상태
      ---Student---(Heap)
      name : "Mike"
      kor : 90
      eng : 95
      math : 100
      sum : 247
      average : 95.0
      ---st1.sum()---(Stack) <<< 다 쓰면 닫힘.
      ---st1.avg()---(Stack) <<< 위와 같음
      ---main---(Stack)
      st1 : 
  // 주의사항
    // 객체(인스턴스, 오브젝트), 함수(메소드), 클래스는 다 다르므로 헷갈리지 말자.
    // 붕어빵 틀(클래스)만 있다고 붕어빵(실물)이 나오는 것은 아님. 클래스는 실물은 아님.
    // main이 포함된 클래스가 아닌 다른 클래스를 수행시키려면 'CPU가 작업을 수행하는 곳'에서 불러와야 한다. 즉 main 함수 안에서 불러와야 한다.
      // 같은 말 : CPU는 메인으로 들어와서 처리하니까 메인에 객체를 만들어야 하는 것.
      // 처리해야 되니까!
    // 클래스는 항상 남(다른 클래스 등)을 위해 작동하는 것으로 만들어야 함.
      // 남을 위한 액션을 만들 때 예시 : 화면에 출력하는 행동 void print(){}
    // main에는 Product에 연결되는 변수 p1만 저장되는 것에 주의
    // 객체 자체가 없는데(객체라는 걸 만든 게 없는데) 객체에 저장하라고 그러믄 안된다.
      // 저장하기 위해서는 객체를 만들어야 한다.
        // arr[i] = new Point(); << 객체 만들기. 이거 이해안감.



// 객체(인스턴스, 오브젝트, 실물) : 상태(구성요소), 동작(액션, 행동)
  // 객체란 무엇인가
    // 객체 = 상태(구성요소)와 동작(액션,행동)
    // 이렇게 뽑아낸 객체는 상태와 동작을 갖는다.
    // 실물 = 객체 = 오브젝트 = 인스턴스
    // 객체를 만드는 과정 = 일정한 틀을 메모리에 찍는 과정
  // 객체지향(Object Oriented) 프로그래밍
    // 코딩을 할 때 두가지 관점
      // 해당 물건(만들고 싶은 것)의 구성요소가 무엇이냐.
      // 해당 물건(만들고자 하는 것)이 행동할 수 있는 액션(행동)은 무엇이냐.
        // 위 두가지 관점에서 코드를 짜는 것이 객체지향 프로그래밍.★
  // 객체의 생성 과정
    // 실물을 만드는 코드 : Product(클래스명) p1 = new Product(); ★객체만들기
      // 클래스로 객체를 만드는(생성하는) 방법이다.
      // new를 써야 실물(붕어빵)이 만들어짐.
      // 실물을 만들겠다 = 객체를 만들겠다
    // Product(클래스명) p1 = new Product();가 Heap에 저장하는 메모리가 오브젝트이다.★
      // 여기서 Product()는 함수. 객체 생성시 클래스명=함수명이어야 함.
      // new는 실물을 새로 만든다는 뜻.
      // 오브젝트 메모리는 Heap 메모리 영역에 저장된다.
      // Student st1 = new Student(); << 붕어빵 찍기.
        // 틀은 Student. 붕어빵은 Heap에 저장되는 Student 클래스의 객체 메모리.
        // 붕어빵에 뭐 넣을지 정하는 게 st1.name = "Mike";
  // 객체의 활용
    //      p.number = 1; // 클래스의 구성요소 호출
            p.name = "Monitor";
      ---Product - p---
      number : 1
      name : "Monitor"
      // p가 가리키는 애(클래스)의 number로 감.
      // p가 가리키는 애(클래스)의 name로 감.★
      // 가서 메모리를 저장함.
      //. (점)의 뜻 : p가 가리키는 애(클래스)
        // 점을 기준으로 오른쪽은 ~를 불러냄으로 해석.
        // .은 화살표!!!
    // 객체를 저장하는 과정은 d1.name = "Mike"; 이렇게 됨.★
    // 객체를 응용하게 되면 객체 안에 객체 안에 객체... 이런 식이 된다.
    // 다른 클래스에 있는 객체(멤버 변수)가 또 다른 클래스의 멤버 변수로 사용됨★ 예시~
      // 클래스와 클래스의 관계. 어떤 클래스에 다른 클래스가 포함되는 관계.
      // ex) Shape 클래스의 멤버 변수 자리에 Point p = new Point(); 가 있을 때
        // Point 클래스의 객체를 생성해서 멤버 변수로 가지고 있어라.
        // Point p = new Point(); //여기서 Point는 Class 이름. Point class를 불러들이는 p변수를 저장.
    // 배열과 객체 생성의 조합
      // Point[] arr = new Point[5]; // 포인트 오브젝트(객체)를 5개 만들어라.
        // 참고 : 기존 객체 생성 방법과 헷갈리지 말 것. Point arr = new Point();



// Stack, Heap
  // 램카드 OS(오퍼레이트 시스템) 메모리 영역은 네가지로 나뉜다.
    // 여기서 중요한 메모리는 Stack메모리와 Heap메모리이다.
  // 모든 함수는 전부 Stack에 저장된다. 물론 다 수행하면 사라진다.
    // 저장하면 할수록 메모리 영역이 잡힌다.
  // 메모리가 생기는 건 실체가 있다(생겼다)는 뜻이다.
  // Heap메모리에는 Product-p1 영역이 만들어지고(+파라미터가 있는 경우 이것들까지 선언됨), p1은 p1을 만든 함수의 메모리에(여기서는 main) 저장된다.
    // p1은 메모리상으로는 값이 없지만, p1이 쓰일 때 Product-p1(Heap)에 연결시켜주는 역할을 한다.
    // 그리고 Product - p2 안에 저장된 변수 이름을 불러내 저장하면 그건 Product - p2(Heap)의 메모리에 저장됨.
      // 같은 말 : p1.name에서 변수값을 저장하면 main(stack)이 아니라 Heap(객체를 저장하는 메모리)에 저장된다.



// 클래스 내 함수(액션) 활용시 CPU의 흐름



// 기본 지식
  // 메모리는 메모리 카드에 저장된다.
  // 메모리와 화면 출력은 아무 관계가 없다.
    // 메모리는 저장, 화면은 출력일 뿐이다.
  // 메모리는 OS가 지운다.
  // 자바는 클래스로 시작해서 클래스로 끝난다. 클래스가 끝이다.
  // CPU가 처리하는 기준(규칙)을 알아야 한다.
  // com.은 폴더. 패키지.
  // 자바 프로그래밍은 클래스를 설계하는 일이다.
  // 프로그래밍은 copy 앤 paste~
  // 주황색 드래그 표시 : 주황색 표시에 커서 갖다댔을 때 나오는 대로 수정해라.
  // 캐스팅 : 데이터 타입을 바꿔주는 것.
    // ex) st1.average = (double)st1.sum / 3;
    // 이렇게 해줘야 소수점으로 나눠진다. 안 그러면 정수로 출력? 정수로 계산? 아무튼 결과값이 소수점이 될 수 있도록.
  // 객체의 연결, 클래스의 연결
  // st1도 '변수'라고 부른다. "Student 타입(함수)의 변수 st1"
  // 클래스에서 함수 만들고 활용하기. 클래스의 활용.
  // 어떤 클래스가 있는지, 뭘 제공해주는지, 언제 어떻게 쓰고 활용해야 하는지 배워야 함.
  // main 함수는 두 개가 있으면 오류난다. 전 파일에 하나만 있어야 한다. 두 개 있으면 오류남.★
  // 왠만한 코드들은 다른 클래스에 만들어서 main에 적을 때는 코드를 적게 적도록 해야 세련된 코딩. ★
  // 앞으로 두 칸으로 나눠진 박스 그림은 클래스라고 생각하기.
  // 함수는 메모리에 저장되는 거 아님.
  // 보통 앱 만들 때 하나의 화면당 하나의 클래스가 들어간다. 두 개가 들어가기도 한다.
  



// 도움되는 말
  // 결과는 기준이 있어야 한다. 만들고 싶은 결과가 무엇인지 정확히 알아야한다.
  // 설계 = 소프트웨어 디자인 >> 연봉~
  // 반복반복반복.


200512 화요일 수업에 쓰인 코드





// 함수 복습
package com.tenisme.libjava;

public class MyClass {

    static int mul(int a, int b){
        int c = a * b;
        System.out.println("hello");
        return c;
    }

    public static void main(String[] args) {

        System.out.println("Start");
        int a = 4;
        int b = 7;
        int c = mul(a, b);
        System.out.println(c);

    }
}
// 결과값
> Task :libjava:MyClass.main()
Start
hello
28





// 함수 복습2
package com.tenisme.libjava;

public class MyClass {

    static void some(int a, int b) {
        int c = a + b;

    }


    public static void main(String[] args) {

        int c = 7;
        some(10, 20);
        System.out.println(c);

        //307
    }
}
// 결과값 예상 307 (30따로 7따로)
// 실제 결과값 (7만 찍힘)
> Task :libjava:MyClass.main()
7





// 함수 복습3
package com.tenisme.libjava;

public class MyClass {

    static int some(int a, int b) {
        int c = a * b + 3;
        return c;
    }


    public static void main(String[] args) {

        int c = 7;
        some(1, 1);
        System.out.println(c);


    }
}
// 예상 결과값 47(4 따로 7 따로)
// 실제 결과값 (7..) some으로 뭘 안 해서 그런가봄.
> Task :libjava:MyClass.main()
7
// 만약에 System.out.println(some(1, 1));로 되어있으면 4를 출력함.





// 함수 복습4
package com.tenisme.libjava;

public class MyClass {

    static int some(int a, int b) {
        int c = a * b + 3;
        return c;
    }


    public static void main(String[] args) {

        int c = 7;
        c = some(1, 1) + 10;
        System.out.println(c);


    }
}
// 결과값
> Task :libjava:MyClass.main()
14





// 함수 질문(왜?1)
package com.tenisme.libjava;

public class MyClass {

    static void some(int a, int b) {
        int c = a * b + 3;
        System.out.println(c);
    }


    public static void main(String[] args) {

        some(1, 1);



    }
}
// 결과값
> Task :libjava:MyClass.main()
4





// 실습1
package com.tenisme.libjava;

public class MyClass {

    static String some(String name){
        String sentence = "Hello " + name;
        System.out.println(name);
        System.out.println("bye"); // 1. 여기까지의 화면출력하는 내용 & 메모리 내용 적기
        return sentence;
    }

    public static void main(String[] args) {
        System.out.println("This is Main");
        some("Mike"); // 2. CPU가 여기까지 실행했을 때
        String my_sentence = some("Mike");
        System.out.println(my_sentence); // 3. CPU
        System.out.println(some("Mike")); // 4. CPU

    }
}
// CPU의 메모리 처리
1.
---some---
name : "Mike"
sentence : "Hello Mike"
---main---


2.
---main---


3.
---main---
my_sentence : "Hello Mike"


4.
---main---
my_sentence : "Hello Mike"
// 출력값(//제외)
> Task :libjava:MyClass.main()
This is Main // main에서 출력 수행
Mike // some을 불렀으므로 some 수행
bye
// sentence = Hello Mike는 return되었지만 아무 것도 하지 않았으므로 밑에 출력도 되지 않음
Mike // some을 불렀으므로 다시 수행
bye
Hello Mike // 변수 my_sentence에 저장한 return값(sentence)를 출력 명령했으므로 출력
Mike // some을 불렀으므로 다시 수행됨
bye
Hello Mike // some을 부르고 돌려받은 sentence를 출력 명령했으므로 출력





// 클래스 파일 만들고 그 클래스를 활용한 객체 만들기
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {
        System.out.println("I an main");
        Product p1 = new Product(); // Product : 클래스 이름
    }
}





// 클래스 예시1
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        int a = 10;
        Product p = new Product();
    }
}





// 클래스 예시2

package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {
//        System.out.println("I an main");
        int a = 10;
        Product p = new Product();
        p.number = 1;
        p.name = "Monitor";

        Product p2 = new Product();
        p2.number = 2;
        p2.name = "Keyboard";
    }
}
---Product - p---(클래스 예시2)
number : 1
name : "Monitor"
---Product - p2---(dog 클래스에 속하는 p2가 heap에 새로 저장됨)
number : 0
name : 
이 과정을 거치고 메인에는
---main---(Stack)
a :10
p : 
p2 : (p2가 main에 저장됨)
이 과정이 클래스로 객체를 생성하는 방법.★★★★★★★★★
그리고 Product - p2 안에 저장된 변수 이름을 불러내 저장하면 그건 Product - p2의 메모리에 저장됨.
---Product - p2---(Heap)
number : 2
name : "Keyboard"
d, d2 등을 만드는 것까지가 객체를 만드는(생성하는) 과정.★
그리고 객체를 저장하는 과정은 d1.name = "Mike"; 이렇게 됨.★






// 클래스 예시3 main함수에서 product의 실체를 만들 거임.(예시3)
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {
//        System.out.println("I an main");
        int a = 10;
        Product p = new Product();
        p.number = 1;
        p.name = "Monitor";

        Product p2 = new Product();
        p2.number = 2;
        p2.name = "Keyboard";
        
        System.out.println(p2.number);
        System.out.println(p.number);
        System.out.println(p.name);
        System.out.println(p2.name);
    }
}
// 결과값





// 예제1 : Dog 클래스를 만들어라.
// name, age 두 개의 요소를 가지고 있다.
// 이 클래스를 가지고 객체 2개를 만들어라. ★객체의 정의 적을 때 참고
// 첫 번째 객체 : Mike, 1
// 두 번째 객체 : Paul, 2
// 그리고 만든(저장된) 객체들의 값들을 화면에 출력.
package com.tenisme.libjava; // dog클래스

public class Dog {
    String name;
    int age;
}
package com.tenisme.libjava; // Myclass(main함수가 있는 클래스)

public class MyClass {


    public static void main(String[] args) {

        Dog d1 = new Dog();
        Dog d2 = new Dog();

        d1.name = "Mike";
        d1.age = 1;
        d2.name = "Paul";
        d2.age = 2;

        System.out.println(d1.name);
        System.out.println(d1.age);
        System.out.println(d2.name);
        System.out.println(d2.age);



    }
}
// 결과값
> Task :libjava:MyClass.main()
Mike
1
Paul
2
썽공


// 예제2
// 1. 다음과 같은 데이터를 처리하는 클래스를 만들어라.
// 학생
// 이름 : 장동건 국어 : 90 영어 : 80 수학 : 100 총점 : 270 평균 : 93.1
package com.tenisme.libjava;

public class Student {
    String name;
    int kor;
    int eng;
    int math;
    int sum;
    double average;
}
// 2. main 함수에서 Student 클래스를 통해 2개의 학생을 만들고, 데이터를 입력해라.
// Mike, 90, 95, 100, 총점, 평균
// Paul, 80, 90, 70, 총점, 평균
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        Student st1 = new Student();
        Student st2 = new Student();

        st1.name = "Mike";
        st1.kor = 90;
        st1.eng = 95;
        st1.math = 100;
        st1.sum = st1.kor + st1.eng + st1.math;
        st1.average = (st1.kor + st1.eng + st1.math) / 3; // 슨생님은 st1.sum / 3라고 적으셨음. 나야 머리를 좀 씁시다.

        st2.name = "Paul";
        st2.kor = 80;
        st2.eng = 90;
        st2.math = 70;
        st2.sum = st2.kor + st2.eng + st2.math;
        st2.average = (st2.kor + st2.eng + st2.math) /3;

    }
}
// 3. 첫번째, 두번째 사람의 이름, 총점, 평균을 출력하라★★★요거 재사용할거임
// 출력 양식 : Mike, sum : 723, average : ~
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        Student st1 = new Student();
        Student st2 = new Student();

        st1.name = "Mike";
        st1.kor = 90;
        st1.eng = 95;
        st1.math = 100;
        st1.sum = st1.kor + st1.eng + st1.math;
        st1.average = (double)st1.sum / 3;

        st2.name = "Paul";
        st2.kor = 80;
        st2.eng = 90;
        st2.math = 70;
        st2.sum = st2.kor + st2.eng + st2.math;
        st2.average = (double)st2.sum /3;

        System.out.println(st1.name + ", sum : " + st1.sum + ", average : " + st1.average);
        System.out.println(st2.name + ", sum : " + st2.sum + ", average : " + st2.average);

    }
}
// 결과값(썽공)
> Task :libjava:MyClass.main()
Mike, sum : 285, average : 95.0
Paul, sum : 240, average : 80.0





// 클래스 예시3
package com.tenisme.libjava; // Product 클래스

public class Product {
    int number;
    String name;

    void print(){ // 출력용 함수는 보통 void를 쓰는 것에 유의.
        System.out.println("number = " + number);
        System.out.println("name = " + name);
    }
}

package com.tenisme.libjava; // Myclass 클래스

public class MyClass {


    public static void main(String[] args) {

        Product p1 = new Product();
        Product p2 = new Product();

        p1.number = 1;
        p1.name = "Computer";
        p2.number = 2;
        p2.name = "Mouse";

        p1.print();
        p2.print();

    }
}
// 결과값
> Task :libjava:MyClass.main()
number = 1
name = Computer
number = 2
name = Mouse // main이 부른 Product 클래스의 함수 print가 수행됨.





// 클래스 예시 (메소드 생성)
package com.tenisme.libjava; // Student 클래스

public class Student {
    String name;
    int kor;
    int eng;
    int math;
    int sum;
    double average;

    void sum(){
        sum = kor + eng + math;
    }

    void avg(){
        average = (double)(kor + eng + math) /3;
    }
}
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        Student st1 = new Student();
        Student st2 = new Student();

        st1.name = "Mike";
        st1.kor = 90;
        st1.eng = 95;
        st1.math = 100;
        st1.sum(); // Student 클래스에서 계산됨. 계산값(sum)은 ---Student---(Heap) 여기에 저장됨. 돌려받는 것 없는 함수이므로 여기서 종료.
        st1.avg();
        System.out.println(st1.name + ", " + st1.sum + ", " + st1.average);
  // st1.sum -> sum은 Student 클래스에 있고, 이 클래스의 sum은 위에서 sum()함수를 불러들여 연산된 값이 ---Student - st1---에 저장되어있는 상태이므로 불러들일 값이 있는 상태가 됨. 그래서 println에서 값이 출력된 것임.
    }
}
// 결과값
> Task :libjava:MyClass.main()
Mike, 285, 95.0
// Student 클래스에서 메소드를 생성해서 이름, 합계, 평균을 출력하는 함수를 만들기 함수 이름 : print
  // 내가 한 거
    void print(){
        System.out.println(name + ", " + sum + ", " + average);
    }
// 숫자(정수) 하나를 입력받으면, 해당 숫자를 kor이랑 곱한 후, 리턴하는 메소드를 만들어라. 썽공
    int mul(int a){ <<Student 클래스에서 메소드 생성
        a = a * kor; // 새로운 변수를 만드는 게 나음. a를 직접 바꾸는 경우는 a값을 바꿔야만 하는 경우에만 쓰임.★
        return a;
    }
        Student st1 = new Student(); << MyClass 
        Student st2 = new Student();

        st1.name = "Mike";
        st1.kor = 90;
        st1.eng = 95;
        st1.math = 100;

        int mul = st1.mul(3); // 리턴하는 메소드 적용
        System.out.println(mul); // 출력
// 출력값
> Task :libjava:MyClass.main()
270
  // 선생님이 한 거
Student 함수 이름 mul -> get_score
Student 함수 이름 a = 가 아니라 int ret으로 새 변수를 선언함. 이유는 해당 코드 옆에 적어놓음.
슨생님은 System.out.println(st1.mul(3)); 이런 형식으로 적으심.





// 문제 : 정수를 입력받아서, 해당 정수보다 평균점수가 크면, "A Grade"를 리턴하고, 그렇지 않으면 "F grade"를 리턴하는 함수. 성공 :3
  // 내가 한 것
    void grade(int x){ // Student 클래스에 grade 메소드 만듦
        String a = "A Grade";
        String f = "F Grade";
        if(x > average){
            System.out.println(a);
        }else{
            System.out.println(f);
        }
    }
package com.tenisme.libjava; // MyClass 클래스

public class MyClass {


    public static void main(String[] args) {

        Student st1 = new Student();
        Student st2 = new Student();

        st1.name = "Mike";
        st1.kor = 90;
        st1.eng = 95;
        st1.math = 100;
        st1.sum();
        st1.avg();

        st1.grade(100); // MyClass에서 불러들임. 근데 이건 리턴이 아니라 그냥 출력..

    }
}
구래서 리턴하는 것도 혼자서 만듦><
    String grade1(int y){ // ----------
        String a = "A Grade";
        String f = "F Grade";
        if(y > average){
            return a;
        }else{
            return f;
        }
    }
package com.tenisme.libjava; // ---------

public class MyClass {


    public static void main(String[] args) {

        Student st1 = new Student();
        Student st2 = new Student();

        st1.name = "Mike";
        st1.kor = 90;
        st1.eng = 95;
        st1.math = 100;
        st1.sum();
        st1.avg();

        String z = st1.grade1(100);
        System.out.println(z);


    }
}
 // 슨생님이 하신 거. void로 만드는 것보다 깔끔하넹.
    String grade1(int y){
        if(y > average){
            return "A Grade"; // 이렇게 리턴해도 되는 줄 몰랐슴..
        }else{
            return "F Grade";
        }
    }





// 문제 2 : 클래스 설계
// Account 클래스
// money 멤버변수
// 입금, 출금 메소드를 만드세요.
// 예금보다 출금이 크면 "Not Enough Money" 리턴, 그렇지 않으면 "O.K" 리턴
성공!!!!!!!!!
package com.tenisme.libjava; // Account 클래스

public class Account {

    int money;

    void dep(int a) {
        money = money + a;
    }

    String wit(int b) {
        if (money - b < 0) {
            return "No money";
        } else {
            money = money - b;
            return "O.K";
        }
    }
}
package com.tenisme.libjava; // MyClass 클래스

public class MyClass {


    public static void main(String[] args) {

        Account cus1 = new Account();

        cus1.money = 0; // 기존 금액

        cus1.dep(10000); // 입금식

        System.out.println("D.B = " + cus1.money);

        String result = cus1.wit(5000); // 출금식

        if(result == "O.K"){
            System.out.println(result);
            System.out.println("last D.B = " + cus1.money);
        }else {
            System.out.println(result);
            System.out.println("last D.B = " + cus1.money);
        }


    }
}
// 결과값 (문제에서 잔액 정산, 잔액 출력 기능 추가함)
> Task :libjava:MyClass.main()
My Current money = 10000
O.K
My Current money = 5000
// 슨생님은 더 간단하게 하신 거 같은데 기분탓인가. 다시 떠올려보기.





// 예시~
package com.tenisme.libjava;

public class Point {

    int x;
    int y;
-----
package com.tenisme.libjava;

public class Shape {

    Point p = new Point();

    void draw(){
        System.out.println("x : " + p.x);
        System.out.println("y : " + p.y);
    }

}
-----
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        Point[] arr = new Point[5];

        for(int i = 0; i < arr.length; i++){
            arr[i] = new Point();
            arr[i].x = i;
            arr[i].y = i;
        }

    }
}






// 예시...(이거 CPU 흐름 좀 다시 파악해보자)
package com.tenisme.libjava;

public class ObjParam {

    String str;

    void print(){
        System.out.println("str : " + str);
    }
}
-------
package com.tenisme.libjava;

public class ObjectParamTest {

    ObjParam obj;

    void setObj(ObjParam new_obj){
        obj = new_obj;
        obj.print();
    }

    ObjParam getObj(){
        obj.str = "return ObjParam";
        return obj;
    }
}
---------
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        ObjParam myobj = new ObjParam();
        myobj.str = "Hello World";
        
        ObjectParamTest test = new ObjectParamTest();
        test.setObj(myobj);
        ObjParam ret_param = test.getObj();
        System.out.println("new str : " + ret_param.str);

    }
}
//결과값
> Task :libjava:MyClass.main()
str : Hello World
new str : com.tenisme.libjava.ObjParam@2a139a55200513 수요일 수업 메모 정리



?? 접근제어자 상세정보 검색
?? 깔끔한 정리가 필요.. 정리의 정리가 필요한가
  ?? 용어랑 중심으로다가..



// 기본 정보
  // 멤버변수, 메소드 -> 구성요소
  // 클래스를 설계했다 -> 클래스 내용을 만들었다★
  // 클래스는 설계만 해 놓는 거고, 실행은 메인에서.★
  // Child ch1 = new Child();일 때 main에 저장된 변수 ch1은 객체가 생성될 때 같은 모양의 Child 클래스(틀, 방, 메모리 영역)를 찍어낸다. Child 클래스로 만든 방(틀)의 이름은 ch1.
    // main에서 클래스 불러올 때는 main에 저장한 변수 이름을 써야한다.. 클래스 이름 쓰지마로라..★
  // 클래스를 나타내는 박스 이미지에서 위에 박스(주제)가 클래스 이름.
  // 생성자를 가운데 위치에 적는 것은 관례.
  // Ctrl + 좌클릭 : 함수나 변수 이름 위에다 대고 Ctrl+좌클릭을 하면 인용한 함수나 변수가 있는 곳(파일)로 바로 이동한다.
  // init : 생성됐다는 뜻으로 쓰신 듯.
  // 원하는 함수를 제공해주는지 해당 클래스에서 확인~
  // ()괄호 안은 파라미터!!!
  // 자바에서 모든 클래스는 오브젝트 클래스의 상속을 받는다. 클래스에 직접 적혀있지는 않다.
    // 몰라도 프로그래밍하는데 전혀 지장이 없다.
  // 배열을 출력하고 싶을 땐 반복문을 쓴다(for)★
  // 같은 패키지(폴더) 안에 같은 이름의 클래스가 있으면 안됨.
    // 다른 패키지는 가능.
  // 같은 소리 네 번
    // new는 Heap 메모리에 빠악★
    // new는 객체(객체 메모리)를 만드는 거다.
    // "객체"는 Heap 메모리에 저장됨.
    // 클래스로 객체 생성시 new할 때마다 새로운 객체 메모리가 생김
  // 어떻게 돌아가는지 나오는 것 : 로그
  // 오버로드랑 오버라이드랑 다르다.



// 도움되는 말
  // 일관성 있는 효율적인 프로그래밍~
  // 로직(if문 for문)은 정답이 없다.
  // 강의자료 Githup에 올려져있음.★
    // Githup자료 주소도 따로 메모장에 저장해놓자
  // 무슨 내용을 어느어느 부분에 작성을 해야하는지 알아야 한다.



// 메소드 오버라이드
  // 정의
    // 다른 클래스와 상속 관계일 때 상위 클래스로부터 상속받은 메소드를 함수 이름은 그대로 둔 채 재정의하는 것을 의미한다.
    // 상위 클래스와 함수 이름은 동일하게 쓰되 내용은 하위 클래스 입맛에 맞게 바꿀 수 있다.
      // 이미 만들어진 함수의 기능을 클래스 상속으로 가져와서 써먹을 때 유용하게 쓴다.
      // 상속을 배운 다음에 이해할 수 있는 개념이다.
  // 특징(규칙)
    // 하위에서 설계하려는 메소드와 상속한 메소드와 이름이 같다.
    // 매개변수(파라미터)가 같아야 한다.
    // 리턴 타입이 같아야 한다.
  // 오버라이드 표시하기
    // 상속한 메소드를 재정의했다는 뜻으로 해당 함수 위에 @Override 표시를 해준다.
      // 단축키 : Ctrl+O or 우클릭-제너레이트-오버라이드메소드
  // 예시
    // ex. (8), (9) 실습문제2에서 Printer 클래스



// 메소드 Overload(오버로드)
  // 정의
    // 한 클래스 안에 같은 이름의 메서드를 매개변수(파라미터) 개수나 타입을 바꾸어 정의하는 것을 말한다.
  // 기능
    // 같은 이름을 가진 여러개의 메소드를 만들 수 있다.
      // 같은 이름의 메소드를 다른 파라미터를 사용하여 정의할 수 있는 것을 말한다.
      // 파라미터의 타입이 달라도 되고, 개수가 달라도 됨.
        // 파라미터가 "완전히" 똑같지만 않으면 된다.★
    // 함수를 다 따로(함수 이름 빼고 전부 다 다를 수도 있음) 만드는데 함수 이름은 똑같이 쓸 수 있는 것.
      // 비슷하게 쓰이는 함수들의 이름을 똑같이 지으면, 해당 함수들을 써먹어야 할 때 편하다.
        // 이용자 중심 코딩
  // 예시 ex. (1), (1)-2
    // ex) add(int x, int y) add(float x, float y) 둘을 한번에 사용 가능.
      // 더하기를 쓰고싶다 하면 "add"만 가져다 쓰면 됨.
        // add_int add_float 등으로 각각 만들거나 찾을 필요가 없음.



// 오버로드, 오버라이드 공통점
  // 함수 이름은 같으면 안 되는 것이 기본 but
  // 자바같은 객체지향에서는 같은 이름의 메소드를 여러개 생성하는 것이 가능
    // "자바에서는" 이렇게 써도 문제가 안 된다.
      // 이런 전제로 만든 것이 오버로드, 오버라이드
  // 자바에서 다형성을 지원하는 방법들이다.
    // ★다형성 : 하나의 인터페이스만을 가지고 다양한 구현을 가능하게 해준다는 뜻.(One interface, multiple implementations)
      // (검색복붙) 예시) 똑같은 물을 담는데도 불구하고 컵에 따라 성질이 달라지는 것
   // 같은 이름의 함수는 자바 컴파일러가 알아서 파악해서 실행을 시켜준다.



// 생성자★
  // 생성자의 정의
    // Test test1 = new Test(); 왼쪽에는 클래스 이름, 우측은 "함수"명
      // 여기서 Test()를 "생성자"라고 한다.
    // 객체는 하나의 데이터만 저장하려는 의도로 만들지는 않는다.
      // 생성자는 객체를 (메모리에) 생성하는 동시에 해당 클래스의 멤버변수 값을 생성자에 줘서(a.k.a 붕어빵 재료 만들기) 원하는 값을 바로 세팅할 수 있다.★
        // 객체를 생성할 때(객체가 생성될 때) 실행하니까 "생성자"이다.★ 
  // 규칙(속성)
    // 생성자(함수) 이름은 클래스 이름과 똑같이 써야 한다.
      // 클래스에 대문자로 만드는 함수는 없다. but 생성자는 가능.
    // 리턴 타입같은 것을 앞에 붙이지 않는다(일반 함수를 쓰는 방법과는 다르다).
      // 리턴 타입이 없으니 앞에 아무 것도 적지 마라.
        // 이름 규칙 : 클래스이름+함수표시 ex. Test()
    // 객체 생성시 생성자에 값이 있으면 "그 값도 한번에 Heap에 같이 저장"함.
    // 생성자를 안 만들어 놓거나 아무 값도 없을 때 객체 생성시 멤버 변수들의 기본값은 숫자는 0, 문자열은 null이다.
    // 생성자는 마음대로 처리하고 말고를 정할 수 있는 게 아님. 객체 만들어지면서 자동으로 실행되는 것임.
      // 객체의 메모리에서 먼저 실행되기를 원하는 게 있을 때 생성자 작성하면 유용함.★
  // 예시
    // 멤버 클래스가 있으니까 멤버 한 명 만드세요.(실체 만드세요) ex. (2)
      // Member m1 = new Member();
      // 저장한 사람의 정보를 화면에 출력해라.
      // Member()는 Member클래스 안에 눈에 안 보이게 이미 존재한다.
      // 자바에서는 클래스를 만들 때 함수 Member를 미리 생성해둔다.
  // 활용예
    // 생성자의 실제 용도ex. (2)-2
    // (2)-1의 결과값이 저렇게 나오는 이유
      // 눈에 안 보이던 생성자를 눈에 보이게 만들어놓으니까 생성자가 일을 하는 것.




// this
  // 파라미터 변수의 이름과 클래스 변수 이름이 동일할 때 구분을 지어줘야 한다.
    // 이걸 구분지어주는 것이 this.
    // this.가 붙은 것은 "해당 클래스"의 변수를 의미한다.★



// 상속
  // 정의
    // 물려주고 물려받도록 해주는 작업.
      // A클래스(상위 클래스)가 다른 클래스(하위 클래스)들에게 A클래스의 구성요소들을 물려주면서 하위 클래스에서 A클래스의 구성요소들을 바로 쓸 수 있도록 만들어주는 작업
      // 상속 단위는 클래스.
    // 상속은 다대 일, 2중 뿐만 아니라 3중 이상도 가능.
  // 상속 구성하는 방법
    1. 만들려는 클래스들의 공통점들(구성요소)을 뽑아 "상위 클래스"를 만들어 저장한다.
      // 필요에 따라 클래스, 메소드, 생성자, 멤버변수 앞에 접근제어자를 붙인다.
    2. 공통되지 않은 구성요소는 각각의 "하위 클래스"를 만들어 추가한다.
      // 클래스 단위에서 ★A extends B 라고 적어야 상위 클래스(여기서는 B)를 상속받을 수 있다. ex) public class Child extends Parent {}
        // A 클래스(하위)는 B 클래스(상위)를 상속받는다는 뜻.
        // 정확히는 "하위클래스가 상위 클래스를 상속하고 있다"고 표현한다.
        // 직접 코드를 적지 않아도 Java 파일을 생성할 때 상속을 미리 설정할 수 있다.
        // 생성시 Superclass 부분에 상속할 클래스 이름을 적어주면 된다
  // 상속의 속성(with 접근제어자)
    // 하위 클래스는 상위 클래스에 있는 구성요소들을 상속받아 자신의 클래스에 있는 것처럼 쓸 수 있다.
      // 하위 클래스를 만들고 아무 것도 안 적어도 상위에서 받을 수 있는 것들(Private 제외)은 전부 다 적용되어 있는 것과 마찬가지다. (눈에는 안 보임)



// 상속 예시
  // 예시1
    // [학생, 교수, 교직원] : 클래스 이름
       [학번, 사번, 사번]
       [이름, 이름, 이름]
       [과목, 과목, 과목]
       [주소, 주소, 주소]
      // 에서 공통된 것들 : 사람(클래스), 번호, 이름, 과목, 주소
    // 안드로이드 클래스 등등에서 상속받아서 써야할 일이 많기 때문에 중요.
  // 예시2 ex. (5)
    // "Parent class init" 이 문구는 객체가 생성될 때 생성자 함수 Parent()가 실행되면서 출력된 것이다.
    // Parent class init
       name = Anne
       age = 40
       1000000
       Parent class init
       Child class init
    // 위와 같이 출력된 이유 : ★
    // 부모 메모리 먼저 (기존 부모 메모리와는 따로!!!)만들고!!!!! 그밑에 자신의 메모리를 만들었다는 뜻.
    // Parent~는 밑의 Parent~와 다른 메모리 영역에서 동작한 것이다.★
    // 메모리 예시★
    -----Parent:p1-----
    name : 
    age : 
    money : 
    ---------------------
    ----Parent:ch1----- // Parent와 Child는 ch1이라는 같은 방을 씀.
    name : Paul
    age :20
    // money는 private이기 때문에 상속받지 않음.★
    -----Child:ch1------
    hobby : movie
    ----------------------
    // 실질적으로 new는 3번 일어남.
    // 이 예시에서 알 수 있는 것★
      // 객체 하나를 생성하는 방법은 기본적으로 =와 new이고, 객체 하나당 생성자 함수 하나가 실행되는 것이다.
      // 상속을 받은 하위 클래스에서 객체를 생성하면 ★상위 클래스가 하위 클래스보다 먼저 생성되고 그 다음에 하위가 생성된다. (상단 예시 참고)
        // 즉 ★하나의 객체 생성 명령어로 두개의 메모리 영역이 생길 수 있는 것이다. (단, 방을 같이 쓴다)
        // 이 때 하위클래스를 기준으로 객체를 생성하는 것이기 때문에, 상위 클래스가 하나 더 만들어지더라도 ★기존 상위 클래스에서 만든 객체와는 다른 영역을 갖는다.
        // 메모리 실행 순서는 ★상위 클래스(상위 객체)부터 실행된다.



// 접근제어자
  // 정의
    // 클래스, 메소드, 생성자, 멤버변수 앞에 붙여 해당 요소를 다른 클래스에서 접근이 가능하도록 하거나 못하도록 막는 기능을 수행한다.
    // 접근 제어자에는 public, protected, private가 있다.
  // public (상속함)
    // 앞에 아무 것도 안 쓴 거랑 똑같음.
      // 앞에 public을 쓴 거나 아예 아무 것도 안 쓴 거나 같음. 디폴트.
  // protected (상속함)
    // 모지.
  // private (상속ㄴㄴ)
    // 다른 데(밖)에서 건들 수 없음. 물론 상속도 안해준다.
    // private는 private가 적힌 그 클래스에서만 활용 가능.
    // private도 저장한 값을 리턴받는 걸로는 입력할 수 있다? why?(물어봄)★
       private가 붙은 멤버 변수는 어떻게 main에서 출력되었는가.
      // 외부에서 직접 접근은 불가능하지만 간접 접근은 가능하다.
      // 앞에 private가 붙어있어도 이게 적혀있는 클래스 안에서는 어떻게든 활용할 수 있기 때문이다.
        // 값을 변경하거나, 외부에서 받은 값으로 변경하거나, 불러온 곳으로 return해주는 것들이 전부 가능.
      // 접근이 제한된 데이터는 직접 활용은 안되므로 함수를 만들어 값을 "입력"하거나 "바꾸거나" "내보내는" 식으로 외부와 접촉(?)할 수 있다.
  // 활용
    // 접근제어자는 필요에 따라 나중에 붙여도(바꿔도) 된다.



// Getter, Setter
  // 직접적으로 접근하기 어려운 멤버변수에 접근(엑세스)하고 활용할 수 있도록 하는 "함수"를 "자동으로" 만들어주는 기능
  // Getter (값을 가져온다)
    // 직접적으로 가지고 나가지 못하는 값을 return 옆에 붙여 돌려준다.
      // 여기서 직접적이란 A클래스에 private int i = 1; 이 있고 main에 A a = new A();이 있을 때 b = a.i(멤버 변수에 직접 접근)로 적어 불러오는 것이다.
    // 멤버변수 앞에 get이 붙어 함수 이름이 된다.
  // Setter (값을 설정한다)
    // 
  // 실행 방법
    // 만들고 싶은 자바 파일 에디터 화면에서 우클릭 - Generate - Getter and Setter 클릭 - 만들고 싶은 변수 선택 - OK
      // 직접적인 단축키는 없지만 Alt+insert가 Generate를 여는 단축키.
  // 활용
    // Getter Setter의 기본값(함수 내용)을 고쳐서 원하는 값을 저장(Setter)하거나 내보낼(Getter) 수 있다.200513 수요일 수업 요약

// 기본 정보

// 도움되는 말

// 메소드 오버라이드
  // 정의
  // 특징(규칙)
  // 오버라이드 표시하기
  // 예시

// 메소드 오버로드
  // 정의
  // 기능
  // 예시

// 오버로드, 오버라이드 공통점
  // 다형성

// 생성자★
  // 정의
  // 규칙(속성)
  // 예시
  // 활용예

// this

// 상속
  // 정의
  // 구성하는 방법
  // 속성(with 접근제어자)

// 상속 예시

// 접근제어자
  // 정의
  // public(상속함)
  // pritected(상속함)
  // private(상속ㄴㄴ)
  // 활용

// Getter, Setter
  // Getter
  // Setter
  // 실행 방법
  // 활용

200513 수요일 수업에 쓰인 코드





(1) 메소드 오버로딩 테스트
(1)-1 기존 메소드 생성
package com.tenisme.libjava;

public class Test {

    int add_int(int x,int y){
        return x+y;
    }

    float add_float(float x, float y){
        return x+y;
    }

    String add_string(String x, String y){
        return x+y;
    }

}
---------------------------------------------------------------
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        Test test1 = new Test();
        int ret1 = test1.add_int(10,20);
        float ret2 = test1.add_float(3.5f,10.111f);
        String ret3 = test1.add_string("Welcome","Bye");

        System.out.println(ret1);
        System.out.println(ret2);
        System.out.println(ret3);

    }
}
// 결과값
> Task :libjava:MyClass.main()
30
13.611
WelcomeBye

(1)-2 메소드 오버로딩(함수의 이름을 똑같이 만듦)
package com.tenisme.libjava;

public class Test2 {

    int add(int x,int y){
        return x+y;
    }

    float add(float x, float y){
        return x+y;
    }

    String add(String x,String y){
        return x+y;
    }

    float add(int x, float y){
        return x+y;
    }

    float add(float x, int y){
        return x+y;
    }

    int add(int aaa, int bbb){ // 오류 : 위에 같은 파라미터가 있기 때문
        return aaa+bbb;
    }
    
    int add(int x,int y, int z){
        return x+y+z;
    }

}
-----------------------------------------------------------------
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        Test2 test2 = new Test2();
        int ret4 = test2.add(10,20);
        float ret5 = test2.add(3.5f, 10.111f);
        String ret6 = test2.add("Welcome","Bye");

        System.out.println(ret4);
        System.out.println(ret5);
        System.out.println(ret6);

    }
}
// 결과값
> Task :libjava:MyClass.main()
30
13.611
WelcomeBye





(2) 생성자 예시
package com.tenisme.libjava;

public class Member {

    String name;
    String tel;
    String address;

    Member(){
        
    } // 생성자 기본 형태. 눈에 안 보이게 있는 것. 클래스를 만들 때 자바에서 안 보이게 만들어두는 것. 생성자의 위치는 가운데★

    void print(){ // 클래스 & 멤버변수와 관련된 메소드
        System.out.println("name : "+name);
        System.out.println("tel : "+tel);
        System.out.println("address : "+address);
    }

}
-----------------------------------------------------------------
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        Member m1 = new Member();
        m1.name = "Mike";
        m1.tel = "010-1234-5678";
        m1.address = "Seoul";

        m1.print();

    }
}
(2)-1 생성자 예시2
위 예시에서
    Member(){ // 생성자에
        name = "no name";
        tel = "no tel";
        address = "no address"; // 를 추가
    }
--------------------------------------------------
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        Member m1 = new Member();

        m1.print();
        System.out.println();

        m1.name = "Mike";
        m1.tel = "010-1234-5678";
        m1.address = "Seoul";

        m1.print();

    }
}
// 출력값
> Task :libjava:MyClass.main()
name : no name
tel : no tel
address : no address

name : Mike
tel : 010-1234-5678
address : Seoul

(2)-2 생성자+메소드 오버로딩 예시
package com.tenisme.libjava;

public class Member {

    String name;
    String tel;
    String address;

    Member(String _name,String _tel,String _address){
        name = _name;
        tel = _tel;
        address = _address;
    }

    Member(){
        name = "no name";
        tel = "no tel";
        address = "no address";
    }

    void print(){
        System.out.println("name : "+name);
        System.out.println("tel : "+tel);
        System.out.println("address : "+address);
    }

}
--------------------------------------------------------------
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        Member m1 = new Member("Mike","010-1234-5678","seoul");
        Member m2 = new Member("Harry","010-1212-5656","Busan");
        Member m3 = new Member();
        m1.print();
        System.out.println();
        m2.print();
        System.out.println();
        m3.print();

    }
}
> Task :libjava:MyClass.main()
name : Mike
tel : 010-1234-5678
address : seoul

name : Harry
tel : 010-1212-5656
address : Busan

name : no name
tel : no tel
address : no address

(2)-3 this 예시
public class Member {

    String name;
    String tel;
    String address;

    Member(String name,String tel,String address){
        name = name; // 회색줄 뜸
        tel = tel;
        address = address;
    }
}
---------------------------변경----------------------------
public class Member {

    String name;
    String tel;
    String address;

    Member(String name,String tel,String address){
        this.name = name; // this는 해당 함수의 변수라는 것을 지정해주는 것
        this.tel = tel;
        this.address = address;
    }
}





(3) 예제
// 1. 객체 생성
// 2. 각 멤버변수를 출력하세요.
// 3. 생성자를 활용해 속도 출력하기
package com.tenisme.libjava;

public class Car {

    String company = "Benz";
    String model = "S350";
    String color = "black";
    int max_speed = 350;
    int speed; // 아직 "모르니까" 비워놓음
// 정해진 값은 바꿀 거 아니면 Car함수에 파라미터로 넣을 필요 읎음..★

    Car(int speed){
        this.speed = speed;
    }

    Car(){

    }

}
-------------------------------------------------------------------
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        Car c1 = new Car(100);

        System.out.println(c1.company);
        System.out.println(c1.model);
        System.out.println(c1.color);
        System.out.println(c1.max_speed);
        System.out.println(c1.speed);

    }
}
// 출력값
> Task :libjava:MyClass.main()
Benz
S350
black
350
100

(3)-1 예제2
// 클래스에 print 함수를 만들고 main에서 함수를 불러와서 출력하기
package com.tenisme.libjava;

public class Car {

    String company = "Benz";
    String model = "S350";
    String color = "black";
    int max_speed = 350;
    int speed;

    Car(int speed){
        this.speed = speed;
    }

    Car(){

    }

    void print(){
        System.out.println(company);
        System.out.println(model);
        System.out.println(color);
        System.out.println(max_speed);
        System.out.println(speed);
    }

}
---------------------------------------------------------------------
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        Car c1 = new Car(100);

        c1.print();

    }
}
// 결과값
> Task :libjava:MyClass.main()
Benz
S350
black
350
100

(3)-2 예제3
// 컴퍼니, 모델, 컬러도 변경할 수 있는 생성자를 만든다.
package com.tenisme.libjava;

public class Car {

    String company = "Benz";
    String model = "S350";
    String color = "black";
    int max_speed = 350;
    int speed;

    Car(int speed){
        this.speed = speed;
    }

    Car(String company,String model,String color){
        this.company = company;
        this.model = model;
        this.color = color;
    }

    Car(){

    }

    void print(){
        System.out.println(company);
        System.out.println(model);
        System.out.println(color);
        System.out.println(max_speed);
        System.out.println(speed);
    }
}
-------------------------------------------------------------------
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        Car c1 = new Car(100);
        c1.print();
        System.out.println();
        Car c2 = new Car("Benz","S350","100");
        c2.print();

    }
}
// 결과값
> Task :libjava:MyClass.main()
Benz
S350
black
350
100

Benz
S350
100
350
0





(4) 예제 (계산기 클래스)
1. 화면에 "Power On"이라고 출력하는 메소드를 만든다.
2. "plus"라는 이름의 메소드를 만든다. 3개의 정수를 입력받아서 합을 리턴하는 함수.
3. devide 메소드 만들기. 두 정수를 입력받아서, 더블형을 리턴하는 함수
4. 를 출력
package com.tenisme.libjava;

public class Calculator {

    void print(){
        System.out.println("Power On");
    }

    int plus(int a, int b, int c){

        int result = a + b + c;
        return result;

    }

    double divide(int a, int b){
        double result = (double)a / b; // int 변수를 double로 바꿔서 나눠라.
        return result;
    }

}
-----------------------------------------------------------
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        Calculator cal1 = new Calculator();

        cal1.print();
        System.out.println(cal1.plus(3,4,5));
        System.out.println(cal1.divide(6,4));

    }
}
// 결과값
> Task :libjava:MyClass.main()
Power On
12
1.5





(5) 상속+게터세터 예시
package com.tenisme.libjava;

public class Parent {

    public String name;
    protected int age;
    private int money;

    Parent(){
        System.out.println("Parent class init");
    }

    void printParentInfo(){
        System.out.println("name = "+name);
        System.out.println("age = "+age);
    }
    int getMoney(){
        return money;
    }
    void setMoney(int money){
        this.money = money;
    }
}
--------------------------------------------------------
package com.tenisme.libjava;

public class Child extends Parent {

//    public String name;
//    protected int age;
    private String hobby;

    Child(){
        System.out.println("Child class init");
    }

    void printInfo(){
        System.out.println("name : "+name);
        System.out.println("age : "+age);
        System.out.println("hobby : "+hobby);
    }
    String getHobby(){
        return hobby;
    }
    void setHobby(String hobby){
        this.hobby = hobby;
    }
}
----------------------------------------------------------
// Parent클래스 객체 생성
// 이름 나이 입력
// setmoney메소드 이용해서 백만원 저장
// Parent클래스의 정보를 화면에 출력
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        Parent pa = new Parent();

        pa.name = "Anne";
        pa.age = 40;

        pa.setMoney(1000000);

        pa.printParentInfo();

        int money = pa.getMoney(); // 변수 선언
        System.out.println(money); // 이 안에 pa.money를 입력해서는 불러올 수 없음

    }
}
//출력값
> Task :libjava:MyClass.main()
Parent class init
name = Anne
age = 40

// Child 클래스 객체 생성
// 이름, 나이를 저장
// 취미를 저장(movie)
// 출력(부모 클래스와 자신의 클래스 함수를 ch1에 같이 씀)
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        Parent pa = new Parent();

        pa.name = "Anne";
        pa.age = 40;

        pa.setMoney(1000000);

        pa.printParentInfo();

        int money = pa.getMoney();
        System.out.println(money);

        Child ch1 = new Child();
        ch1.name = "Paul";
        ch1.age = 10;
        ch1.setHobby("movie");

        ch1.printParentInfo();
        System.out.println();
        ch1.printInfo();

    }
}
// 출력값
> Task :libjava:MyClass.main()
Parent class init
name = Anne
age = 40
1000000
Parent class init
Child class init
name = Paul
age = 10

name : Paul
age : 10
hobby : movie

(5)-1 예제 getter, setter 활용
package com.tenisme.libjava;

public class Person {

    int num;
    String name;
    String dept;
    String address;

    void print(){
        System.out.println("num : "+num);
        System.out.println("name : "+name);
        System.out.println("dept : "+dept);
        System.out.println("address : "+address);
    }

    public int getNum() {
        return num;
    }

    public String getName() {
        return name;
    }

    public String getDept() {
        return dept;
    }

    public String getAddress() {
        return address;
    }

    public void setNum(int num) {
        this.num = num;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setDept(String dept) {
        this.dept = dept;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}
----------------------------------------------------------
package com.tenisme.libjava;

public class Student extends Person {

    private String[] subjects;

    void print_subject(){
        System.out.println(name + "'s subject");
        for(int i = 0;i < subjects.length; i++){
            System.out.println("subject : "+subjects[i]);
        }
    }

    public String[] getSubjects() {
        return subjects;
    }

    public void setSubjects(String[] subjects) {
        this.subjects = subjects;
    }
}
----------------------------------------------------------
package com.tenisme.libjava;

public class Professor extends Person {

    private String[] subjects;

    void print_subject(){
        System.out.println(name+"'s subjects");
        for(int i = 0;i<subjects.length;i++){
            System.out.println("subject : " + subjects[i]);
        }
    }

    public String[] getSubjects() {
        return subjects;
    }

    public void setSubjects(String[] subjects) {
        this.subjects = subjects;
    }
}
----------------------------------------------------------
package com.tenisme.libjava;

public class Staff extends Person {

    private String job;

    public void print_job(){
        System.out.println(name+"'s job : "+job);
    }

    public String getJob() {
        return job;
    }

    public void setJob(String job) {
        this.job = job;
    }
}
----------------------------------------------------------
교수, 학생, 직원 신상 출력하기
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {
        Professor f = new Professor();
        f.setNum(2);
        f.setName("Mike");
        f.setDept("Computer");
        f.setAddress("Seoul");
        String[] sub = {"Computer","C","Java"};
        f.setSubjects(sub);

        f.print();
        System.out.println();
        f.print_subject();

        System.out.println();

        Student s = new Student();
        s.setNum(3);
        s.setName("Paul");
        s.setDept("Computer");
        s.setAddress("BuCheon");
        String[] studentClass = {"Java","Compiler"};
        s.setSubjects(studentClass);

        s.print();
        System.out.println();
        s.print_subject();

        System.out.println();

        Staff sf = new Staff();
        sf.setNum(4);
        sf.setName("Anne");
        sf.setDept("Edu");
        sf.setAddress("KyungGi");
        sf.setJob("Edu manager");

        sf.print();
        sf.print_job();
        
    }
}
// 결과값
> Task :libjava:MyClass.main()
num : 2
name : Mike
dept : Computer
address : Seoul

Mike's subjects
subject : Computer
subject : C
subject : Java

num : 0
name : Paul
dept : Computer
address : BuCheon

Paul's subject
subject : Java
subject : Compiler

num : 4
name : Anne
dept : Edu
address : KyungGi
Anne's job : Edu manager





(6) 삼중 상속 예시
package com.tenisme.libjava;

public class GrandParent {

    protected String name;
    protected int age;

    public GrandParent(){
        System.out.println("GrandParent Class");
    }

    public void printGrandParentInfo(){
        System.out.println("name : "+name);
        System.out.println("age : "+age);
    }

}
------------------------------------------
package com.tenisme.libjava;

public class Parent extends GrandParent {

    protected String job;

    Parent(){
        System.out.println("Parent Class");
    }

    void printParentInfo(){
        System.out.println("name : "+name);
        System.out.println("age : "+age);
        System.out.println("job : "+job);
    }

}
--------------------------------------------
package com.tenisme.libjava;

public class Child extends Parent {

    public String hobby;

    Child(){
        System.out.println("Child Class");
    }

    void printChildInfo(){
        System.out.println("name : "+name);
        System.out.println("age : "+age);
        System.out.println("job : "+job);
        System.out.println("hobby : "+hobby);
    }

}
----------------------------------------------
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        GrandParent gp = new GrandParent();
        gp.name = "grand";
        gp.age = 80;
        gp.printGrandParentInfo();
        System.out.println("-------------------");

        Parent p = new Parent();
        p.name = "parent";
        p.age = 50;
        p.job = "edu";
        p.printGrandParentInfo();
        System.out.println("-------------------");
        p.printParentInfo();
        System.out.println("-------------------");

        Child c = new Child();
        c.name = "child";
        c.age = 20;
        c.job = "rider";
        c.hobby = "ride";
        c.printGrandParentInfo();
        System.out.println("-------------------");
        c.printParentInfo();
        System.out.println("-------------------");
        c.printChildInfo();


    }
}
// 결과값
> Task :libjava:MyClass.main()
GrandParent Class
name : grand
age : 80
-------------------
GrandParent Class
Parent Class
name : parent
age : 50
-------------------
name : parent
age : 50
job : edu
-------------------
GrandParent Class
Parent Class
Child Class
name : child
age : 20
-------------------
name : child
age : 20
job : rider
-------------------
name : child
age : 20
job : rider
hobby : ride





(7) 오버라이드
package com.tenisme.mytest1;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}
//안드로이드는 여기 안에 값을 넣어서 오버라이드를 써먹을 거임.
"오버라이드한 함수를 써먹는다."





(8) 오버라이드 실습(개념 알기)
package com.tenisme.libjava;

public class A {

    void hello(){
        System.out.println("A say Hello");
    }

}
----------------------------------------------------
package com.tenisme.libjava;

public class B extends A {

    @Override
    void hello() {
        System.out.println("B say Hello");
        System.out.println("Ha-ha");
    }
}
// 결과값
> Task :libjava:MyClass.main()
B say Hello
Ha-ha





(9) 예제 : (6)의 함수 print~~Info를 오버라이드해서 간단하게 바꾸기
package com.tenisme.libjava;

public class GrandParent {

    protected String name;
    protected int age;

    public GrandParent(){
        System.out.println("GrandParent Class");
    }

    public void printInfo(){ // 해당 클래스의 정보를 출력하는 기능.
        System.out.println("name : "+name);
        System.out.println("age : "+age);
    }

}
---------------------------------------------------------
package com.tenisme.libjava;

public class Parent extends GrandParent {

    protected String job;

    Parent(){
        System.out.println("Parent Class");
    }

    @Override
    public void printInfo() {
        System.out.println("name : "+name);
        System.out.println("age : "+age);
        System.out.println("job : "+job);
    }
}
----------------------------------------------------------
package com.tenisme.libjava;

public class Child extends Parent {

    public String hobby;

    Child(){
        System.out.println("Child Class");
    }

    void printChildInfo(){
        System.out.println("name : "+name);
        System.out.println("age : "+age);
        System.out.println("job : "+job);
        System.out.println("hobby : "+hobby);
    }

    @Override
    public void printInfo() {
        System.out.println("name : "+name);
        System.out.println("age : "+age);
        System.out.println("job : "+job);
        System.out.println("hobby : "+hobby);
    }
}
-------------------------------------------------------------
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        GrandParent gp = new GrandParent();
        gp.name = "grand";
        gp.age = 80;
        gp.printInfo();
        System.out.println("-------------------");

        Parent p = new Parent();
        p.name = "parent";
        p.age = 50;
        p.job = "edu";
        p.printInfo();
        System.out.println("-------------------");

        Child c = new Child();
        c.name = "child";
        c.age = 20;
        c.job = "rider";
        c.hobby = "ride";
        c.printInfo();

    }
}
// 결과값 :)
> Task :libjava:MyClass.main()
GrandParent Class
name : grand
age : 80
-------------------
GrandParent Class
Parent Class
name : parent
age : 50
job : edu
-------------------
GrandParent Class
Parent Class
Child Class
name : child
age : 20
job : rider
hobby : ride





// 실습문제 : 게터세터
// Account 클래스를 활용해 main 요구사항을 처리
// main 요구사항 : 
// Account 클래스는 balance라는 멤버변수를 가지고 있다.
// balance는 음수가 될 수 없다.
// balance는 1,000,000(백만)을 넘을 수 없다.
// 이 범위를 넘으면 무시. balance에 변화없음. 저장 안함.
// balance 변수는 외부에서 직접 접근할 수 없음.
package com.tenisme.libjava;

public class Account {

    private int balance;


    public int getBalance() {
        return balance;
    }

    public void setBalance(int balance) {

        if (balance <= 1000000 && balance >= 0) {
            this.balance = balance;
        }

    }
}
---------------------------------------------------------------
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        Account account = new Account();
        account.setBalance(10000);
        System.out.println("Current Balance : "+account.getBalance());

        System.out.println();

        account.setBalance(10000000);
        System.out.println("Current balance : "+account.getBalance());

        System.out.println();

        account.setBalance(-3000);
        System.out.println("Current balance : "+account.getBalance());
    }
}
// 결과값
> Task :libjava:MyClass.main()
Current Balance : 10000

Current balance : 10000

Current balance : 10000





// 실습문제2 : 오버로딩
// 주어진 main의 코딩을 모두 만족하는 클래스 Printer를 만들어라. 성공 :)
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        Printer printer = new Printer();
        printer.println(10);
        printer.println(3.14);
        printer.println("Hello");

    }
}
--------------------------------------------------------
package com.tenisme.libjava;

public class Printer {

    public void println(int a){
        System.out.println(a);
    }

    public void println(double a){
        System.out.println(a);
    }

    public void println(String a){
        System.out.println(a);
    }

}
// 결과값
> Task :libjava:MyClass.main()
10
3.14
Hello200514 목요일 수업 메모 정리



// 기본 정보
  // protected : 상속받는 데에만 사용할 수 있도록 하는 접근제어자
  // 상속받으려면 접근제어자까지 똑같이 적어야한다.★
    // 똑같이 안 적으면 오류남.
  // new 옆에 있는 클래스의 메모리가 만들어지는 것을 항상 유념하자.
  // 객체 만들기 = 메모리 영역 만들기 기억~~ ★
  // 문자열에서 글자 개수 셀 때는 공백도 중요함.
    // 인덱스는 0부터 시작하는 거 잊지말기
  // is로 시작하는 함수들은 대답이 트루올펄스★
  // 문자열이 같냐 틀리냐는 ==로 비교하지 않는다. ==는 변수 등을 비교. 
    // 이 파일의 String Class 참고.
  // static★★
    // 객체를 생성하지 않은 상태에서도 쓰고싶은 클래스의 함수를 쓸 수 있다.
    // 이름 앞에 static이 붙어있는 함수는 Heap이나 Stack 영역에 저장되지 않는다.
      // 이게 붙어있으면 기존의 방법(new)으로 객체를 생성하지 않아도 바로 해당 함수를 호출할 수 있게 해준다.★
    // 예시 : LocalDate.now();  <-- LocalDate클래스에서 바로 now()함수를 불러옴
  // ISO : 표준이라는 뜻.
  // 클래스 이름이나 함수 이름을 맞게 적었는데 오류가 난다면, 해당 패키지를 불러오지 않아서 오류가 뜬 것인지 확인한다.
    // 위의 원인이 맞다면 Alt+Enter로 해당 패키지를 불러오면 오류가 사라진다.
  // import A : A 패키지를 가져오겠다.
    // 가져와서 이 안에 있는 것들을 쓰겠다.
    // 예시 ) import java.util.Date;
      // 패키지명(폴더명) 확인 java.~.~
    // 클래스 파일 최상단 패키지 이름 밑밑줄에 적혀짐(적음).
  // static 이외의 함수를 가져다 쓰는 데에 필요한 줄 최소 2줄.
    // 객체 생성, 변수 선언(혹은 바로 함수 호출).
    // 출력까지 하려면 3줄.
  // am은 0, pm은 1  <-- 21)
  // 소팅(정렬)
  // 클래스 속성(타입)을 가지는 변수를 만들 땐 "클래스이름 변수이름 = 변수값or함수;" ★
    // 예시) String name = "a"; LocalDate currDate = LocalDate.now();
    // 객체 생성이 필요한 함수는 생성 먼저 하고서 쓰면 됨.



// 공부, 프로그래밍 관련 조언
  // 자바 래퍼런스
    // 자바 래퍼런스 뜻 검색해보기
      // 클래스 래퍼런스 사이트 등등에서 클래스 검색 및 사용방법을 확인할 수 있다.
        // 래퍼런스의 설명서를 보고 사용하면 된다.
      // 래퍼런스 잘 갖다 쓰려고 문법을 배우는 것이다. 뭔 소린지 알아먹어야 활용하니까.
      // 함수 등등의 검색은 구글에서.
  // 라이브러리
    // 필요에 의해서 사용해야 될 함수들(클래스들?)의 모음. 외우는 게 아니라 어디다 적어놓고 필요할 때 찾아서 쓰는 거
    // 이런 곳에서 찾아서 써먹는 함수들은 하나하나 다 외울 필요는 없지만 필요할 때 꺼내 쓸 수 있도록 기억정도는 해두는 것이 좋다.
  // 활용법을 잘 익히자. 함수들의 재조합, 적용 연습이 필요하다.
  // 숫자, 날짜 포맷팅은 회사마다 다 다르고 다 정해져있다.



// 아직 자세히 알 필요 없는 것들
  // 업캐스팅, 다운캐스팅
    // 업캐스팅 : 상위가 하위 클래스 갖다 쓰는 거.  28)
      // 서브 클래스의 객체가 수퍼 클래스 타입으로 형변환되는 것을 말한다.
    // 다운캐스팅 : 업캐스팅 된 상태를 다시 원상태로 돌리는 것.  29)
    // instanceof : 객체의 타입을 구분하기 위해 instanceof 연산자를 사용할 수 있다.  30)
      // 다수의 하위클래스를 업캐스팅했을 때 각 객체들이 어디에 속해있는지를 알 수 있도록 쉽게 비교(구분, 구별)해준다.
      // 실행 시점에 발생할 수 있는 형변환 오류를 줄일 수 있는 것이다.
      // 사용시 주의할 점은 instanceof 연산자는 객체에 대한 "클래스(참조형) 타입"에만 사용할 수 있다.
      // instanceof 연산자를 사용한 연산의 결과 타입은 boolean이며 이항연산자처럼 사용하면 된다. (if등에 사용 가능)
  // 클래스 관련한 추상클래스, 인터페이스 사용법은 나중에 배움.. 예습은 ㄴㄴ 지금 봐도 모름.



// 나중에 배울 거
  // 데이터 저장하는 내용 배우는 거, 데이터베이스.
  // 서버 설치, 오퍼레이팅 시스템.



// 업캐스팅 - 상위 클래스로 하위의 객체를 만들기
  // 앞과 뒤의 이름이 다른 객체를 만들면 된다
  // "상위클래스 이름" "변수이름" = new "하위클래스 이름";
    //Heap  1)
      ---SuperChild---
      a : 20
      -------------------
      Stack
      ---main----------
      sp(SuperParent) :  <- SuperParent로 만든 SuperChild메모리
     // sp는 SuperParent 소속
     // 부모는 자식을 가리킬 수 있다.
  // 부모의 클래스로 만든 변수(sp)로 자식의 값을 쓸 수 있다.★



// Super
  // 가져다 쓰려는 상위 멤버 변수나 메소드 이름 앞에 Super.를 붙여서 상위 클래스에 적힌 변수나 함수를 그대로 하위 클래스에 호출한다.
    // 위와 반대이다.
    // 하위 클래스와 붙어있는 상위 클래스에서 불러온다.
      // 하위 클래스에서 extends 우측에 붙어있는 그 클래스
  // 예시1
  // @Override
      void fly() {
         super.fly(); } // 오버라이드한 fly()함수는 부모의 fly()를 실행한다는 뜻
  //  2)에서 메모리 시각화
  //  Heap
      ---SuperParent- // 먼저 메모리에 잡힘
      a : 10
      ---SuperChild---
      a : 20
      -------------------
      Stack
      ---main----------
      sp(SuperChild) : 



// final
  // 클래스나 함수, 변수 이름 앞에 붙어서 해당 요소를 상속하지 못하게 하는 코드이다.
    // 주로 함수 앞에 붙어서 클래스는 상속하되 특정 함수는 상속하지 못하도록(오버라이드를 못하게) 하고싶을 때 해당 함수 앞에 final을 적어 사용한다.
  // 예시
    // public static final int NUMBER = 100;
      // 변수 앞에 파이널이 들어가있으면 변수값을 바꿀 수 없다.



// String Class★★★
  // 문자열 처리를 위해서 자바에서 제공하는 클래스.
    // 문자열을 처리해주는 라이브러리.
  // 문자열 안의 숫자를 숫자 데이터로 바꿔주는 코드  5)
    // 예시) int i = Integer.valueOf("123").intValue(); <-- "123"을 숫자로 바꿔주는 코드.
  // 숫자 데이터를 문자열로 바꿔주는 코드 5)
    // 예시) String sk = String.valueOf(k); <-- 변수 k를 문자열로 바꿈.
  // A.concat("B") - 문자열 나열하기
    // 문자열 두 개를 붙이고 싶을 때 사용. +와 같은 역할.
  // A.compareTo(B) - 비교 함수(1)
    // A와 비교하려는 값(수, 문자열)이 같으면 0, B가 더 많으면 +, 더 적으면 -의 결과값을 준다.
    // 보다 더 정확하게 비교시켜준다.
  // A.equals(B) - 비교 함수(2)
    // A와 B가 같은지 다른지만을 판별해줌. 결과값은 트루 올 펄스.
  // A.parse~(B)
    // ?
  // A.indexOf("B") - 텍스트의 위치 찾기★  7) , 8)
    // String 변수A를 선언하고 나서 변수값 옆에 A.indexOf("B")를 붙여 활용
      // A의 변수값에서 문자열B의 위치를 찾아준다.
      // B가 변수값의 몇 번째 문자부터 시작되는지 인덱스 숫자로 표시한다.
        // 인덱스는 0부터 시작(당연). 공백 문자를 포함해서 계산한다.
        // 찾는 단어가 없을 경우 -1을 결과값으로 준다.★
  // A.substring(a,b) - 지정 범위의 문자 선택  8)
    // String 타입 변수 A의 0번째부터 3번째까지의 글자를 값으로 돌려주는 함수.
      // a는 인덱스 번호, b는 마지막 문자열 인덱스"+1"이다.
      // 예시는 0번부터 3번째까지, 즉 0,1,2,3을 돌려준다.
  // A.trim() - 공백 지우기  10)
    // 문자열 변수A의 앞뒤에 있는 공백을 지워준다. 문자열 사이의 공백은 냅둔다.
  // A.toLowerCase() : 문자열 변수 A의 알파벳을 모두 소문자로 변환한다.  11)
  // A.toUpperCase() : 문자열 변수 A의 알파벳을 모두 대문자로 변환한다.
    // 자바는 소문자(java)와 대문자(JAVA)를 구분한다.  11)
      // ★A.indexOf("")를 써서 글자가 있는지 없는지 있으면 어딨는지 찾을 때 기존 문장과 찾으려는 글자의 소문자 대문자 여부가 다르면 글자 자체는 같아도 다른 문자로 인식한다.
  // A.split("a") - 문자 분리(1)  12), 13)
    // 문자열 변수 A 안에 있는 문자열을 "a"를 기준으로 쪼개준다. 이 때 "a"는 지워진다.
    // 문자열을 쪼개면 변수 개수가 여러개가 되기 때문에 변수를 만들어 줄 때 배열 변수로 선언해야 한다.
    // 배열 출력은 for 잊지말기...★
  // A.replace("a","b") - String 속성 문자열 변환  14)
    // 문자열 변수 A 안에 있는 "a"라는 문자열을 "b"로 변환시켜준다.
  // A.contains("a") : 문자a를 포함하고 있는지를 확인해줌. 결과값은 트루올펄스로 나옴.
  // A.startsWith("a") : 시작문자의 문자열 값이 a와 일치하는지를 확인. 트루올펄스.
  // A.endsWith("a") : 끝문자의 문자열 값이 a와 일치하는지를 확인. 트루올펄스.



// StringTokenizer  15)
  // new StringTokenizer(a,"b") - 문자 분리(2)
    // StringTokenizer로 객체를 생성할 때 매개변수를 위와 같이 적어주면, 문자열 변수 a 안의 문자열들은 "b"를 기준으로 나눠진다. 나눌 때 "b"는 지워진다.
  // A.countTokens() : 나눠진 문자열의 총 개수를 구한다.
  // A.nextToken() - 호출시 순서대로 값 바꾸기 ★
    // 위 함수를 쓸 때마다 A안에 있는 값들을 인덱스 0부터 순서대로 불러 바꿔준다.



// StringBuilder  16)
  // StringBuilder의 객체를 생성하고나서 해당 변수를 활용한다.
  // A.append("a") - 문자열 옆으로 추가하기
    // 이 함수를 호출할 때마다 호출 순서대로 우측에 문자열을 차곡차곡 붙여준다.
  // A.insert(a,"b") - 중간에 문자열 추가하기
    // a는 인덱스 번호, b는 추가할 문자열이다. a의 위치에서부터 b가 추가된다.
      // 뒤에 있는 문자열들은 알아서 b의 뒤로 이어진다.
  // A.toString() - 속성 변환  17)
    // 변수A를 String 속성으로 바꿔준다.
  // A.replace(a,b,"c") - StringBuilder 속성 문자열 변환  17)
    // StringBuilder 속성의 변수 A에서 a에서 b까지의 문자열 범위를 "c"로 변환시켜준다.
      // a는 바꾸고 싶은 문자열의 시작 인덱스 번호, b는 끝나는 부분의 인덱스 번호+1



// Math Class  18)
  // static Class (객체 생성 없이 바로 함수 사용 가능)
  // Math.abs(a) : 절대값을 구해준다. (내 눈으로 보기엔 마이너스 없애주는 용도)
  // ★Math.ceil(a) : 올림. 해당 숫자보다 오른쪽에 있는 "정수"로 가라. (only double type)
  // ★Math.floor(a) : 내림. 해당 숫자보다 왼쪽에 있는 "정수"로 가라. (only double type)
  // Math.round(a) : 반올림. only long type!
  // Math.max(a,b) : a와 b를 비교해서 더 큰 수를 구한다.
  // Math min(a,b) : a와 b를 비교해서 더 적은 수를 구한다.
  // ★Math.random() : 0과 1사이의 값을 double형으로 랜덤으로 뽑아준다. *10하면(을 붙이면) 0과 10 사이의 수를 뽑아준다. (only double type)
    // Math.random()을 활용해 정수값을 랜덤으로 얻고 싶을 때의 구상 과정  19)
      // 1부터 6 사이의 랜덤값을 얻고 싶을 때(주사위 굴리기)
      // 0 <= Math.random() < 1  -->  0.00 ~ 0.99
         0 <= Math.random()*6 < 6  -->  0.00 ~ 5.99
         0 <= (int)(Math.random()*6) < 6  --> 0,1,2,3,4,5
         1 <= (int)(Math.random()*6) +1 < 7 --> 1,2,3,4,5,6
        // 여기서 곱하는 수를 잘 정해야 한다. 곱하는 수가 곧 랜덤 개수이다.



// 날짜 관련 함수  20)
  // 날짜 출력하기(1)
    // Date a = new Date();  <--현재 날짜를 가져오는 객체를 생성
    // String b = a.toString();  <-- 가져온 데이터를 String 속성으로 변환(출력을 위해서)
      // -> 프린트 함수 출력.
  // 날짜 출력하기(2)
    // Date a = new Date();  <--현재 날짜를 가져오는 객체를 생성



// SimpleDateFormat 객체 생성하기
  // 파라미터에는 ("yyyy-MM-dd HH:mm:ss") 등등을 적어 원하는 형태로 날짜를 표시할 수 있다. (여기서 변수 이름은 d라고 가정한다)
  // String c = d.format(a);  <-- 위의 형태(SimpleDateFormat 타입 참조변수 d에 저장한 형태)로 a를 출력한다.(이 작업을 .format()함수가 함)



// LocalDateTime : 지역 날짜시간 표시  24) ★
  // 기본 설명(웹검색)
    // Local(지역)이 접두어로 붙은 것에서 유추할 수 있듯이 여러 지역의 시간대(Time Zone) 정보는 포함하지 않는다.
      // 실제 사람이 사용하는 시간을 나타내는 API이다.
    // 시간대를 필요로 하지 않는 작업이라면 LocalDateTime 사용을 고려한다.
      // KST나 UTC처럼 시간대를 지정하는 것이 정확한 표현이지만, 실제 활용에서 이러한 시간대는 잘 사용되지 않고 오히려 방해가 될 수 있다. 이럴 때 LocalDateTime을 사용.
  // 기본 "출력"코드
    // LocalDateTime now = LocalDateTime.now();
       System.out.println(now);
    // 당연히 LocalDateTime.now()자체를 넣어서 프린트해도 됨.
  // 어떤 프로그램에 LocalDate를 하나만 달아놓으면 여러 국가에서 시간이 달릴 때 전부 각각의 현지 시간으로 표시되서 문제가 생긴다.
    // 이럴 땐 UTC타임 기준으로 각 국가마다 시간을 +혹은-해주는 코드를 사용하면 된다
    // 실제로 글로벌 서비스에서는 각 국에서 시간을 입력받으면 UTC시간으로 저장하고, 이 데이터가 필요할 때 각 국에 다시 UTC 시간을 보내주면 그 지역에 맞는 시간만큼 더해지거나 빠지면서 제 시간이 나온다.



// ZonedDateTime  24) 31)
  // 기본 설명(웹검색)
    // LocalDateTime에서 시간대(Time Zone) 개념이 추가된 클래스
    // LocalDateTime에 타임존을 추가하거나 ZonedDateTime에 타임존을 제거하면서 상호변환이 가능하다.



// 연월일시 빼오기, 윤년, 윤달 확인, 시간날짜 바꾸기
// 날짜/시간 비교  25)



// .format() - 포맷팅(formatting)★ 22)
  // 숫자, 날짜 표기를 내가 원하는 모습(형식)으로 맞추는 것.
  // 위의 SimpleDateFormat와 같이 '포맷'을 정해주는 역할.
    // 변수값 정해주는 게 아님 주의. 이 포맷에 맞출 기존 변수값이 필요함.★
  // DecimalFormat 클래스의 .format(num) 함수 활용★
    // 객체를 생성해서 써야함.
    // 변수값은 double유형으로 선언. 예시) double a = 123456.1456;
    // 활용 시작은 DecimalFormat b = new DecimalFormat("c");
      // 이후 b = new DecimalFormat("c"); 으로 포맷을 계속 바꿀 수 있음.
      // c에는 포맷 유형이 들어감.
      // 포맷을 정한 다음 b.format.(a)로 a값을 b의 포맷에 맞게 바꿔 값을 바꿀 수 있음.
      // 포맷 유형
        // 소수점 이후로 정해줄 때는 0.0000...
        // 앞에를 정해줄 때는 ...0000.0
        // 0으로 쓰면 자릿수를 맞춰줌. 맞추고 남은 공간은 0으로 표시.
        // 0 대신 #으로 바꿔서 쓰면 #을 쓰는 자릿수가 더 늘어나도 앞뒤를 0으로 메꾸지 않고 그대로 있는 그대로 씀.
        // 앞에 0이나 # 한 개만 붙이면 있는 그대로 다 씀
        // 점 뒤에 맨 마지막이 .0이든 .#이든 반올림을 함.★
        // 기호를 같이 써서 원 단위나 더하기 빼기를 표현할 수 있음.★
        // .0E0 10의 몇승으로 표기하겠다. 1.2E6 : 1.2곱하기 10의 6승이라는 말.
        // "+#,### ; -#,###"
          // "+ ; -"는플러스면 플러스 표시, 마이너스면 마이너스 표시 



// 문자열 포맷팅  23)
  // ""안에 문자열을 쓸 때 문구 안의 정보를 수정하고 싶을 때 쓰인다.
  // \n(역슬래시n) : 줄을 바꿔준다(엔터).
  // {a} : a는 인덱스 번호. a번의 인덱스를 호출해 그 값을 입력시켜준다.
  // 사용법★
    // String 타입으로 변수들을 선언한다 (변수 이름이 d, e, f, g라고 치자)
    // 표현하고 싶은 문구를 String b = ""안에 {a}와 함께 쓴다
    // String c = MessageFormat.format(d,e,f,g)
      // 이렇게 쓰면 d, e, f, g....는 각각 인덱스 {0}, {1}, {2}, {3}...이 된다.
    // 변수 b에 적혀있던 {a}안에 각각의 인덱스가 호출된다.
    // 변수 b에서는 인덱스 순서가 바뀌어도 된다.
      // 변수 c의 순서는 고정. 각각의 인덱스에 무슨 변수를 넣느냐에 따라 {a}에서 출력되는 값도 변한다.


200514 목요일 수업 요약



// 기본 정보
  // static
    // 객체를 생성하지 않은 상태에서도 쓰고싶은 클래스의 함수를 쓸 수 있다.
    // 이름 앞에 static이 붙어있는 함수는 Heap이나 Stack 영역에 저장되지 않는다
  // import A
    // A 패키지(폴더)를 가져오겠다. 가져와서 안에 있는 클래스 좀 쓰겠다.
  // am은 0, pm은 1
  // +=, -= 잘 기억하기★
  // 지역 변수 : 메소드 안에 있는 변수★
  // 객체 만들어질 때 핵주의 ★★★
    // new 뒤에 있는 클래스에 속한 멤버변수도 바로 선언됨 + 생성자 바로 호출됨에 유의.
    // 클래스를 상속할 때에는 상속한 클래스 먼저 호출하는 것 더욱 유의 ★★★
  // 캐스팅, 타입캐스팅 : 형 변환
  // 배열은 항상 객체이다.



// 클래스, 필드, 생성자, 메소드 ★★★
  // 속성 = 필드(멤버) = 멤버 변수 = 전역 변수
    // 클래스 영역에 저장한 변수
  // 기능 = 메소드 = 함수
  // 속성 + 기능 = 클래스 = 틀 = 설계도 = 참조형



// 클래스, 객체, 인스턴스 (혼자 찾아봄)
  // 인스턴스(Instance)
    // 어떤 원본(추상적인 개념)으로부터 ‘생성된 복제본’을 의미한다.
    // 예시) 객체 생성시 new ClassName();  <-- 이게 인스턴스★
  // 객체(Object)
    // 클래스에 선언된 모양 그대로 생성된 실체. "객체는 클래스의 인스턴스다."
    // Heap 메모리에 저장됨.
  // 클래스 VS 객체
    // 클래스는 ‘설계도’, 객체는 ‘설계도로 구현한 모든 대상’을 의미한다.
  // 객체 VS 인스턴스
    // 클래스의 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.
    // 엄격하게 객체와 인스턴스를 나누기는 어렵다.
    // 예시) ClassName a;  <-- 객체(클래스 타입으로 선언됨)★
      // a는 "객체(인스턴스) 참조(레퍼런스) 변수"★
  // 참조변수
    // 클래스를 인스턴스화 할 때 main에 저장하는 변수(이름)
  // 예시) c1.name
    // c1(참조변수)가 참조하는 객체의 name을 의미.
    // c1.name = "car";  <-- c1이 참조하는 객체의 name을 car로 설정.



// Primitive type(pt), Reference type(rt) (프리미티브 타입, 레퍼런스 타입) (혼찾)
  // Primitive type (pt)
    // ★원시형★
    // 원시변수를 만들 수 있음.
    // 값을 변수에 직접 대입하여 사용하는 형태
    // short, int, long, char, boolean, float, double
  // Reference type (rt)
    // ★참조형★
    // 참조변수를 만들 수 있음.
    // reference : "참조"라는 뜻.
    // 값을 변수에 대입하지만 변수는 참조값(메모리상)을 가지고있다.
    // pt값을 직접 들고있지 않다.
    // 클래스, 인터페이스, 배열, 열거형
    1. 레퍼런스(참조) 변수 선언★★★
      // ClassName name;  <-- name은 ClaassName 유형의 변수임을 선언. 객체 생성
    2. 인스턴스 생성
      // new ClassName();  <-- 새로운 ClassName 공간을 마련
    3. 참조 변수와 인스턴스를 연결
      // ClassName name = new ClassName();
        // 새로 만든 ClassName인스턴스와 변수name을 연결.
        // name은 새로 만든 ClassName으로 가는 주소, 포인터 값을 가진다.
        // 변수 이름만 바꿔 만들면 새로운 ClassName인스턴스가 계속 만들어짐.
        // name은 ClassName_name의 "객체를 참조한다"고 표현한다.★



// 공부, 프로그래밍 관련 조언
  // 자바 레퍼런스
  // 라이브러리



// 아직 알 필요 없는 것들
  // 업캐스팅, 다운캐스팅 (검색해서 정보 적음)
    // a instanceof A  30)★
      // (조건) 변수 a는 클래스 A를 불러오는가 아닌가를 구함. true or false.
      // 여기서는 업캐스팅된 참조변수a가 어느 클래스(인스턴스)를 불러오는지 구할 때 사용함.
      // 클래스(참조형)타입만 비교 가능.
  // 추상클래스, 인터페이스 사용법



// 나중에 배울 거
  // 데이터베이스
  // 서버 설치, 오퍼레이팅 시스템



// 업캐스팅  32)
  // 정의
    // 서브 클래스 객체가 슈퍼 클래스 타입으로 변환되는것이다.
    // 슈퍼클래스A로 만든 서브클래스B의 메모리(B의 인스턴스)
  // 작성방법
    // 객체 생성시 객체의 클래스 타입과 객체로 만들어지는 클래스를 다르게 쓴다.
      // 객체의 클래스 타입 : 상위클래스
      // 객체로 만들어지는 클래스 : 하위클래스
    // 예시
      // SuperClass a = new SubClass();  <-- Super~는 상위, Sub~는 하위
  // 효과
    // 상위 클래스 타입 a로 하위 클래스 값을 쓸 수 있다.
      // 하위 클래스가 상위 클래스의 함수를 그대로 가져다 쓰거나 멤버변수 타입과 이름을 그대로 쓸 때에만 하위 클래스의 내용을 사용할 수 있다.
      // 하위클래스에만 있는 변수나 함수에는 접근하지 못한다.
  // 메모리 시각화
    // 정리 파일 참고.



// Super.
  // 정의
    // 하위 클래스에서 상위 멤버 변수나 메소드를 가져다 쓸 수 있도록 하는 코드.
    // 업캐스팅과 역할이 반대됨.
  // 유의사항
    // extends 옆에 붙어있는 클래스에서만 불러올 수 있다.
  // 사용 예시
    // super.fly();  <-- 상위 클래스의 fly()라는 메소드를 호출하겠다.
  // 메모리 시각화  2)
    // 정리파일 참고.



// final
  // final + class + ClassName {}
    // ClassName 클래스를 상속할 수 없는 클래스로 지정
  // 접근제어자 + final + 타입 + finalMethod(){}
    // finalMethod(){}를 오버라이딩할 수 없는 메소드로 지정
    // super.로만 사용할 수 있음
  // final + 타입 + 변수 이름 = a;
    // final이 붙은 변수값 a는 변경할 수 없다. 상수 정의에 쓰인다.
  // 멤버 변수의 경우 final 앞에 접근제어자와 static이 붙을 수 있다.
    // public + static + final + 타입 + 변수 이름 = a;
      // 이렇게 쓰면 프로그램 전체에 공유해 쓸 수 있는 상수 a가 된다.



// String Class★★★
  // 정의
  // Integer.valueOf("a").intValue()
    // (타입변경) 문자a를 숫자로 바꾸기  5)
  // String.valueOf(k)
    // (타입변경) 변수k를 문자열로 바꾸기  5)
  // A.concat("a")
    // (나열) 문자열 a를 생성, 이후 생성부터는 우측으로 나열한다
  // A.compareTo(B)
    // (비교) 변수A와 변수B가 같으면 0, B가 많으면 +1, 더 적으면 -1를 리턴
  // A.equals(B)
    // (조건) 변수A와 변수B는 같은가. true or false
  // A.parse~(B)
  // A.indexOf("B")
    // (색인) 변수A에서 문자열B의 위치를 인덱스 번호로 찾아줌  7), 8)
      // 찾는 단어가 없으면 -1
  // A.substring(a,b)
    // (범위지정) 변수A의 a번째부터 b번째까지를 값으로 돌려줌  8)
      // a, b 둘 다 인덱스 번호
      // b는 인덱스번호+1★
  // A.trim()
    // (내용변경) String 변수A의 "앞뒤" 공백을 지워준다.  10)
  // A.toLowerCase()
    // (내용변경) 변수 A의 알파벳을 모두 소문자로 변환한다.  11)
  // A.toUpperCase()
    // (내용변경) 변수 A의 알파벳을 모두 대문자로 변환한다.  11)
    // Upper, Lower 둘 다 indexOf()와 연관
  // A.split("a")
    // (분리) a를 기준으로 문자열을 쪼갠다. a는 지워짐.  12), 13)
    // 변수 선언시 배열 변수로 해야됨.
  // A.replace("a","b")
    // (내용변경) 변수A안에 "a"내용을 "b"로 변경  14)
  // A.contains("a")
    // (조건) 내용 a가 들어있는가. true or false
  // A.strtsWith("a")
    // (조건) 시작문자가 a와 일치하는가. true or false
  // A.endsWith("a")
    // (조건) 끝문자가 a와 일치하는가. true or false



// StringTokenizer Class  15)
  // new StringTokenizer(a,"b")
    // (분리) (객체 생성식으로 사용) 변수a 안의 내용을 b로 쪼갠다. b는 지워짐.
    // 배열변수로 선언할 필요 없음.
  // A.countTokens()
    // (계산) 나눠진 문자열의 총 개수를 구한다. 낱자가 아니라 뭉치 기준.
  // A.nextToken() ★
    // (변경) 호출할 때마다 등록된 순서대로 값을 불러와 바꿔준다



// StringBuilder Class  16)
  // StringBuilder의 객체 생성 후 아래의 함수들을 사용
    // 이하 main에 저장된 변수 이름이 A일 때
  // A.append("a")
    // (나열) 문자열 a를 생성, 이후 생성부터는 우측으로 나열한다
  // A.insert(a,"b")
    // (추가) (내용변경) 인덱스번호a의 위치에 b를 추가한다.
      // a 위치 뒤에 있던 문자열들은 알아서 b 뒤로 나열됨.
  // A.toString()
    // (타입변경) 변수A를 String 타입으로 변환.
  // A.replace(a,b,"c")
    // (내용변경) 인덱스번호 a부터 b까지의 영역을 문자열 c로 변경.
    // b는 인덱스번호+1★



// Math Class  18)
  // static Class : 객체 생성 없이 바로 활용 가능★
  // Math.abs(a)
    // (절대값) 절대값을 구해준다. (내 눈으로 보기엔 마이너스 없애주는 용도)
  // Math.ceil(a) ★
    // (올림) 숫자a보다 오른쪽에 있는 "정수"로 가라. only double type.
  // Math.floor(a) ★
    // (내림) 숫자a보다 왼쪽에 있는 "정수"로 가라. only double type.
  // Math.round(a) ★
    // (반올림) 숫자a를 반올림. 반올림의 결과값이 long타입이기 때문에 only long type
  // Math.max(a,b)
    // (비교) a와 b를 비교해서 더 큰 수를 구한다.
  // Math min(a,b)
    // (비교) a와 b를 비교해서 더 적은 수를 구한다.
  // Math.random() ★★★  19)
    // (랜덤) 0이상 1미만 값을 double형으로 랜덤으로 뽑아준다. only double type.
      // 보통 (Math.random()*n)+1을 해서 1이상 n미만 사이의 수를 뽑아준다.



// Date, SimpleDateFormat Class  20)
  // Date a = new Date();
    // (Get) 현재 날짜 데이터로 가는 경로를 a에 저장
  // String b = a.toString();
    // (타입변환) a를 String 타입으로 변환해놓은 곳으로 가는 경로를 b에 저장
    // 기본 형태의 양식으로 저장됨.
  // SimpleDateFormat c = new SimpleDateFormat("yy-MM-dd HH:mm:ss");
    // (변경) 날짜, 시간 양식을 "yy-MM-dd HH:mm:ss"로 변경하고 이 양식으로 가는 경로를 c에 저장
  // String d = c.format(a);
    // (변경) c변수(양식)에 a변수(날짜데이터)를 추가하고 String타입으로 d에 저장.
    // d를 프린트하면 바뀐 양식(c)으로 a가 표시됨.



// Local~ Class  24)
  // Local~는 객체 생성 없이 함수 사용 가능(static).
  // Local~
    // LocalDate
    // LocalTime
    // LocalDateTime
  // Local~.now();
    // (Get) 현지의 현재 날짜 or 시간 or 날짜시간 데이터를 리턴.
  // Local~.of(a,b,c,d,e,f,g);
    // (Get) 직접 지정한 날짜 or 시간 or 날짜시간 데이터를 리턴.
    // Date : a(년도4자리), b(월),  c(일)
    // Time : a(시간-24시), b(분), c(초)
    // DateTime : a년, b월, c일, d시, e분, f초, g밀리세컨 순서



// ZonedDateTime Class  24), 31)
  // Zoned~는 객체 생성 없이 함수 사용 가능(static)
  // ZonedDateTime.now(ZoneId.of("UTC"));
    // (Get) UTC의 ZoneId를 리턴한 다음, 돌려받은 Id의 날짜와 시간 데이터를 리턴.
    // 프린트하면 해당 지역의 날짜, 시간이 표시됨.
  // ZoneId.getAvailableZoneIds()
    // (Get) 시간대를 이용할 수 있는 모든 국가(지역) 정보들을 리턴.
    // 변수 선언은 <>로.



// a.get~()
    // (Get) 날짜타입 변수a에서 ~(년, 월, 일..)데이터를 리턴.
    // Year() : a의 년도 데이터를 리턴. int타입.
    // Month() : a의 월 데이터를 리턴. int타입 아니고 Month타입임.
    // DayOfMonth() : a의 일(월 기준) 데이터를 리턴. int타입.



// A.plus~(a).minus~(b)  24)
  // (계산) 변수 A에 저장한 특정 날짜를 기준으로 "a만큼 더하거나 b만큼 빼서" 계산한 값을 각각 리턴.
  // plus~(a) or minus~(a)
    // ~Years(a) : 년도를 a만큼 + or -
    // ~Months(a) : 월을 a만큼 + or -
    // ~Days(a) : 일을 a만큼 + or -
    // ~Hours(a) : 시간을 a만큼 + or -
    // ~Minutes(a) ~Seconds(a) ...

////200514 여기까지

// a.is~(b)  25)
  // (비교) a는 b에 비해 ~한가. 여기서는 시간 비교에 쓰임. true or false.
  // is~
    // is~ 이름의 함수는 결과값이 boolean 타입.
    // a.isBefore(b) : a는 b의 이전에 있는가.
    // a.isEqual(b) : a는 b와 같은가.
    // a.isAfter(b) : a는 b의 이후에 있는가.



// a.isLeapYear()  24)
    // (조건) 변수a안에 있는 날짜 데이터가 윤년인지 확인해줌. true or false.
    // 특정 날짜 데이터를 변수a로 지정한 다음 사용.



// a.until(b,ChronoUnit.~);  26)
  // (계산) 날짜값 변수a와 b의 ~(년도,월,일 등)을 비교해 남는 숫자를 계산.
  // 변수 선언시 long type only
  // ChronoUnit.~
    // YEARS : 년도 비교
    // MONTHS : 월 비교
    // DAYS : 일 비교
    // HOURS, MINUTES, SECONDS, ... : 시간, 분, 초 ... 비교



// DecimalFormat Class★  22)
  // 숫자, 날짜 양식 포맷팅에 도움을 주는 클래스.
  // 설정한 "포맷"에 들어갈 "변수"는 따로 필요함.
  // DecimalFormat a = new DecimalFormat("b");
    // b로 설정한 유형으로 가는 경로를 a에 저장.
  // a.fotmat(c)
    // (Get) (변경) a가 가리키는 b유형에 c를 대입한 값을 리턴.
  // b에 들어가는 포맷 생성 규칙
    // 0.00... : .을 기준으로 뒤의 0의 개수만큼 자릿수 표현.
    // ...00.0 : .을 기준으로 앞의 0의 개수만큼 자릿수 표현.
    // 0 : 자릿수 맞추고 남은 자리는 0표시.
    // # : 자릿수 맞추고 남은 자리는 표시하지 않음.
    // .기준 앞에 0이나 #이 하나만 붙으면 앞자리수 내용을 전부 표시.
    // .은 앞자리만 적고싶을 땐 생략한다.
    // .0E0 : 10의 n승으로 표기해줌. 예시) 1.2E6 : 1.2곱하기 10의 6승.
    // +0 ; -0 : 대입하는 값이 양수면 +, 음수면 -를 붙여서 표시해줌.



// MessageFormat Class★  23)
  // 문자열 포맷팅에 도움을 주는 클래스.
  // {0}{1}{2}
    1. 변수 a, b, c를 선언
    2. 인덱스 넘버{0}, {1}, {2}를 포함하는 문자열 변수 d 선언
    3. String formatting = MessageFormat.format(d,a,b,c); 선언
      // 변수a, b, c는 선언한 순서대로 {0}, {1}, {2}가 되고, 이걸 d의 각 위치에 대입한다.
    4. d를 출력하면, 변수 a, b, c의 변수값이 인덱스 넘버를 기입한 자리에 각각 들어가 같이 출력됨.
    // 변수d에서는 필요에 따라 인덱스의 위치가 뒤바뀌어도 됨.
    // 변수 선언 순서나 .fotmat 안의 순서가 바뀌면 인덱스 값도 바뀜.
  // \n (역슬래시n) : 문자열 안에서 엔터(줄바꿈)의 역할을 한다.


200514 목요일 수업에 쓰인 코드





1) Super 예시
=====SuperParent
package com.tenisme.libjava;

public class SuperParent {
    protected int a = 10;

    public void print(){
        System.out.println("SuperParent print()");
        System.out.println("a = "+a);
        System.out.println();
    }

}
=====SuperChild
package com.tenisme.libjava;

public class SuperChild extends SuperParent {
    private int a = 20;

    @Override
    public void print(){
        System.out.println("SuperChild Print()");
        System.out.println("a = "+a);
        System.out.println();
    }

    void superCall(){
        System.out.println("Super.a = "+ super.a);
        super.print();
    }

}
=====main
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        SuperParent sp = new SuperChild();
        sp.print();

    }

}
=====
// 결과값
> Task :libjava:MyClass.main()
TestChild Print()
a = 20





2) super 예시2
=====SuperParent
package com.tenisme.libjava;

public class SuperParent {
    protected int a = 10;

    public void print(){
        System.out.println("SuperParent print()");
        System.out.println("a = "+a);
        System.out.println();
    }

}
package com.tenisme.libjava;

public class SuperChild extends SuperParent {
    int a = 20;

    @Override
    public void print(){
        System.out.println("SuperChild Print()");
        System.out.println("a = "+a);
        System.out.println();
    }

    public void superCall(){
        System.out.println("Super.a = "+ super.a);
        super.print();
    }

}
=====main
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        SuperChild sp = new SuperChild();
        sp.print();
        sp.superCall();

    }

}
=====
// 결과값
> Task :libjava:MyClass.main()
SuperChild Print()
a = 20

Super.a = 10
SuperParent print()
a = 10





3) super 예시
=====Airplane
package com.tenisme.libjava;

public class Airplane {
    void land(){
        System.out.println("Landing");
    }
    void fly(){
        System.out.println("Flying");
    }
    void takeOff(){
        System.out.println("Take off");
    }
}
=====ChildAirplane
package com.tenisme.libjava;

public class ChildAirplane extends Airplane{
    int flyMode = 1;

    @Override
    void fly() {
        if(flyMode == 1){
            super.fly();
        }else{
            System.out.println("Child Flying");
        }
    }
}
=====main
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        ChildAirplane ca1 = new ChildAirplane();

        ca1.flyMode = 1;
        ca1.takeOff();
        ca1.fly();
        ca1.land();

        System.out.println();

        ca1.flyMode = 2;
        ca1.takeOff();
        ca1.fly();
        ca1.land();
    }

}
=====
// 결과값
> Task :libjava:MyClass.main()
Take off
Flying
Landing

Take off
Child Flying
Landing





4) final 예시
=====PrivateMember
package com.tenisme.libjava;

public class PrivateMember {
    public static final int NUMBER = 100;
    int a = 10;


    final void speedUp(){ // 이 함수는 다른 클래스에서 못 갖다쓴다.
        NUMBER = 1000; // 변수 final을 붙였기 때문에 오류뜸.
        a = a + 10;
    }
    void speedDown(){
        a = a - 10;
    }
}
=====ChildMember
package com.tenisme.libjava;

public class ChildMember extends PrivateMember {

    @Override
    void speedDown() {
        a = a - 1000;
    }
}
=====





5) String class 예시
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        int i = Integer.valueOf("123").intValue();
        float f = Float.valueOf("23.5").floatValue();

        System.out.println(i);
        System.out.println(f);

        int k = 15;
        double d = 15.6;

        String sk = String.valueOf(k);
        String sd = String.valueOf(d);



        String str1 = "hello";
        String str2 = new String("Java");

        String s_i = "123";
        String s_f = "23.5";
        String s_d = "234.567";

        System.out.println(s_i+s_f+s_d);

        int o = Integer.valueOf(s_i).intValue(); // 문자를 숫자로 바꾸기
        float w = Float.valueOf(s_f).floatValue();
        double x = Double.valueOf(s_d).doubleValue();

        System.out.println(o+w+x);

        int l = Integer.parseInt(s_i); // 숫자를 
        float p = Float.parseFloat(s_f);
        double z = Double.parseDouble(s_d);
        System.out.println("l + p = " + l + p);
        System.out.println("l + p = " + (l + p)); // 두개 차이 비교해보기★

        String str5 = String.valueOf(l); // 숫자를 문자열로 바꾸기
        System.out.println(str5 + 1000); 
        
        String str6 = Integer.toString(o);
        String str7 = Float.toString(w);
        String str8 = Double.toString(x);
        
        System.out.println(str6);
        System.out.println(str7);
        System.out.println(str8);
    }

}
=====
// 결과값
> Task :libjava:MyClass.main()
123
23.5
12323.5234.567
381.067
l + p = 12323.5
l + p = 146.5
1231000
123
23.5
234.567





6) String class 예시2
package com.tenisme.libjava;

public class MyClass {


    public static void main(String[] args) {

        System.out.println("concat() test : " + "abc".concat("def"));

        String strVar = new String("Hello");
        String strVar2 = "Hello";

        String concatStr = strVar.concat(strVar2);
        System.out.println(concatStr);

        if(strVar == strVar2){
            System.out.println("The same String");
        }else{
            System.out.println("Different String");
        }

        if(strVar.compareTo(strVar2) == 0){
            System.out.println("The same String");
        }else{
            System.out.println("Different String");
        }

        if(strVar.equals(strVar2)){
            System.out.println("The same String");
        }else{
            System.out.println("Different String");
        }
    }
}
=====
// 결과값
> Task :libjava:MyClass.main()
concat() test : abcdef
HelloHello
Different String
The same String
The same String





7) String예시(문자열 찾기와 활용)
        String subject = "java programming language class";
        int location = subject.indexOf("mm");
        System.out.println(location);
=====
// 결과값
11

8) 해당 문자열이 있는지 없는지 찾아내기, 문자열 자르기
        String subject = "java programming language class";

        if(subject.indexOf("mango") != -1){
            System.out.println("exists");
        }else{
            System.out.println("No word");
        }

        System.out.println(subject.substring(0,4));
        System.out.println(subject.substring(5,16));
=====
// 결과
No word
java
programming





9) 예시 글자 길이 구하기
        String ssn = "13546678321867465134341234";
        int len = ssn.length();

        String subject = "java programming language class";
        int len1 = subject.length();

        System.out.println(len);
        System.out.println(len1);
=====
// 결과
26
31





10) 공백이 들어가 있으면 다른 문자로 친다. 공백 판별하기
        if("programming".compareTo(" programming") == 0){
            System.out.println("Same");
        }else{
            System.out.println("Different");
        }
=====
// 결과
Different

===앞에도 뒤에도 공백이 있으면 어떻게 판별하지
& 앞뒤 공백 지우기
        String ex1 = " pro gramming";
        String ex2 = "pro gramming ";
        String ex3 = "      pro gramming       ";


        System.out.println("ex1 : " + ex1.length() + ", ex2 : " + ex2.length() +
                ", ex3 : " + ex3.length());

        ex1 = ex1.trim();
        ex2 = ex2.trim();
        ex3 = ex3.trim();

        System.out.println("ex1 : " + ex1.length() + ", ex2 : " + ex2.length() +
                ", ex3 : " + ex3.length());

        System.out.println(ex1);
        System.out.println(ex2);
        System.out.println(ex3);
=====
// 결과
ex1 : 12, ex2 : 12, ex3 : 24
ex1 : 11, ex2 : 11, ex3 : 11





11) 대문자를 소문자로 바꾸기
        String subject = "java programming language class";

        if(subject.indexOf("Java") != -1){
            System.out.println("exists");
        }else{
            System.out.println("No word");
        }

        String search_word = "JaVa";
        
        subject = subject.toLowerCase();
        search_word = search_word.toLowerCase();

        if(subject.indexOf(search_word) != -1){
            System.out.println("exists");
        }else{
            System.out.println("No word");
        }
=====
결과값
No word
// 자바는 java(소문자)와 Java(대문자)를 구분한다. 그래서 No word 출력.
exists
// 대문자가 섞인 JaVa를 소문자로 바꿔주고 비교했기 때문에 exists 출력.





12) 문자열에 콤마가 들어있을 때 분리하기
        String color = "red, blue, white, orange";
        String[] arr = color.split(", ");

        for(int i = 0; i < arr.length; i++){
            System.out.println(arr[i]);
        }
=====
// 결과값
red
blue
white
orange





13) 분리하기 2
        String subject = "java programming language class";

        String[] arr2 = subject.split(" ");
        for(int i = 0; i < arr2.length; i++){
            System.out.println(arr2[i]);
        }

        String[] arr3 = subject.split("a");
        for(int i = 0; i < arr3.length; i++){
            System.out.println(arr3[i]);
        }
=====
// 결과
java
programming
language
class
j
v
 progr
mming l
ngu
ge cl
ss





14) 단어 바꾸기
        String subject = "java programming language class";
        String req_str = subject.replace("java","Python");
        System.out.println(subject);
        System.out.println(req_str);

        System.out.println(subject.contains("class"));
        if(subject.contains("Class")){
            System.out.println("subject");
        }else{
            System.out.println("not subject");
        }

        String url = "http://www.naver.com";
        System.out.println(url.startsWith("http"));

        if(url.startsWith("http")){
            System.out.println("Web");
        }else{
            System.out.println("Not Web");
        }
        System.out.println(url.endsWith("kr"));
        if(url.endsWith("kr")){
            System.out.println("korea");
        }else{
            System.out.println("Not Korea");
        }
=====
// 결과값
java programming language class
Python programming language class
true
not subject // 대소문자 구분해서 그럼.
true
Web
false
Not Korea





15) StringTokenizer 래퍼런스 잘 갖다 쓰기. ?? 이건 배열로 저장되는 게 아닌 건가? 아닌 거임. 변수 st에 레드 그린 등등이 다 알아서 들어가 있다고 생각하면 됨.
        String text = "red/green/blue/white/black";
        StringTokenizer st = new StringTokenizer(text,"/"); // 남이 만든 클래스

        int countTokens = st.countTokens(); // 스트링~ 클래스에 포함되어있는 함수. 남이 짠 메소드 호출함.
        System.out.println(countTokens);

        for(int i = 0; i <countTokens; i++){
            String token = st.nextToken(); // 쓸 때마다 st 안에 있는 값들을 인덱스 0부터 순서대로 불러 바꿔주겠다는 메소드 호출. nextToken(); <- 다음 토큰을 불러와라.
            System.out.println(token);
}
=====
// 결과값
5
red
green
blue
white
black

===활용하기2===
        String text = "red/green/blue/white/black";
        StringTokenizer st2 = new StringTokenizer(text,"/");
        while(st2.hasMoreTokens()){
            String token = st2.nextToken();
            System.out.println(token);
        }
=====
// 결과값
red
green
blue
white
black





16) StringBuilder 사용하기 (문자열 추가하기. 옆으로 붙는다.)
        StringBuilder sb = new StringBuilder();
        sb.append("Java ");
        sb.append("Programming Class");
        System.out.println(sb);
=====
// 결과값
Java Programming Class

===중간에 문자열 추가하기===
        StringBuilder sb = new StringBuilder();
        sb.append("Java ");
        sb.append("Programming Class");
        sb.append(" Bye");
        sb.insert(5,"language");
        System.out.println(sb);
=====
// 결과값
Javalanguage Programming Class Bye





17) 리플레이스, 스트링으로 바꾸기
        sb.replace(0,4,"Python");
        System.out.println(sb);

        System.out.println(sb.length());

        String str = sb.toString();
        System.out.println(str);




18) Math 설명
        Math v1 = new Math(); // 보통은 이렇게 씀
        v1.abs = 1;
=====
        int v1 = Math.abs(-5); // 근데 아무 객체 생성도 없이 이렇게 쓰는 것이 가능.
=====
        int v1 = Math.abs(-5);
        double v2 = Math.abs(-3243.234);
        float v3 = Math.abs(-23111.455f);
        long v4 = Math.abs(-324234L);

        System.out.println(v1+","+v2+","+v3+","+v4);

        double a1 = Math.ceil(5.3);
        double a2 = Math.ceil(-5.3);
        System.out.println(a1);
        System.out.println(a2);

        double a3 = Math.floor(5.7);
        double a4 = Math.floor(-5.7);
        System.out.println(a3);
        System.out.println(a4);

        int b1 = Math.max(1,10);
        System.out.println(b1);

        int b2 = Math.min(-238,-224);
        System.out.println(b2);

        double c = Math.random();
        System.out.println(c);

        c = Math.random()*10;
        System.out.println(c);

        c = Math.random()*10;
        System.out.println(c);

        long v14 = Math.round(5.6);  ?? why long???????
        long v15 = Math.round(5.1); // A. 라운드 함수는 리턴 타입이 롱으로 되어있음.
        System.out.println(v14);
        System.out.println(v15);
=====





19) Math예제(주사위놀이 구하기)
        int num = (int)(Math.random()*45)+1;
        System.out.println(num);
=====





20) 날짜 관련(현재 날짜 출력하기)
package com.tenisme.libjava;

import java.text.SimpleDateFormat;
import java.util.Date;

public class MyClass {


    public static void main(String[] args) {

        Date now = new Date();
        String strNow1 = now.toString();
        System.out.println(strNow1);

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String strNow2 = sdf.format(now);
        System.out.println(strNow2);

        SimpleDateFormat sdf2 = new SimpleDateFormat("yy/MM/dd HH:mm:ss");
        String strNow3 = sdf2.format(now);
        System.out.println(strNow3);
=====
// 결과값
Thu May 14 15:14:08 KST 2020
2020-05-14 15:14:08
20/05/14 15:14:08





21) 캘린더 클래스는 연월일시분초 하나씩 다 불러올 수 있음.
package com.tenisme.libjava;

import java.util.Calendar;

public class MyClass {


    public static void main(String[] args) {

        Calendar now = Calendar.getInstance();
        int year = now.get(Calendar.YEAR);
        int month = now.get(Calendar.MONTH)+1;
        int day = now.get(Calendar.DAY_OF_MONTH);
        int week = now.get(Calendar.DAY_OF_WEEK);

        String strWeek = null;
        switch(week){
            case Calendar.MONDAY:
                strWeek = "Mon";
                break;
            case Calendar.TUESDAY:
                strWeek = "Tue";
                break;
            case Calendar.WEDNESDAY:
                strWeek = "Wed";
                break;
            case Calendar.THURSDAY:
                strWeek = "Thu";
                break;
            case Calendar.FRIDAY:
                strWeek = "Fri";
                break;
            case Calendar.SATURDAY:
                strWeek = "Sat";
                break;
            case Calendar.SUNDAY:
                strWeek = "Sun";
                break;
        }

        System.out.println(strWeek);
        System.out.println(week);

        int amPm = now.get(Calendar.AM_PM);
        String strAmPm = null;
        if(amPm == Calendar.AM){
            strAmPm = "AM";
        }else{
            strAmPm = "PM";
        }
        System.out.println(amPm);
        System.out.println(strAmPm);

        int hour = now.get(Calendar.HOUR);
        int minute = now.get(Calendar.MINUTE);
        int second = now.get(Calendar.SECOND);
        System.out.println(year+"-"+month+"-"+day+" "+hour+":"+minute+":"+second);

    }
}
=====
// 결과값
> Task :libjava:MyClass.main()
Thu
5
1
PM
2020-5-14 3:43:3





22) 포맷팅
        double num = 1234567.89;

        DecimalFormat df = new DecimalFormat("0");
        System.out.println(df.format(num));

        df = new DecimalFormat("0.0");
        System.out.println(df.format(num));

        df = new DecimalFormat("0.00");
        System.out.println(df.format(num));


        df = new DecimalFormat("0000000000.00000");
        System.out.println(df.format(num));

        df = new DecimalFormat("#.#");
        System.out.println(df.format(num));

        df = new DecimalFormat("#########.########");
        System.out.println(df.format(num));

        df = new DecimalFormat("#.0");
        System.out.println(df.format(num));

        df = new DecimalFormat("+#.0");
        System.out.println(df.format(num));

        df = new DecimalFormat("-#.0");
        System.out.println(df.format(num));

        df = new DecimalFormat("#,###.0");
        System.out.println(df.format(num));

        df = new DecimalFormat("0.0E0");
        System.out.println(df.format(num));

        df = new DecimalFormat("+#,### ; -#,###");
        System.out.println(df.format(num));

        df = new DecimalFormat("#.00%");
        System.out.println(df.format(num));
=====
// 결과값
1234568
1234567.9
1234567.89
0001234567.89000
1234567.9
1234567.89
1234567.9
+1234567.9
-1234567.9
1,234,567.9
1.2E6
+1,234,568 
123456789.00%





23) 문자열 포맷팅
        String id = "Java";
        String name = "Mike";
        String tel = "010-1234-5678";
        String gender = "male";

        String id2 = "Python";
        String name2 = "Harry";
        String tel2 = "010-5555-3333";
        String gender2 = "female";

        String text = "user Id : {0} \nuser name : {1} \ngender : {3}\nuser tel : {2}";

        String result1 = MessageFormat.format(text,id,name,tel,gender);
        System.out.println(result1);
        System.out.println();
        String result2 = MessageFormat.format(text,id2,name2,tel2,gender2);
        System.out.println(result2);
=====
// 결과값
user Id : Java 
user name : Mike 
gender : male
user tel : 010-1234-5678

user Id : Python 
user name : Harry 
gender : female
user tel : 010-5555-3333





24) 날짜, 시간(타임패키지) 계산
package com.tenisme.libjava;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;

public class MyClass {


    public static void main(String[] args) {
        //local date
        LocalDate currDate = LocalDate.now();
        System.out.println("local : "+currDate);

        //target date
        LocalDate targetDate = LocalDate.of(2024,5,10);
        System.out.println("target Date : "+targetDate);
        System.out.println();

        //local time
        LocalTime currTime = LocalTime.now();
        System.out.println("current Time : "+currTime);

        //target time
        LocalTime targetTime = LocalTime.of(23,30,0,0);
        System.out.println("target Time : "+targetTime);

        //local date time1
        LocalDateTime currDateTime = LocalDateTime.now();
        System.out.println("current : " + currDateTime);

        //target date time
        LocalDateTime targetDateTime = LocalDateTime.of(2024,5,10,23,30,0,0);
        System.out.println("target : "+targetDateTime);

        //ZonedDateTime
        ZonedDateTime utcDateTime = ZonedDateTime.now(ZoneId.of("UTC"));
        System.out.println("UTC : "+utcDateTime);

        ZonedDateTime newyorkDateTime =
                ZonedDateTime.now(ZoneId.of("America/New_York"));
        System.out.println("new york : "+newyorkDateTime);

        //local date time2 ??
        LocalDateTime now = LocalDateTime.now();
        System.out.println(now);

        String strDateTime = now.getYear() + "/";
        strDateTime += now.getMonth() + "/";
        strDateTime += now.getDayOfMonth() + " ";

        System.out.println(strDateTime);

        // local date time2 이렇게도 가능(셀프테스트)
        LocalDateTime now = LocalDateTime.now();
        System.out.println(now);

        int now1 = now.getYear();
        Month now2 = now.getMonth();
        int now3 = now.getDayOfMonth();

        System.out.println(now1+"/"+now2+"/"+now3);

        //yunDal  <--  윤달구하기
        LocalDate nowDate = now.toLocalDate();
        if(nowDate.isLeapYear()){
            System.out.println("Yes Leap Year, 29");
        }else{
            System.out.println("No Leap Year, 28");
        }

        //Change DateTime  <-- 로컬타임 기준으로 시간날짜 바꾸기
        LocalDateTime targetDateTime2 = now.plusYears(1)
                .minusMonths(2).plusDays(4).plusHours(2);
        System.out.println(targetDateTime2);

    }

}

=====
// 결과값
> Task :libjava:MyClass.main()
local : 2020-05-14
target Date : 2024-05-10

current Time : 16:54:22.657
target Time : 23:30
current : 2020-05-14T16:54:22.657
target : 2024-05-10T23:30
UTC : 2020-05-14T07:54:22.657Z[UTC]
new york : 2020-05-14T03:54:22.657-04:00[America/New_York]
2020-05-14T16:54:22.657
2020/MAY/14 
Yes Leap Year, 29
2021-03-18T18:54:22.657





25) 시간 비교하기
        // start time vs end time
        LocalDateTime startDateTime =
                LocalDateTime.of(2024,3,31,18,0,0);
        System.out.println("Start date : "+startDateTime);

        LocalDateTime endDateTime =
                LocalDateTime.of(2024,3,31,18,0,0);
        System.out.println("Start date : "+endDateTime);

        if(startDateTime.isBefore(endDateTime)){
            System.out.println("ing...");
        }else if(startDateTime.isEqual(endDateTime)){
            System.out.println("same");
        }else if(startDateTime.isAfter(endDateTime)){
            System.out.println("end");
        }
=====
// 결과값
Start date : 2024-03-31T18:00
Start date : 2024-03-31T18:00
same





26) 
        //남은연도구하기
        long remainYear =
                startDateTime.until(endDateTime, ChronoUnit.YEARS);
        System.out.println(remainYear);

        //남은달구하기
        long remainMonth =
                startDateTime.until(endDateTime, ChronoUnit.MONTHS);
        System.out.println(remainMonth);

        //남은날구하기
        long remainDay =
                startDateTime.until(endDateTime, ChronoUnit.DAYS);
        System.out.println(remainDay);

        long remainHour =
                startDateTime.until(endDateTime, ChronoUnit.HOURS);
        System.out.println(remainHour);

        long remainMinute =
                startDateTime.until(endDateTime, ChronoUnit.MINUTES);
        System.out.println(remainMinute);

        long remainSecond =
                startDateTime.until(endDateTime, ChronoUnit.SECONDS);
        System.out.println(remainSecond);

        //남은연도구하기2
        remainYear = ChronoUnit.YEARS.between(startDateTime,endDateTime);
=====
//결과값
2
32
974
23376
1402560
84153600





27) formatter
        DateTimeFormatter formatter;
        LocalDate localDate;

        localDate = LocalDate.parse("2024-05-21");
        System.out.println(localDate);

        formatter = DateTimeFormatter.ISO_LOCAL_DATE;
        localDate = LocalDate.parse("2024-05-21",formatter);
        System.out.println(localDate);

        formatter = DateTimeFormatter.ofPattern("yyyy.MM.dd");
        localDate = LocalDate.parse("2024.05.21",formatter);
        System.out.println(localDate);
=====
// 결과값
2024-05-21
2024-05-21
2024-05-21





27) 어레이 리스트(Array List)
        ArrayList<String> list = new ArrayList<String>();

            list.add("Java");
            list.add("Python");
            list.add("Javascript"); // add list
            list.add(1,"C");
            list.add("SQL");

            for(int i = 0;i < list.size();i++){
                System.out.println(list.get(i));
            }
======
// 결과값
Java
C
Python
Javascript
SQL




28) 업캐스팅 예시 (수업내용x)
        // 레퍼런스 student를 이용하면 name, dept에 접근 가능
        Student student = new Student("MadPlay");  // 업캐스팅 방법1-1

        // 레퍼런스 person을 이용하면 Student 객체의 멤버 중
        // 오직 Person 클래스의 멤버만 접근이 가능합니다.
        Person person = student;  // 업캐스팅 방법1-2
        person.name = "Kimtaeng";
        
        // 아래 문장은 컴파일 타임 오류
        person.dept = "Computer Eng";
=====
// 아래와 같이 명시적으로 타입 캐스팅 선언을 하지 않아도 된다.
Person person = (Person) student;
=====main
// 취객, 해장국, 뼈해장국 전부 클래스 이름. 해장국먹기는 함수 이름.
        취객 취객1 = new 취객();
        해장국 해장국한그릇 = new 뼈해장국();
        취객1.해장국먹기(해장국한그릇);



29) 다운캐스팅 예시 (수업내용x)
// Person은 상위, Student는 하위
        // 업캐스팅 선행
        Person person = new Student("MadPlay");  // 업캐스팅 방법2

        // 다운캐스팅
        Student student = (Student) person;  // 변수person의 타입을 다시 Student로 돌린다.

        // Okay!
        student.name = "Kimtaeng";

        // Okay!
        student.dept = "Computer Eng";  // 다운캐스팅하고 나서는 다시 dept에 접근 가능



30) instanceof 예시 (수업내용x)
=====main
        Unit unit1 = new Unit();
        Unit unit2 = new Zealot(); // 업캐스팅 - Unit이 만든 Zealot객체에서 unit변수를 정의★
        Unit unit3 = new Marine(); // 업캐스팅
        Unit unit4 = new Zergling(); // 업캐스팅
=====
public void attackEnemy(Unit unit) {
  // unit이 가리키는 객체가 Unit일 수도 있고
  // Zealot, Marine, Zergling일 수도 있다.
=====instanceof사용
 if (unit1 instanceof Unit) { // true
            System.out.println("unit1은 Unit 타입이다.");
        }
        if (unit1 instanceof Zealot) { // false
            System.out.println("unit1은 Zealot 타입이다.");
        }
        if (unit2 instanceof Zealot) { // true
            System.out.println("unit2는 Zealot 타입이다.");
        }
        if (unit2 instanceof Zergling) { // false
            System.out.println("unit2는 Zergling 타입이다.");
        }
        if (unit3 instanceof Unit) { // false
            System.out.println("unit3은 Unit 타입이다.");
        }
        if (unit4 instanceof Zergling) { // true
            System.out.println("unit4는 Zergling 타입이다");



31) ZonedDateTime(수업x)
    // 각 시간대는 America/New_York, Europe/Berlin 등 ID가 존재한다.
    Set<String> availableZoneIds = ZoneId.getAvailableZoneIds(); // 이용할 수 있는 모든 시간대를 얻는다.
    for(String str : availableZoneIds){
        System.out.println(str); // Asia/Aden, America/Chicago, Europe/Luxembourg ...
    }
}



32) 업캐스팅/다운캐스팅 연습(수업x)
package com.tenisme.libjava;

public class TestParent {

    protected int a = 10;

    public void print(){
        System.out.println("TestParent print()");
        System.out.println("a = "+a);
        System.out.println();
    }

}
=====
package com.tenisme.libjava;

public class TestChild extends TestParent {

    private int a = 20;

    @Override
    public void print(){
        System.out.println("TestChild Print()");
        System.out.println("a = "+a);
        System.out.println();
    }

    void superCall(){
        System.out.println("Super.a = "+ super.a);
        super.print();
    }
}
=====
package com.tenisme.libjava;


public class myclass1 {


    public static void main(String[] args) {

        TestParent tp = new TestChild();
        tp.print();

//        tp.superCall();  <-- 컴파일 에러

        TestChild tc;

        tc = (TestChild)tp;

        tc.superCall();

    }
}
=====결과값
TestChild Print()
a = 20

Super.a = 10
TestParent print()
a = 10200515 금요일 수업 메모 정리



// 해야 할 거
  // 함수 만들기 연습하기
  // +=, -= 실습
  // 질문



// 기본 정보
  // ★ true or false는 boolean
    // 과제를 볼 때 함수가 뭘 리턴해야 하는지 리턴이 필요 없는지를 잘 살펴야 함.
  // 객체(인스턴스)가 생성(new)된다는 건 Heap 메모리가 생성된다는 것!!!
  // return 밑에는 break처럼 뭐 못 씀
  // 클래스~ 멤버변수(필드 멤버)~ 생성자~ 메소드~
  // 리턴해야 하는 함수는 특히 조건문이 있을 때 하나하나 빠짐없이 리턴 다 달아줘야 한다.
  // ★ 생성자도 메소드 오버로딩할 수 있음.
  // ★ 인수값 : 넘겨받는(받을) 값
  // ★main은 Stack!!! 객체(인스턴스)는 Heap!!!!!!★
  // i는 인티저(Integer)의 약자로 쓰는 듯. 아님 인덱스(Index)거나.
    // Integer : 정수. int.
    // Index : 색인. 인덱스 그거.
  // ★ String도 객체.
  // 클래스는 사람들이 쓰기 편하게 만들자.
    // 예시) 오버로딩!!!!!!
  // value : 값, 가치



// super()과 super.의 활용(용도) 차이
  // super.
    // super 키워드는 부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조하는 데 사용하는 ★참조 변수★
    // super.슈퍼클래스멤버변수이름 = a;
    // super.슈퍼클래스메소드이름(a);
  // super()
    // super() 메소드는 ★부모 클래스의 생성자를 호출★할 때 사용된다.
    // super(a);



// this()
  // this() 메소드는 ★같은 클래스의 다른 생성자를 호출★할 때 사용된다.



// Getter Setter (게터세터)
  // ★ 프라이빗 변수나 메소드를 다른 클래스로 불러오고 싶을 땐 게터로
    // get 붙은 함수 이름은 보통 멤버 변수값이나 메소드 return(제공)!!!에 사용.
  // 세터는 프라이빗 변수값을 변경할 때 사용. void!!!
    // 단, 리턴할 거 있으면 void 노놉.



// ★ 이고&& 이거나|| ★
  // 이고&&는 하나만 true
  // 이거나||는 하나만 false



// 클래스 만들 때 유의사항
  // 일단 변수 이름은 변수값 특징에 맞게 만들어야 쓰기 쉽고 알아보기 쉽다.
  // ★ 이름이 같은 변수는 this.로 뭐가 뭔지 잘 구분해줘야 한다.



// ★★★ 컬렉션(Collection)
  // 데이터를 저장하는 ★자료구조(Data structure)★
    // 순서나 집합적인 저장공간
    // 데이터의 집합, 그룹, 자료구조
    // 핵심은 데이터를 여러개 저장할 수 있는 것.
      // 배열의 한계를 극복하고 발전시킨 것.



// JCF(Java Collections Framework)
  // JCF는 컬렉션과 인터페이스를 제공한다.
    // 인터페이스 : 컬렉션을 구현하는 ★클래스★를 정의
  // ★JCF(컬렉션 & 맵 인터페이스⊃소속 인터페이스⊃구현 클래스들))★



//// 컬렉션 인터페이스들의 특징 (혼찾)

// "컬렉션" 인터페이스 특징 (not 맵)
  // 배열처럼 일렬로 저장됨

// Set 인터페이스
  // 집합적인 저장 공간
  // 순서를 유지하지 않는 데이터의 집합으로 데이터의 중복을 허용하지 않는다.
  // 구현 클래스
  (1) HashSet
    // Set계열의 대표 클래스
    // 가장빠른 임의 접근 속도
    // 순서를 예측할 수 없음
  (2) ★ TreeSet
    // 정렬방법을 지정할 수 있음
    // SortedSet을 상속한다
      // SortedSet : 정렬을 위한 Set계열의 클래스
    
// List 인터페이스
  // 순서가 있는 저장 공간
    // 순서가 있는 데이터의 집합으로 데이터의 중복을 허용한다.
  // 구현 클래스
  (1) LinkedList  ??
    // 양방향 포인터 구조  ?? 뭔뜻
      // 데이터의 삽입, 삭제가 빈번할 경우 데이터의 위치정보만 수정하면 되기에 유용  ?? 뭔뜻
    // 스택, 큐, 양방향 큐 등을 만들기 위한 용도로 쓰임  ?? 뭔뜻
  (2) Vector
    // 과거에 대용량 처리를 위해 사용함
    // 내부에서 자동으로 동기화처리가 일어나 비교적 성능이 좋지 않음
    // 무거워서 잘 쓰이지 않음
    // 동기화를 보장  ?? 동기화가 뭘 의미하지
  (3) ★★★ ArrayList  16), 27)
    // 단방향 포인터 구조
    // 각 데이터에 대한 "인덱스를 가지고 있어" 조회 기능에 성능이 뛰어남
    // 동기화를 보장하지 않음
    // Array(배열)을 확장한 것.
      // 배열은 자동으로 배열 수를 바꾸게 할 수 없음.
      // ArrayList는 자동으로 바꿔짐. 가변적.
    // 데이터 자료 분석에 사용. 앱 개발할 때 실무에서 무조건 씀.
  (4) ★ Stack
    // 스택자료구조

// Map 인터페이스
  // 키와 값으로 데이터 핸들  ?? 키가 뭐지
    // 키(Key), 값(Value)의 쌍으로 이루어진 데이터의 집합
  // 순서는 유지되지 않음
  // 키(Key)의 중복을 허용하지 않으나 값(Value)의 중복은 허용
  // ★Collection 인터페이스를 상속받고 있지 않지만★ Collection으로 분류
  // ★ Heap에 저장됨
  // 구현 클래스
  (1) Hashtable
    // "동기화를 보장"하는 Map계열의 클래스
    // HashMap보다는 느리지만 동기화 지원
    // null 불가
  (2) HashMap
    // "동기화를 보장하지 않는" Map계열의 클래스
    // 중복과 순서가 허용되지 않는다
    // null값이 올 수 있다
  (3) ★ TreeMap
    // 정렬된 순서대로 키(Key)와 값(Value)을 저장하여 검색이 빠름
    // SortedMap을 상속한다
      // SortedMap : 정렬을 위한 Map계열의 클래스



//// ★★★ ArrayList 사용하기

// 선언 방법(예시)
  // ArrayList<a> b = new ArrayList<a>();
    // a타입의 ArrayList 참조변수 b를 선언.
    // 이렇게 선언만 한 상태에서는 공간만 있고 데이터는 없는 상태.

// 활용 방법
  (1.1) b.add(c)
    // (추가) 참조변수b를 통해 ArrayList_b에 값c를 (순서대로) 저장.
    // c가 a타입이어야만 저장할 수 있음.
  (1.2) b.add(d,c)
    // (추가) 특정 위치에 저장하고 싶을 때 인덱스 번호(d)와 저장할 값(c)을 ,로 나눠 순서대로 적음.
  (2.1) b.remove(d)
    // (삭제) 인덱스 번호d에 저장되어있는 데이터를 삭제.
  (2.2) b.remove(c)
    // (삭제) 지우려는 값이 뭔지 정확히 아는 경우 값을 직접 입력해 삭제할 수 있다.
    // c는 값.
  (3) b.get(d)
    // (Get) 특정 값을 불러오고 싶을 때 사용.
    // d는 인덱스 번호
  (4) b.size()
    // (계산) (Get) 참조변수b가 가리키는 ArrayList_b에 '값이 저장된 인덱스의 총 개수'를 리턴.



// ★ Iterator Class  17)
  // ★ 루프를 도는 다른 방법
    // Iterator 뜻이 반복임(반복자).
    // for 루프랑 같은 역할.
    // 주로 읽기 전용으로 사용한다.
  // ★컬렉션의 List, Set계열의 객체가 먼저 생성되어있어야 함.★
    // Map 계열과는 같이 쓸 수 없음.(우회해서 사용할 수는 있음)
  // 활용 방법
  (1) Iterator<a> b = c.iterator();
    // ★ ArrayList타입의 변수를 Iterator 타입으로 변환.
    // ArrayList 타입의 변수c를 .iterator()하고, b가 참조하는 a타입의 Iterator 객체에 저장.
    // 타입a는 변수c가 취급하는 타입과 같아야 함. ★ (int면 int) ★
    (1.1) b.iterator()
      // (반복) 자체적으로 루프를 태워주는 메소드.
  (2) b.hasnext()
    // (조건) 변수에 다음 데이터가 있으면 true, 없으면 false를 반환.
      // while과 같이 써서 다음 값이 없을 때까지 (시작부터 끝까지) 루프 돌기 가능.
  (3) b.next() : (Get) 첫 데이터부터 다음 데이터를 반환하는 메소드
  (4) b.remove(a) : (삭제) "next()가 호출한" 데이터a를 삭제해주는 메소드.
    // a는 인덱스 번호 혹은 직접적인 데이터값
    // next()이전에 remove()를 호출할 수 없음.
  // (2), (3), (4) 예시
    // while(b.hasNext()){
       System.out.print(b.next()+", ");}
      // b가 가리키는 Iterator_b에 저장된 값들을 순서대로 전부 출력.
    // while(b.hasNext()){
       b.remove();}
      // next()가 불러냈던 데이터를 전부 삭제.



// ★★ for-each문  18)
  // 향상된 for문
  // 최근에 많이 쓰는 방법
  // 다수의 값을 갖는 변수가 먼저 선언(혹은 객체가 생성)되어있어야 함.
  // 사용 예시
    // for(String a : b){
       System.out.print( a +" ");}
      // ArrayList 타입 참조변수 b에서 데이터를 순서대로 하나씩 빼와서 String타입 변수 a에 저장하고, b에서 데이터를 다 뽑아올 때까지 a를 출력(for)하라는 뜻.
      // String a : b 는 변수 선언한 것과 마찬가지임.
  // 리스트 데이터가 몇 개인지 알 필요가 없음.
200515 금요일 수업에 쓰인 코딩

1) 3의 배수의 합 구하기
        int sum = 0;
        for(int i = 0; i <= 100; i = i + 1){
            if(i%3 == 0){
                sum = i + sum;
            }
        }
        System.out.println(sum);
=====



2) 책 134페이지 예제4 (해결~)
        int a = (int) (Math.random() * 6) + 1;
        int b = (int) (Math.random() * 6) + 1;
        while((a + b) != 5) {
            System.out.println("(" + a + " + " + b + ")");
            a = (int) (Math.random() * 6) + 1;
            b = (int) (Math.random() * 6) + 1;
        }
        System.out.println("(" + a + " + " + b + ")");



3) 135페이지 예제 6 해결~
        // Q.6 my answer
        StringBuilder star = new StringBuilder();
        for (int c = 0; c < 5; c++) {
            star.append("*");
            System.out.println(star);
=====
        }
        // Q.6 teach
        for(int i = 1; i <= 5; i++){
            for(int j = 0; j < i;j++){
                System.out.print("*");
            }
        }
=====



4) 135 페이지 예제 5 반만 해결
        // Q.5 my answer
        for (int x = 1; x <= 10; x++) {
            for (int y = 1; y <= 10; y++) {
                if (4*x + 5*y == 60) {
                    System.out.println("(" + x + "," + y + ")");
                }
                if (4*x + 5*y == 60) {
                    System.out.println("(" + x + "," + y + ")");
                }
            }
=====
출력값
(5,8) <<두개씩 출력됨.
(5,8)
(10,4)
(10,4)
=====
        // Q.5 teach
        for(int z = 0 ; z <= 10 ; z++){
            for(int y = 0 ; y <= 10 ; y++){
                if(4*z + 5*y == 60){
                    System.out.println("(" + x + "," + y + ")");
                }
            }
        }
=====
출력값 ????이상한데
=====



5) 예제(1)
바람의 속도가 다음과 같을 경우 해당되는 문자열을 출력하시오
경우는 모다 조건식이다.
1~3 : Light air
4~27 : Breeze
28~47 : Gale
48~63 : Storm
해결함 :3
        int a = (int) (Math.random() * 63) + 1;
        System.out.println("wind speed = " + a);
        System.out.println("-------");
        if(a >= 1 && a <=3) {
            System.out.println("Light air");
        }else if(a >= 4 && a <= 27) {
            System.out.println("Breeze");
        }else if(a >= 28 && a <= 47) {
            System.out.println("Gale");
        }else if(a >= 48 && a <= 63){
            System.out.println("Storm");
        }
=====
결과값
wind speed = 45  // 랜덤값
-------
Gale
=====


6) 예제(2)
a가 7인 조건식(변수)을 만들어라
짝수면 "짝수", 홀수면 "홀수"가 출력되게 만들어라.
        int a = 7;
        if(a % 2 == 0){
            System.out.println("jjacksu");
        }else{
            System.out.println("holsu");
        }
=====
holsu
=====



7) 예제(3)
    static boolean checkEmail(String adr){
        if(adr.indexOf("@") == -1){
            return false;
        }else{
            return true;
        }
    }

    static boolean checkEmail2(String adr){
        if(adr.contains("@")){
            return true;
        }else{
            return false;
        }
    }

    public static void main(String[] args) {

        System.out.println(checkEmail("abc"));
        System.out.println(checkEmail2("abcd@"));

        }

    }
=====
결과값
false
true
=====



8) 예제(4)
    static boolean checkPasswd(String passwd1, String passwd2) {
        if (passwd1.compareTo(passwd2) == 0) {
            if (passwd1.length() < 6 || passwd1.length() > 12) {
                return false;
            } else {
                return true;
            }
        } else {
            return false;
        }
    }

        public static void main (String[]args){

            String passwd = "12345";
            String passwd3 = "12346";
            System.out.println(checkPasswd(passwd,passwd3));

        }
    }
=====
결과값
false
=====



9) 예제(5)
// my answer
public class User {

    private String email;
    private String passwd;
    public String nickName;

    User(String nN) {
        nickName = nN;
    }

    void getNick() {
        System.out.println("nickName : " + nickName);
    }

    void setEmail(String adr){
        if(adr.contains("@")){
            email = adr;
            System.out.println("Success save email");
        }else{
            System.out.println("Fail save email : plz add @");
        }
    }
    void getEmail(){
        System.out.println("email : " + email);
    }

    void setPasswd(String passwd1, String passwd2) {
        if (passwd1.compareTo(passwd2) == 0) {
            if (passwd1.length() >= 6 && passwd1.length() <= 12) {
                passwd = passwd2;
                System.out.println("Success save password");
            } else {
                System.out.println("Fail save : password length error");
            }
        } else {
            System.out.println("Fail save : password not equal");
        }
    }

    void getPasswd(){
        System.out.println("passwd : " + passwd);
    }
=====main
public class MyClass {



    public static void main(String[] args) {

        User u1 = new User("iamme");

        u1.setEmail("abc@email.com");
        u1.setPasswd("abced","abced");

        System.out.println();

        u1.getNick();
        u1.getEmail();
        u1.getPasswd();

        }

    }
=====결과값
Success save email
Success save password

nickName : iamme
email : abc@email.com
passwd : abced

=====
// teach : 불린 활용
boolean setEmail(String email){
if(email.contains("@"){
this.email = email;
return true;
} else {
return false;
}
boolean setPasswd(String passwd1, String passwd2){
        if (passwd1.compareTo(passwd2) == 0) {
            if (passwd1.length() < 6 || passwd1.length() > 12) {
	     return false;
            } else {
                passwd = passwd2;
	     return true;}
        } else {return false;}
    }
// 강사님 print 함수도 만들어서 저장하셨음. 세개 다 한번에 출력되게.
나도 해보자.
u1.print();
보통 서비스들은 이런식으로 만들고 출력한댔음.
=====



10) 예제(6)
=====teach
public class MyClass {

    static int[] io(int a){
        int[] b = new int[a];
        for(int i = 0; i < b.length; i++){
            b[i] = i+1;
        }
        return b;
    }

    public static void main(String[] args) {

        int[] c = io(7);

        for(int i = 0;i < c.length; i++){
            System.out.print(c[i]+" ");
        }
        }
    }
=====
결과값
1 2 3 4 5 6 7



11) 예제(7) (내가 만든 거+손본 거)
public class MyClass {

    static int cal(int value1,int value2,String operator){
        int ret = 0; // 초기값을 정해두고 뭘 해도 이 값만 return해주는 게 깔끔해보인다.
        if(operator.compareTo("add") == 0){
            ret = value1 + value2;
        }else if(operator.compareTo("mul") == 0){
            ret = value1 * value2;
        }
        return ret ;
    }

    public static void main(String[] args) {

        int a = 2;
        int b = 4;
        String[] c = {"add","mul"};
        System.out.println("Answer : "+cal(a,b,c[1]));

        }

    }
=====결과값
Answer : 8



12) 예제(8) 책 279페이지
public class Member {

    String name;
    String id;
    String pw;
    int age;

    Member(String name,String id){
        this.name = name;
        this.id = id;
    }

    void printName(){
        System.out.println("Name : " + name);
    }
    void printId(){
        System.out.println("ID : "+id);
    }
}
=====main

public class MyClass {


    public static void main(String[] args) {

        Member user1 = new Member("Nick","nike123");
        Member user2 = new Member("Oz","wowoz");

        user1.printName();
        user1.printId();

        System.out.println();

        user2.printName();
        user2.printId();

    }
}
=====출력값
Name : Nick
ID : nike123

Name : Oz
ID : wowoz



13) 예제(9) 책 280페이지 15번
// teach
if(id.compareTo("hong") == 0 && password.compareTo("12345") == 0){
return true;
}else{
return false;
=====main
MemberService memberService = new MemberService();
if(result){
System.out.println("Log in.");
memberService.logout("hong");
}else{
SYstem.out.println("Not Correct.");

// My Answer
public class MemberService {

    static boolean logIn(String id, String pw){
        if(id.compareTo("hong") == 0){
            if(pw.compareTo("12345") == 0){
                System.out.println("Login Success");
                return true;
            }else{
                System.out.println("Wrong Password");
                return false;
            }
        }else{
            System.out.println("Wrong ID");
            return false;
        }
    }

    void logOut(String id){
        System.out.println("Logout");
    }

    void print(String a){
        System.out.println(a);
    }

}
=====main
        MemberService memId1 = new MemberService();
        MemberService memId2 = new MemberService();

        String id1 = "hong";
        String pw1 = "12345";
        memId1.print(id1);
        memId1.print(pw1);
        memId1.logIn("hong","12345");
        System.out.println("--------------");
        memId1.logOut("hong");

        System.out.println();

        String id2 = "Hong";
        String pw2 = "123456";
        memId1.print(id2);
        memId1.print(pw2);
        memId2.logIn("Hong","123456");

=====출력값
hong
12345
Login Success
--------------
Logout

Hong
123456
Wrong ID



14) 예제(10)
public class ClassTest_1 {
    private String name;
    private int salary;

    public ClassTest_1(){

    }

    ClassTest_1(String n,int s){
        name = n;
        salary = s;
    }

    public String getName(){
        return name;
    }

    public int getSalary(){
        return salary;
    }

    public void getInformation(){
        System.out.println("name : "+name+"salary : "+salary);
    }

    public void prn(){
        System.out.println("Super Class");
    }
}
=====
package com.tenisme.libjava;

public class ClassTest_2 extends ClassTest_1 {

    String department;

    ClassTest_2(String name,int salary, String department){
        super(name,salary);
        this.department = department;
    }

    @Override
    public void getInformation() {
        String name = super.getName();
        int salary = super.getSalary();
        System.out.println("name : "+name+" salary : "+salary+" dep : "+department);
    }
// 이것도 가능.
// super.getInformation(); System.out.println("dep : "+department);
// or System.out.println("name : "+super.getName()+" salary : "+super.getSalary()+" dep : "+department);
}
=====main
    public static void main(String[] args) {

        ClassTest_2 ct1 = new ClassTest_2("name",1000000,"Edu");
            ct1.getInformation();

    }
}
=====결과값
name : name salary : 1000000 dep : Edu



15) 클래스 이렇게 쓰면 안된다.
    int x = 12;
    public void method(int x){
        x += x;
        System.out.println(x);
=====main
        ClassTest_2 t = new ClassTest_2();
        t.method(5);
=====결과값
10



16) 어레이리스트 예시
        ArrayList<String> list = new ArrayList<>();
        System.out.println(list.size());

        list.add("400");
        list.add("Java");
        list.add("ABC");
        // list : ["400","Java","ABC"]
        System.out.println(list.size());

        System.out.println();

        list.add(1,"Python");
        // list : ["400","Python","Java","ABC"]
        for(int i = 0;i < list.size();i++){
            System.out.println(list.get(i));
        }

        System.out.println();

        list.remove(0);
        for(int i = 0;i < list.size();i++){
            System.out.println(list.get(i));
        }

        System.out.println();

        list.remove("ABC");
        for(int i = 0;i < list.size();i++){
            System.out.println(list.get(i));
        }

        list.add("Hello");
        list.add("Bye");
        list.add("Welcome~");

        System.out.println();

        // list : ["Python","Java","Hello","Bye","Welcome~"...]
        Iterator<String> i = list.iterator();  // 17)
        while(i.hasNext()){
            System.out.println(i.next());
        }
=====결과값
0
3

400
Python
Java
ABC

Python
Java
ABC

Python
Java

Python
Java
Hello
Bye
Welcome~



18) for-each문 (향상된 for문)
=====main
        ArrayList<String> list = new ArrayList<String>();
        list.add("a");
        list.add("b");
        list.add("c");
        list.add("d");
        list.add("e");

        for(String value : list){
            System.out.print(value+" ");
        }
=====결과값
a b c d e 
200518 월요일 수업 메모 정리



// ★★★ 터미널 명령어 그냥 다 여기에 정리함. ★★★



// HashMap  1)~3)
  // 특징
    // 찾기 쉬운 "키"값(왼쪽)으로 저장할 수 있다
    // 해시맵은 순서없이 돌아간다
      // 어레이리스트는 일렬로 쭉 저장하는 것. (순서가 있음)
        // 중복된 값도 각각의 인덱스에 저장해 추가할 수 있음.
  // 해시맵 객체 생성시 변수 타입 두개를 저장.
  예시) HashMap<String,Integer> hash = new HashMap<String,Integer>();
    // key : String 위치에 있는 것
      // 같은 "키값"을 저장하면 기존 값이 덮어씌워짐. ★
        // 키값은 중복을 허용하지 않는다. ★
    // value : Integer 위치에 있는 것
    // String타입 값은 Integer타입 값이다라고하는 역할을 저장함.
      // <>에는 클래스 타입만 추가 가능
        // int는 Integer, float은 Float, double은 Double로 변환해서 적어야 함.
  // hash.put(a,b)
    // b값을 a값으로 저장하는 데이터 추가
    // ArrayList에서 .add의 역할과 같음
  // hash.get(a) : 왼쪽 값 a를 적으면 오른쪽 값을 리턴.
  // 키값만, 밸류만 분할출력하기 : 오브젝트[]  1)



// 캐스팅(타입 변환)



// 향상된 for문도 value 좌측에는 해당 원시형을 가지는 클래스 이름을 적어야 함.★



// OS(오퍼레이팅 시스템)
  // 유닉스, 리눅스, 윈도우 등
    // 컴퓨터의 하드웨어를 관리하는 시스템.
    // 소프트웨어와 하드웨어 사이에서 컴퓨터를 관리하는 프로그램.
    // ★ 서버 만들려면 오에스를 설치해야 함.



// CentOS(센트OS)
  // 리눅스 기반 OS
  // 우분투도 서버로 쓰는데 센트를 더 많이 씀. 아마존이 미는 게 센트.
  // 수업에서는 CentOS를 사용하는 서버를 만듦.
    // 여기에 DBMS(MariaDB)도 설치했음.



// 안드로이드 스튜디오 구조
  // 앱은 구동시 무조건 네트워크 통신을 함.
  // .xml
    // 이 파일과 자바 파일로 안드로이드 앱을 만듦.
    // 여기서 작업할 거임.
  // ConstraintLayout



// 메인 액티비티 파일(레이아웃 폴더)
  // 클래스와 매칭되는 화면
  // 화면을 하나 만들 수록 xml 파일 개수가 추가됨



// 액티비티 메인(위에랑 다름)
  // 레이아웃에 있는 화면 버튼 텍스트 등을 설정하는 곳
  // <TextView에서 텍스트 고쳐보기
  // <Button 만들어보기
    // 버튼을 누르면 뭘 나오게 할지 작업하는 건 자바에서 코딩.
    // 동작(액션)은 자바에서 설정 한다.



// SDK 업데이트
  // ~플랫폼은 개발에 필요
    // 어떤 버전으로 개발할 건지 선택(지금은 Q)
  // ~툴에서는 업데이트 체크
  // 우측에 업데이트 떠있으면 업뎃해주면 됨.
    // 이하 꼭 업뎃해야 되는 것들
    // 첫번째꺼
    // CMake
    // 안드에뮬레이터
    // 구글플레이서비스



// 안드로이드 매니페스트
  // 하단 머지드 메니페스트 (왼오 다 볼 수 있음)
  // 앱 런처 아이콘 세팅
  // 앱 테마
  // 실행할 때 어떤 화면을 가장 먼저 띄워줄 것인지를 (액티비티 코드쪽에) 설정
  // 어떤 기능을 사용할지에 대해 권한 설정 가능



// 구글 개발자 등록
  // developer.android.com
  // 등록수수료 25달러 결제. 평생 한 번.



// 리눅스
  // 기본 지식이 필요함.
  // 보통 서버는 리눅스 서버랑 안드로이드 서버랑 섞어서 씀.



//// 버추얼 박스에 CentOS설치하기

// CentOS iso 다운받기
  1. 구글에 CentOS 검색 >> Download CentOS 링크 클릭
  2. CentOS Linux DVD ISO 버튼 클릭
  3. 상단 녹색 박스 아래에 있는 몇가지 중 하나를 클릭해 다운로드

// 버추얼 박스에 센트OS 생성
  1. "새로만들기" 클릭
  2. 이름에 "CentOS"라고 치면 자동으로 종류와 버전이 바뀜 >> 다음
  3. 메모리 - 2048MB >> 다음
  4. "지금 새 가상 하드디스크 만들기" >> 만들기
  5. '하드디스크 파일 종류'에서 "VDI" 선택 >> 다음
  6. "동적 할당" 선택 >> 다음
  7. '파일 위치 및 크기' 용량에 100GB 입력 >> 만들기

// 가상머신 기본 설정 :: 버추얼박스
  1. 우측 메뉴 중 네트워크 >> NAT(기본설정) 선택

// CentOS설치를 위해 ISO디스크 삽입하기
  1. OS생성 후 좌측 가상머신 리스트에서 CentOS 클릭 >> "설정" 클릭
  2. 우측 메뉴 중 저장소 >> 컨트롤러 : IDE 항목의 '비어있음' 클릭
  3. 우측 작은 디스크 버튼 클릭 >> Choose/Create a Virtual ~ 클릭
  4. "추가" >> 다운받은 CentOS iso 파일 선택 >> "선택" 클릭 >> "확인"

// 가상머신에서 Cent OS 설치
  1. 좌측 가상머신 리스트에서 CentOS 선택 후 "시작" 버튼 클릭
  2. Install CentOS Linux 8(첫 번째 항목) 선택(엔터) >> 실행창 뜸
  3. 언어 선택 >> Continue
  4. "네트워크 및 호스트 이름" >> 우측의 "끔"을 "켬"으로 전환 >> 완료
  5. "시간 및 날짜" >> 아시아 >> 서울 선택 >> 완료
    // "키보드", "언어 지원"은 임의로 더 추가할 수 있음
  6. "설치 목적지" 클릭 >> "완료" 클릭
  7. 우측 하단에 "설치 시작" 버튼이 활성화되면 클릭
  8. 설치중 "Root 암호"와 "User Creation" 생성
  9. 설치가 완료되고 우측 하단에 "재부팅"버튼이 활성화되면 클릭
  10. 재부팅 후 가상머신 전원off
  11. 다시 해당 가상기기의 설정으로 진입 >> 저장소 >> ISO파일 꺼내기
    // 작은 디스크 버튼 클릭 >> "가상 드라이브에서 디스크 꺼내기"를 누르면 됨.
    // 디스크 꺼내기 안하면 이 가상머신 켤 때마다 설치화면만 계속 뜸.

// 설치 완료 후 첫 실행시
  1. 냅두면 알아서 LICENSING 페이지로 넘어옴.
  2. License Information 클릭 >> 좌측 하단의 체크박스 클릭 >> "완료" 클릭
    // 약관 동의 버튼임.
  3. "설정 완료" 클릭 >> 로그인(일반 계정)
  4. 언어 선택 >> 다음 >> 쭉쭉 다음 클릭한 뒤 "CentOS Linux" 시작 클릭
    // 이후에 뜨는 "시작하기" 창은 그냥 튜토리얼. x버튼을 눌러서 꺼주면 된다.



//// 원격 서버 접속하기 :: Windows에서

// PuTTY(퍼티) 다운로드 & 설치하기
  // PuTTY : 다른 서버에 원격접속할 수 있도록 도와주는 "윈도우 전용" 툴.
    // 이걸 통해서 리눅스 서버에 원격으로 접속해 설정 및 개발이 가능함.
    // 중복 실행, 다계정 접속이 가능.
      // 똑같은 일반 계정으로도 중복 접속이 가능.
      // 서버 작업을 여럿이 같이 할 수 있음.
  1. 구글에 PuTTY 검색
  2. Download PuTTY ~ 링크 클릭
  3. 최상단의 Download PuTTY에서 You can download PuTTY here.의 here. 클릭
  4. Package files - MSI (‘Windows Installer’) - 64-bit: 우측에 있는 ~.msi 링크 클릭
  5. 다운받은 파일을 실행해서 설치 진행(쭉 next 누르면 됨)

// CentOS에서 ssh(sshd) 설치하기 :: 서버 설치 & 설정
  // SSH 뜻은 검색해서 이 파일에 따로 메모해놓음.
  1. 터미널 열기
  2. su 치고 엔터 >> root 암호 입력 후 엔터
    // 최상위 관리자, 슈퍼 관리자, 루트 계정, 슈퍼 유저(줄여서 su)로 로그인함.
      // "어디에든" 접근 가능하고, 뭐든 다 읽거나 변경할 수 있는 권한을 가짐.
        // 시스템을 관리하는 폴더(etc 등)에 접근해 정보 등을 변경할 수 있음.
  3. OpenSSH 설치
    3-1. yum install openssh-server openssh-clients openssh-askpass 입력 후 엔터
    3-2. 뭐가 나오든 y 누르고 전부 설치.
  4. 설정 파일 수정 :: Port 22 부분 주석 해제하기
    4-1. vi /etc/ssh/sshd_config 입력 후 엔터
    4-2. 방향키를 눌러서 내려가 "# Port22"에 커서를 놓기
    4-3. Delete키를 눌러 #없애기
    4-4. Esc키 누르고 :q! 를 입력한 다음 엔터를 쳐서 빠져나오기.
  5. 설치 상태와 동작 상태 확인하기
    (1) yum list installed | grep ssh
    // ssh가 포함된 소프트웨어를 표시해주는 코드.
    // 검색한 단어(ssh)가 진하게 표시되는 파일들이 주루룩 나오면 설치 성공.
    (2) systemctl status sshd
    // sshd 동작상태 확인 코드
    // active (running)이 보이면 sshd가 '실행되고 있는 중'이라는 뜻.
      // 원격 접속이 가능해졌다는 뜻.
    // q를 눌러 빠져나올 수 있음.
    // systemctl에서 ctl은 컨트롤의 약자.
    (3) ps -ef | grep sshd
    // sshd 동작 상태 확인
    // sshd가 진하게 표시된 상태로 나오면 OK(라고 알고있음)

// CentOS(리눅스)에서 ip주소 알아내기
  1. 터미널 실행
    1-1. CentOS 가상머신 실행
    1-2. 메인화면에서 좌측 상단의 "현재 활동" 클릭
    1-3. 좌측 하단의 [>_ ] 아이콘을 클릭해서 터미널 실행.
      // 검색창에 terminal을 검색해서 실행해도 됨.
  2. ifconfig -a 치고 엔터
  3. enp0 s3: 와 lo: 에 있는 inet을 기록(복붙 등)
    // 예시) enp0 s3: 의 inet 10.0.2.15, lo: 의 inet 127.0.0.1
  4. 문제 해결 :: 위 명령을 실행했는데 IP주소가 안 보일 때
    // 보여야 다음 단계가 진행이 가능함.
    // 선행 : 인터넷(네트워크) 연결이 되어있는지부터 체크
      // 이하 연결이 되어있는데도 IP주소가 안 보일 때 명령어(아마도)
    // 아래의 두 명령어는 하나의 과정이 아니라 따로따로 실행되는 것임.
    1) system-config-network-tui
    2) systemctl restart network-online.target

// 서버OS 포트포워딩하기 :: in 버추얼박스
  1. 서버OS(CensOS) 선택 >> 설정 >> 네트워크
  2. 고급 >> "포트포워딩" 버튼 클릭
  3. 우측 상단의 조그만 버튼 클릭 후 양식 입력
    // 호스트 IP : 127.0.0.1 / 호스트 포트 : 22
       게스트 IP : 10.0.2.15 / 게스트 포트 : 22
  4. "확인" 버튼 누르면서 설정화면 전부 빠져나오기

// PuTTY에서 CentOS 서버에 접속하기
  // 주의사항
    // 서버(여기서는 CentOS)에 ssh 설치가 선행되어야 함.
    // 서버가 꺼져있는 상태로는 접속이 불가.
    // 서버와 PuTTY를 실행하는 두 곳 중 한 군데 어디라도 네트워크 연결이 안 되어있으면 접속이 불가.
  1. "PuTTY" 실행
  2. "Host Name (or IP address)"에 lo: 의 inet 주소(127.0.0.1)를 입력.
  3. Connection type은 "SSH" 선택.
  4. 하단의 "Open" 클릭.
  5. 이 호스트 신뢰할 수 있냐 어쩌고 묻는 영문 메세지창 뜨는데 Yes.
  6. 실행창에 로그인 화면(login as: )이 뜨면 원격 접속 성공.
  7. 유저 아이디와 패스워드를 쳐서 로그인.
  // 중간에 둘 중에 하나의 기기나 네트워크가 꺼지면 연결 해제됨(편집불가)



// [사용자ID@ ~]  ::  사용자의 홈 디렉토리
  // [tenisme@Localhost ~]  ::  /home/tenisme
    // ★ tenisme(유저 이름) 디렉토리의 기본 접근 권한 : drwx------ (700)
  // [root@Localhost ~]  ::  /root



//// ★★★ PuTTY 터미널(리눅스) 서버 기본 명령어/사용키 설명

// 다른 정리와 중복내용있음
// 외워야됨. 시험에 나옴.

// poweroff
  // 전원 끄기(서버 종료)

// shutdown (now)
  // 전원 끄기(서버 종료) (지금 당장)

// reboot
  // 재부팅

// man 명령어
  // 메뉴얼의 약자. 헬프페이지를 띄워줌.
  // man 뒤에 알고 싶은 명령어를 적으면 그것에 대해서만 알려줌.
  // 메뉴얼 창에서 q 누르면 메뉴얼 종료

// su
  // 슈퍼 계정으로 로그인할 수 있도록 도와주는 명령어
    // 슈퍼(루트) 계정은 일반유저 및 시스템의 모든 폴더와 파일에 접근 가능한 루트 권한을 가진다.
  // su >> 엔터 >> 루트 패스워드를 입력
  // su : 슈퍼 유저의 약자. 슈퍼 관리자, 최상위 관리자, root(루트)
  // 슈퍼 계정으로 볼일 다 봤으면 바로바로 일반으로 빠져나와주는 것 잊지 말기.
  // ★ su [유저 이름]  ::  [유저 이름] 계정에 로그인을 시도할 수 있다
    // 다른 유저로 먼저 로그인했다가 계정을 변경해 사용하고 싶을 때 쓴다.
    // 접속하려는 계정에 암호가 존재하면 당연히 입력해야함.

// sudo 명령어  ::  슈퍼유저로 행동하라
  // 루트 권한으로 써야하는 명령어를 일반 계정에서도 쓸 수 있게 해주는 명령어.
  // 일반 유저 이름 등이 /etc/sudoers에 등록되어있어야 사용 가능.

// clear
  // 접속 초기 화면처럼 상단 텍스트들을 깨끗하게 치워줌.
  // 이전 내용들을 다시 보려면 마우스 스크롤을 올리면 됨.

// exit
  // 터미널 종료. 슈퍼 계정으로 로그인한 경우 일반 계정으로 전환됨.

// /(슬래시)
  // 경로를 구분하고 표시할 때 쓴다.
  // 경로의 시작에 적는 맨 첫 슬래시는 최상위 디렉토리를 의미한다.
    // ★ 경로의 시작에 적는 / 는 무조건 최상위 경로를 나타낸다.
      // 시작부터 / 를 적을 땐 최상위 경로부터 도달하고자 하는 위치까지 모든 경로를 다 적어야 한다.
    // ★ 현재 위치 아래에 있는 디렉토리부터 경로를 적을 때에는 /부터 시작하면 안된다
      // "/"를 최상위로 인식해 없는 디렉토리라고 나올 수 있다
    // 윈도우즈에서는 C:\ (C드라이브)와 같은 것
    예시) /home/tenisme
    // 최상위 디렉토리 안에 속한 home 디렉토리 안에 속한 tenisme 디렉토리

// ★★★ cd /경로/
  // 체인지 디렉토리. 현재 위치에서 다른 디렉토리(폴더)로 이동.
  // "cd " 뒤에 경로를 입력해 입력한 경로로 이동함.
    예시) cd /home/tenisme
    // 현 위치에서 /home/tenisme 폴더로 이동
    // 맨 앞의 /는 적어도 되고 안 적어도 되지만 쓰는 것을 적극 추천.
      // 파일을 보거나 수정하려고 할 때(vi) 맨 앞에 /를 안 적으면 기존 파일이 열리지 않고 새로운 파일이 만들어지더라.
  // cd ..  ::  현재 위치에서 한 단계 상위 폴더로 이동. ../로 써도 무관함.
    // cd . or cd ./ 는 자신의 폴더를 의미
  // cd ~  ::  ~는 /home/tenisme(유저ID) 폴더를 의미.
    // root 계정에서는 /root
    // 기본적으로 일반 계정이 다른 일반 계정 + root에 접근하는 권한은 막혀있다.
  // cd /  ::  최상위(/) 폴더로 이동
    // ★ /(최상위) 폴더는 root폴더가 아님 리얼 핵주의
    // /(최상위) 폴더에서 cd .. 하면 현 위치에서 아무데도 이동하지 않음.

// pwd
  // 현재 어느 디렉토리 안에 있는지를 경로의 시작부터 쭉 표시해줌
  // 현재 경로(위치) 표시

// ↑,↓(방향키 위, 아래)
  // ↑ :: 맨 마지막에 쓴 것부터 순서대로 명령어 호출
  // ↓ :: ↑키 사용하다가 다시 이 다음에 썼던 명령어로 돌아가고 싶을 때

// 텍스트 복사 후 우클릭
  // 텍스트를 붙여넣어줌. 윈도우에서 Ctrl+V의 역할을 함.

// ls(엘에스) /경로
  // 현재 위치한 디렉토리 안에 있는 디렉토리들과 파일들을 표시.
  // 다른 디렉토리 안의 내용을 보고 싶으면, ls 뒤에 보고싶은 디렉토리의 경로를 적으면 볼 수 있음.
  // ls -a : 숨김파일까지 다 보여줌
  // ls -il : 각 파일의 아이디(아이노드) 확인하기
  // 현재 계정에 대해 r 권한이 부여되어있지 않으면 퍼미션 디나이드 뜸.
    // 현재 계정에 x권한이 없고 r권한만 있을 때는 목록을 불러들이긴 하지만 각 파일마다 허가 거부 표시가 붙어서 뜸.
  // 아무 것도 없으면 아무 것도 안 뜸.

// ll(엘엘) /경로
  // 현재 위치한 디렉토리 안에 있는 디렉토리들과 파일들의 정보를 상세 표시.
  // 다른 디렉토리 안의 내용을 보고 싶으면, ll 뒤에 보고싶은 디렉토리의 경로를 적으면 볼 수 있음.
  // ll -a : 숨김파일까지 다 상세하게 보여줌
  // ll -il : 각 파일의 아이디(아이노드) 확인하기
  // 현재 계정에 대해 r 권한이 부여되어있지 않으면 퍼미션 디나이드 뜸.
    // 현재 계정에 x권한이 없고 r권한만 있을 때는 목록을 불러들이긴 하지만 각 파일마다 허가 거부 표시가 붙어서 뜸.
  // 아무 것도 없으면 아무 것도 안 뜸.

// vi /경로/파일명
  // 해당 경로의 파일을 열어서 보여주는(view) 명령어
    // 실행하면 파일을 보거나 편집할 수 있는 에디터가 열림.
    // 파일 권한에서 rwx 중에 r(read)가 없으면 퍼미션 디나이드(허가 거부) 뜸.
    // x(실행) 권한과는 무관함.
  // 해당 파일명이 없으면 그 파일명으로 새로운 파일을 만들어 빈 화면을 보여줌.
    // 이 경우 편집된 내용 없이 그냥 나가거나 저장하지 않고 강제로 나가거나 하면 파일은 생성되지 않음.
  // 보려고 하는 파일이 현재 디렉토리 안에 있으면 경로를 적지 않고 파일명만 적어서 바로 들어갈 수 있음.

// touch /경로/파일명
  // 에디터 창에 들어가지 않고 파일명.확장자 파일을 바로 하나 만들어주는(저장시켜주는) 명령어.
  // 파일 생성 명령이 잘 수행됐는지 ls나 ll로 확인해보자.
  // 서로 다른 계정은 서로의 디렉토리에서 touch로 파일을 생성할 수 없음. 루트 제외.

// cp /경로/파일명 /경로/파일명  ::  복붙
  // 앞에 쓴 "/경로/파일명"을 뒤에 쓴 "/경로/파일명"으로 복붙한다.
  // 붙여넣을 경로가 다르면 파일 이름은 같아도 된다.
    // 같은 경로는 같은 이름 안됨.
  // cp는 copy의 약자.
  // 서로 다른 계정은 서로의 파일(디렉토리)에 복사 권한이 없음. 루트 제외.

// mv /경로/파일명 /경로  ::  옮기기(이동)
  // 앞에 쓴 "/경로/파일명"을 뒤에 쓴 "/경로"로 옮긴다.
  예시) mv test1.txt ..
    // 현재 디렉토리의 test1.txt 파일을 현재 디렉토리의 한 단계 상위 폴더로 옮긴다.
  // mv는 move의 약자
  // ★ 공통된 파일 이름을 묶어서 옮기기
    예시) mv my* /경로
      // 현재 디렉토리에 이름이 my로 시작하는 모든 파일들을 /경로로 이동시킨다.
  // 서로 다른 계정은 서로의 파일(디렉토리)에 이동 권한이 없음. 루트 제외.

// rm /경로/파일명  ::  파일 삭제
  // 해당 경로에 있는 "파일명"을 삭제함.
  // 리눅스는 휴지통도 없고 복구도 안되므로 삭제는 신중하게 해야 함.
  // rm은 remove의 약자.
  // rm -r /경로/디렉토리명  ::  디렉토리 삭제
    // 'rm -rf /경로/디렉토리명'도 가능.
      // -rf : 안에있는 파일도 다 지워라
  // 서로 다른 계정은 서로의 파일(디렉토리)에 삭제 권한이 없음. 루트 제외.

// 에디터(vi) 편집키
  // i, a, o키 : 편집(인서트)
    // 편집창에 들어와서 위 세가지 키 중 하나를 누르면 편집창 하단에 [INSERT]가 뜨면서 해당 파일의 편집이 가능해진다.
  // Delete키 & x키 & 백스페이스 : 편집(문자 삭제)
    // 인서트 키를 누르기 전 
      // Delete키나 "x키"를 눌러 문자를 삭제할 수 있다.
      // 백스페이스는 그냥 왼쪽으로 칸 이동만 함.
    // 인서트 키를 누른 다음
      // Delete키와 백스페이스 키로 문자를 삭제할 수 있음
      // x키는 그냥 x로 "입력"된다.
  // dd : 인서트 들어가기 전에 실행하면 라인별로 지워줌

// echo "Hello"
  // 그냥 Hello라는 문자를 바로 밑에 찍어줌.

// find /경로 -name "찾는문자"  ::  파일 찾기(서치)
  예시) find / -name "*.txt"
    // 전체 위치(/)에서 뒤의 문자가 .txt로 끝나는 파일들(*.txt)을 모두 찾아라.
  // 접근 불가한 정보는 퍼미션 디나이드가 뜬다.

// Esc  ::  편집창(인서트 상태) 빠져나오기
  // Esc + :w  <-- 저장하기
    // 그냥 저장만 됨. 그리고 저장이 완료됐다는 메시지만 하단에 뜸.
  // Esc + :wq  <-- 저장함과 동시에 빠져나가기
  // Esc + :q  <-- 빠져나가기
  // Esc + :q!  <-- 긴급 빠져나가기(강종) : 수정 내용을 저장하지 않고 빠져나간다
    // Esc :q와 Esc :q!는 에디터 밖에서도 명령어로 쓸 수 있음. 기능도 같음.

// Ctrl+C  ::  복사하기 아님 핵주의
  // 어디서든 특정 상황을 강제로 빠져나와 명령창으로 돌아올 수 있는 단축키.
    // 줄여서 작업 빠져나오기, 강종.
    // 터미널 종료는 아님.
  // 예시 : 프로그램 설치 중 실행 >> 프로그램 설치 취소 후 명령창으로 복귀

// q
  // 작업이 끝나고 end표시 뒤에 뭣도 안 쳐질 때 누르면 벗어날 수 있음.

// tab 키
  // 디렉토리/파일명 자동 완성 기능

// cat /경로/파일명
  // 특정 파일(디렉토리 ㄴㄴ)의 내용을 에디터(vi)에 들어가지 않고 바로 아래에 출력해주는 명령어.
  // "cat 파일경로"의 형식으로 쓴다.

// mkdir /경로/디렉토리이름  ::  디렉토리 만들기
  // "디렉토리 이름"의 디렉토리를 만든다.

// useradd 유저이름  ::  일반 유저 추가(새 계정 만들기)
  // root 권한에서"만" "직접적으로" 생성 가능. sudo 안됨.
  // 유저가 잘 생성되었는지 확인하기  ::  ll /home
  // passwd 유저이름  ::  "유저이름"의 패스워드 설정

// del 유저이름  :: 유저(계정) 지우기
  // 이것도 당연히 루트 권한에서만.



// 절대 경로와 상대 경로
  // 절대 경로 : 자신이 원하는 경로를 "최상위 디렉토리부터" 모두 적은 것.
    // 위치가 고정되어있는 고유한 경로 ex) 대한민국 서울시 관악구 ~
  // 상대 경로 : 특정 경로를 기준으로 다른 경로를 표시하는 개념.
    // 현재 위치를 기준으로 한 파일/폴더 경로



// ★★★ ln [option] /경로/파일이름 /경로/링크이름  ::  링크 만들기
  // 링크 파일 : 윈도우즈의 바로가기 파일이라고 생각하면 됨.
  // 링크 파일의 종류 : 하드링크, 소프트링크, 심볼릭링크
  예시1) ln a b
    // 현재 디렉토리의 파일a로 연결되는 "하드 링크" 파일b를 현재 디렉토리에 만들어라.
      // ★ 하드 링크 파일 확장자는 원본 파일 a와 "같은 확장자를 적어줘야 함" 핵주의.
        // 하드 링크 뒤에 확장자 안 적으니까 그냥 새로운 파일이 만들어지고 원본과 연결도 안 됨.
      // ★ 하드 링크의 권한은 원본 파일의 권한과 같다. 파일 유형(-,d,l)도 똑같이 표시된다.
        // 원본 파일의 권한 변경시 하드 링크의 권한도 똑같이 변경된다.
  예시2) ln -s a b
    // 현재 디렉토리의 파일a로 연결되는 "소프트 링크" 파일b를 현재 디렉토리에 만들어라.
      // 소프트링크는 원본 파일a와 같은 확장자 쓰든 안 쓰든 전혀 상관없음. 그저 이름일 뿐임.
      // ★ 소프트 링크의 권한은 원본과 상관없이 777로 되어있다. + 파일 유형에 l(엘)이 붙음
        // 단 777과는 별개로, 연결된 파일에 현재 계정의 접근 권한이 없으면 퍼미션 디나이드 뜸.
  // ls -il  ::  각 파일(링크)의 아이디(아이노드) 확인하기
  // 각 링크의 아이노드 체크로 확인해볼 수 있는 사실들
    // 원본 파일(베이스 파일)과 하드 링크는 아이디가 같다. 직접적으로 같은 곳을 가리키는 방식이다.
    // 소프트 파일은 원본 파일과 다른 아이디로 만들어지지만, 실행시 원본 파일로 이어진다.



//// 접근 권한 제어  ::  퍼미션(permission)을 주다

// 파일 정보 설명
  // ll(엘엘)에서 볼 수 있는 파일의 상세 정보에 대한 설명
  // 파일 정보 설명 순서
    1) 파일 유형
      // 맨 왼쪽에 표시된 1자리수 알파벳은 해당 파일의 유형이 무엇인지 보여줌.
      // -는 파일, d는 디렉토리, l는 (소프트)링크를 의미
    2) 파일 허가권
      // 파일 유형 뒤에 붙은 9자리 알파벳은 유저별 접근 권한을 rwx로 상세하게 보여줌.
      // 앞에서부터 각 3자리씩 "소유자", "소속 그룹", "나머지"의 접근 권한을 의미함.
    예시) 1)과 2)의 예시 : drwxr-xr-x, -rwx--xw-x 등
    3) 링크 수
    4) 파일 "소유자(Owner) 이름" : 파일 허가권 앞 3자리
    5) 파일을 "소유한 그룹(Group) 이름" : 파일 허가권 중간 3자리
    6) 파일 크기
    7) 마지막 변경 날짜 & 시간
    8) 파일 이름

// ★ 파일 허가권(접근 권한) 상세 설명
  // rwx  ::  파일, 디렉토리, 링크 등의 권한을 표시해주는 기호.
    // r  ::  읽기(read) 권한이 부여됨. 4
      // 디렉토리에 읽기 권한이 없을 경우 폴더 진입부터 불가능.
    // w  ::  쓰기(편집, write) 권한이 부여됨. 2
    // x  ::  실행(execute) 권한이 부여됨. 1
    // -  ::  맨 앞 자리를 제외한 - 표시는 접근 권한이 없음을 의미.

// ★★★ chmod 000 /경로/파일명  ::  모드 변환, 권한 체인지, 체인지 모드, 퍼미션을 주다
  // 특정 파일(디렉토리)의 rwx(접근 권한)을 변경해주는 명령어.
  // 권한을 바꿀 파일의 "소유자" 계정만 그 파일의 권한 변경이 가능하다.
    // root 계정은 위의 룰과 상관없이 모든 계정의 접근 권한을 변경할 수 있음.
  // chmod : 체인지 모드(모드 변환)의 약자
  // chmod 뒤에 오는 숫자 세자리(000)는 각각 유저별 접근 권한 3종류를 의미함.
    // 순서대로 "소유자" "소속 그룹" "나머지"
    // 3가지의 각 권한마다 0부터 7까지 8가지의 숫자를 부여해 권한 컨트롤이 가능함.
      // r은 4(2^2), w는 2(2^1), x는 1(2^0), -는 0으로 계산, 부여할 권한만큼의 숫자를 더해 각 권한에 표시한다.
      예시) chmod 777 test.txt  <-- -rwxrwxrwx  <-- -(파일)rwx(7)rwx(7)rwx(7)
      // 소유자, 소속 그룹, 나머지 모두에게 읽기, 쓰기, 실행 권한을 부여하도록 변경
  // ★ 같은 속성의 권한을 모든 영역에 한번에 줄 때/없앨 때 팁
    예시) chmod +rx my_script
    // 가운데에 숫자가 아닌 +rwx, -rwx 등을 적어서 권한을 추가하거나 뺄 수 있다.
    // 예시에서는 my_script 파일의 유저, 그룹, 기타에 전부 r과 x권한을 준 것.



// 서버 시간 설정(셋팅)해주는 명령어
  // ln -sf /usr/share/zoneinfo/Asia/Seoul /etc/localtime
    // 아이엔 아니고 엘엔임.
  // ls -al /etc/localtime
    // 이 명령어는 뭔지 몰것음. 같이 메모되어있었음.



// gedit /경로/파일명  ::  터미널로 텍스트 편집기 띄우기
  // gedit 명령어는 본 서버 컴퓨터에서만 실행 가능. (원격 접속으로는 실행 안됨)
  // vi 명령어로 터미널 안에서 내용을 편집하는 에디터와 달리, 별도의 프로그램(텍스트 편집기)를 띄워 거기에서 파일을 실행시켜준다.
  // gedit에서 g는 그래픽의 약자. 그래픽으로 보여달라는 뜻.



// ★ 파일 유형별 컬러 표시
  // ls나 ll을 썼을 때 나오는 리스트에서 볼 수 있는 컬러 표시의 의미
  // 디폴트 컬러는 일반 파일을 의미함.
  // 파란색은 디렉토리를 의미함.
  // 하늘색은 링크를 의미함.
  // 녹색 글씨는 "실행 가능한(rwx의 x)" 파일을 의미함.
  // 빨간 글씨랑 빨간 마크 쳐져있는 건 뭔지 모르겠음. 뭔가 건들면 안 될 거 같음.



// 클라우드 서비스
  // 클라우드 서비스를 제공하는 이유 (요약)
    // 서버(기기) 남는 거 좀 있는데 쓸 수 있게 빌려줄겡.
      // 쓴 시간만큼 돈냉.
  // 클라우드 서비스로 로그인 등을 구현함.
  // 제일 많이 쓰이는 것 : 아마존 AWS, 애저, GCP(구글)
  // 서버를 직접 구축하지 않고 클라우드 서비스를 사용하는 이유
    1. 서버를 회사가 자체적으로 가지고 있으면 비용이 많이 들어서
    2. 서버 처리는 한계가 있음.
      // 서버 접속 폭발시켜서 먹통되는 게 디도스.
    3. 굳이 힘들게 서버 깔고 그러지 않아도 쉽고 빠르게 서버 생성 및 활용 가능.
    4. 미드웨어, 웹서버, 데이터(DB?) 저장 서버 등을 전부 지원함(아마도)
    3. 기타 등등



// 프로토콜 뜻 (검색 정보)
  // 디바이스 간 데이터를 교환하기 위한 통신 규약
  // 컴퓨터 컴퓨터와 컴퓨터 사이, 또는 한 장치와 다른 장치 사이에서 데이터를 원활히 주고받기 위하여 약속한 여러 가지 규약(規約). 이 규약에는 신호 송신의 순서, 데이터의 표현법, 오류 검출법 따위가 있다. ≒통신 규약.



// SSH  ::  Secure SHELL (검색 정보)
  // telnet의 보안 버전을 의미한다. 실무에서는 보안의 문제로 이 SSH 프로토콜을 사용하는 경우가 많다.
    // Telnet은 서버와 클라이언트 사이에 오가는 데이터를 암호화하지 않는다는 심각한 보안 결함이 있습니다.
    // 그래서 실제 서비스를 하는 서버에 접속할 때는 SSH를 사용해야 합니다.
  // ssh  ::  SSH 클라이언트 실행 파일
  // sshd  ::  SSH 서버의 실행 파일
    // ~d가 붙은 건 데몬이라는 뜻
      // ★ 데몬은 백그라운드 프로세스, 즉 뒤에서 상시에 실행되고 있는 프로그램.
      // 계속 작동하고 있어야 클라이언트가 접속을 요청을 했을 때 알아챌 수 있다
  // SSH로 디바이스간 원격 접속하는 원리
    // "클라이언트가 설치된 컴퓨터"에서 "서버가 설치된 컴퓨터"로 원격 접속하는 것
  // SSH는 세 개의 프로토콜로 이루어져 있다.
    1. SSH 사용자 인증 프로토콜 : 클라이언트 사용자를 서버에 인증
    2. SSH 연결 프로토콜 : 암호화된 터널을 여러 개의 논리적 채널로 다중화
    3. SSH 전송 프로토콜 : 서버 인증,기밀성,무결성을 제공해 파일을 전송함



// 유닉스 서버
  // 비쌈. 대기업만 썼었음.
  // 안정적임.
  // 이걸 무료로 만든 사람이 리누스(가 만든 게 리눅스)



//// 리눅스 관련 자잘 정보

// 그룹핑(그룹 만들기)는 슈퍼 유저가 만들 수 있다.

// 터미널 관련
  // ★ 각 디렉토리 권한을 끄고 켰을 때
    // 읽기 권한(w)을 끄면 ls나 ll로 디렉토리 안을 읽을 수 없다.
    // 실행 권한(x)을 끄면 디렉토리 안으로 들어갈 수 없다.
  // ★ Permission denied  ::  퍼미션 디나이드(허가 거부)
    // 명령어 실행시 접근 허가(Permission)를 거부(denied)하는 메세지
    // 접근 권한이 없는 파일에 엑세스하려고 할 때 뜨는 메세지.
      // 이럴 땐 보통 루트 계정으로 엑세스하면 됨.
  // $, # 기호는 커멘트?
    // 일반 유저로 접속시에는 명령어 입력 맨 앞에 $가 쓰여있음.
    // 루트 유저로 접속시에는 명령어 입력 맨 앞에 #가 쓰여있음.
    // 일반이랑 루트를 구분하려고 써놓는 거 같다. 알아보지는 않음.
  // ★ 이름 앞에 .이 붙은 파일명은 숨김파일
    // 시스템 파일(아마도)
  // ★ /etc는 시스템 파일이 들어있음. 그래서 루트로 접속해야됨.

// 루트 계정 디렉토리는 최상위 디렉토리(/) 바로 아래에 있음.
  // 나머지 일반 계정 디렉토리는 /home 바로 아래에 있음.
  // 일반 계정을 추가로 생성시 역시 /home 폴더 바로 아래에 들어가짐.
    // 일반 계정들은 자신 이외의 다른 계정의 폴더에는 기본적으로 접근 권한이 없음. (권한을 만들어줄 수는 있음)
    // 루트는 상관없이 계정 및 시스템 폴더에 접근이 가능함.

// ★ 리눅스에서는 폴더를 디렉토리라고 부름.

// ★ CentOS 기업에서 많이 씀.

// 리눅스나 맥은 개발용 컴퓨터(?)라 퍼티 필요없음.
  // 터미널 들어가서 뚝딱 접속하면 됨.
  // 원격 접속 명령어(리눅스 터미널 :: 퍼티 아님 주의)
    // ssh 10.0.2.15 -1 tenisme

// AWS 서버 - EC2(컴퓨팅)
  // 아마존의 EC2에 해당하는 게 지금 배우는 센트OS
  // 아마존도 센트OS가지고 만듦. 아마존이 미는 거.

// 일반 유저 계정 비번 까먹었을 땐 싹 지우고 새로 추가해야 한다.
  // 계정 삭제하면 해당 계정의 디렉토리 내용들이 전부 사라지는 것 주의.
  // 계정 내용을 잘 백업해두면 새로 만든 계정에 자료를 옮겨놓을 수 있다.



//// 기타 자잘한 정보

// 강사님은 안스에서 AVD를 픽셀2로 만드심.

// 안드로이드 개발에 필요한 문법은 라이브러리에 가까움.

// 이 과정에서 배우는 것
  // 앱 개발/ 데이터통신 서버 http로 통신/ 데이터 처리하는 데이터베이스
    // 즉 앱, 서버, 데이터베이스

// 윈도우는 개인용이라 서버로 쓰면 터짐.

// 원래 서버(용 컴퓨터)는 모니터(화면)나 키보드(입력) 그런 거 읎음. "서버용"임.

// 윈도우에서 ip주소 알아내기
  // cmd >> ipconfig 치고 엔터 >> 첫 묶음의 IPv4 주소가 ip주소(192.168.~~)

// 버추얼박스 익스텐션 팩6.1.6 CentOS에도 또 적용하나봄.

// 뭔소린지 잘 모르겠음 주의
  // 실행될 때 런 레벨을 잘 설정해주면 네트워크 동장하게할거냐 안하게할거냐 등등을 설정할 수 있음.
  // 런레벨 레벨 네트웍모드로 시잘할 거냐 그래픽모드로 시작할 거냐를 결정해주는 애가 default.~

// 버추얼박스 기본 호스트키는 우측 컨트롤 키로 설정되어있음.
  // 가상 머신에서 작업하다가 빠져나오려면 호스트키를 눌러야 함.

// 실무에서 슈퍼관리자 비밀번호는 관리자만 알아야 하는 것.
  // 루트 비번 까먹으면 답없음.
  // 비밀번호 아는 사람만 시스템(etc 등)에 접근가능.

// 실무에서는 무슨 작업을 하든 루트 계정으로 작업하면 혼남.
  // 시스템 파일 건드리기 등등 실수할 가능성이 높기 때문임.

// 서버의 개념 (검색 정보)
  // 주된 정보의 제공이나 작업을 수행하는 컴퓨터 시스템. 서버는 클라이언트 시스템이 요청한 작업이나 정보의 수행 결과를 돌려준다.

// 서버 계정??? 서버컴에 있는 계정을 서버 계정이라고 부르면 되려나.

// 시스템 엔지니어(설치해주는 사람)

// 일반 유저 폴더 아래에는 documents 폴더와 downloads 폴더 등등이 있다.

// 시험 하루 종일 보는 거 아님. 60에서 90분 정도
  // 시험보기 전에 나올 부분에 대해서 말해줌.

// 추상클래스, 인터페이스는 안드로이드 배울 때 배움

// 아이노드(inode) 블록, 데이터(data) 블록은 아직 잘 모르겠음.

// 퍼티 커스텀 설정은 굳이 방법 메모 안 해도 될 듯.
  // 세팅 설정창의 세션 항목에서 세션 저장해야 지금 해놓은 설정 계속 쓸 수 있음. 안그럼 초기화됨.

200518 월요일 수업 중요 키워드

HashMap
  a, b = reference type
  d = key
  e = value
  i = index
  HashMap<a,b> c = new HashMap<a,b>();
  c.put(d,e)
  c.get(d)
  Object[] f = c.keySet().toArray();
    f[i]
  Object[] g = c.values().toArray();
    g[i]

OS

CentOS
  CentOS 설치

★SSH
  ssh
  sshd
  CentOS에 sshd설치

SDK - Android Studio

PuTTY
  CentOS에 원격 접속하기

터미널 명령어(Terminal Command) 기본 & 기본 키
  poweroff
  shutdown
    shutdown now
  reboot
  man [command]
  su
    su [userid]
    sudo
  clear
  exit
  cd /경로
    cd .. or cd ../
    cd . or cd ./
    cd ~
    cd / (not root)
  pwd
  ls
    ls /경로
    ls -a
    ls -il
    ls /
  ll
    ll /경로
    ll -a
    ll -il
    ll /
  vi /경로/파일명
  touch /경로/파일명
  cat /경로/파일명
  mkdir /경로/디렉토리명
  에디터(vi) 편집키
    i, a, o
    Delete, x, Backspace
    dd
  cp /경로/파일명 /경로/파일명
  mv /경로/파일명 /경로
    mv 파일명일부* /경로
  rm /경로/파일명
    rm -r /경로
    rm -rf /경로
  echo
  useradd [userid] (only root)
    passwd [userid] (only root)
  del [userid] (only root)
  Esc
    Esc :q
    Esc :q!
    Esc :w (in vi)
    Esc :wq (in vi)
  Ctrl+C
  q
  tab
  /
  ↑,↓(방향키 위, 아래)
  텍스트 복사 후 우클릭

ln [option] /경로/파일이름.txt /경로/링크이름.txt
  ln -s /경로/파일이름.txt /경로/링크이름

chmod 000 /경로/파일명
  Change Mode, 모드 변환, 권한 체인지, Permission을 주다
  000  ::  유저/그룹/기타
  r = 4, w = 2, x = 1, - = 0

서버 시간 셋팅
  ln -sf /usr/share/zoneinfo/Asia/Seoul /etc/localtime

gedit /경로/파일명

파일 정보 설명
  파일 유형  ::  -, d, l (파일/디렉토리/소프트링크)
  ★파일 허가권  ::  r, w, x, - (읽기/쓰기/실행/권한없음)
  링크 수
  파일 소유자 이름
  파일 소유 그룹 이름
  파일 크기
  마지막 변경 날짜 & 시간
  파일 이름

절대경로/상대경로

파일 유형별 컬러 표시

클라우드 서비스

프로토콜

Permission denied

AWS 서버 - EC2200518 월요일 수업에 쓰인 코드



1) 해시맵1
        HashMap<String,String> map = new HashMap<String,String>();
        map.put("name", "Mike");
        map.put("tel","010-1234-5678");
        map.put("address","Seoul");
        map.put("age","35");

        System.out.println(map.get("name"));  // value값이 출력
        System.out.println(map.get("tel"));  // value값이 출력
        System.out.println(map.get("address"));  // value값이 출력

        System.out.println();

        // possible Object --> String
        Object[] keys = map.keySet().toArray();  // key값만 저장
        for(int k = 0; k < keys.length; k++){
            System.out.println((String)keys[k]);  // key값만 출력
        }

        System.out.println();

        Object[] values = map.values().toArray();  // value값만 저장
        for(int k = 0; k < values.length; k++){
            System.out.println((String)values[k]);  // value값만 출력
        }
=====결과값
Mike
010-1234-5678
Seoul
35

address
name
tel
age

Seoul
Mike
010-1234-5678
35



2) 해시맵2
HashMap<String,Integer> scoreMap = new HashMap<>();  // int X Integer O
        scoreMap.put("KOR",88);
        scoreMap.put("ENG",77);
        scoreMap.put("MATH",100);

        Object[] keys1 = scoreMap.keySet().toArray();  // key값만 저장
        for(int k = 0; k < keys1.length; k++){
            System.out.println((String) keys1[k]);  // key값만 출력
        }

        System.out.println();

        Object[] values1 = scoreMap.values().toArray();  // value값만 저장
        for(int k = 0; k < values1.length; k++){
            System.out.println((Integer) values1[k]);  // value값만 출력
        }
=====결과값
MATH
KOR
ENG

100
88
77



3) 해시맵 예시 어레이리스트vs해시맵
// 어레이리스트에 46.33, 77.8, 90.0, 87.5를 저장
// 해시맵에 각각 마이크, 해리, 제인, 폴의 점수를 위와 같이 저장
        // ArrayList
        ArrayList<Double> scoreList = new ArrayList<>();  // double or float
        scoreList.add(46.33);
        scoreList.add(77.8);
        scoreList.add(90.0);
        scoreList.add(87.5);

        for(Double value : scoreList){  // 향상된 for문으로 출력
            System.out.println(value);
        }

        System.out.println();

        // HashMap
        HashMap<String,Double> scoreHash = new HashMap<>();
        scoreHash.put("Mike",scoreList.get(0));  // 걍 숫자값 적어도 됨.
        scoreHash.put("Harry",scoreList.get(1));  // 그냥 이렇게 해봄.
        scoreHash.put("Jane",scoreList.get(2));
        scoreHash.put("Paul",scoreList.get(3));

        System.out.println(scoreHash.get("Jane"));

        System.out.println();

        // remove hashmap data
        scoreHash.remove("Jane");
        System.out.println(scoreHash.get("Jane"));
=====결과값
46.33
77.8
90.0
87.5

90.0

null



4) 200519 화요일 수업 메모 정리



// yum  ::  소프트웨어 설치 & 업데이트
  // 루트 계정으로 사용하자.
  // 해당 OS가 받을 수 있는(패치할 수 있는) 소프트웨어를 yum으로 알아보고 인터넷을 통해 설치하도록 도와주는 명령어.
  // ★ 뭐 설치할 때 서버(네트워크) 연결 꺼지면 안됨.
  // yum install 소프트웨어이름
    // 이 이름의 소프트웨어를 설치함.
    // yum -y install 소프트웨어이름
      // y를 일일히 안 누르고도(-y) 이 소프트웨어를 끝까지 설치할 수 있도록 도와주는 명령어
  // yum check-update
    // 업데이트할 수 있는 것을 체크하고 보여달라.
    // 업뎃할 수 있는 것들이 하얀 글씨들로 뜸.
  // yum update (소프트웨어이름)
    // 업데이트가 있으면 전부 업데이트해라 (★only root)
    // 업뎃할 수 있는 목록 쭉 뜸.
    // 이거 업뎃 할 거냐. y >> 업뎃 진행
    // update 뒤에 특정 소프트웨어 이름 적으면 그것만 업데이트(아마도)
  // yum info 소프트웨어이름
    // 이 소프트웨어의 정보를 확인
  // yum remove 소프트웨어이름
    // 이 소프트웨어 지우기



//// ★★★ 압축하기 (직접 테스트해보기)

// 많은 파일을 압축해서 보낼 때 등등에 사용.
// 압축 파일 종류는 많음. 확장자명 보고 거기에 맞게 압축하거나 풀어주면 됨.
// 압축을 한다고 원본 파일이 알아서 삭제되진 않음.
// 압축을 푼다고 압축파일이 알아서 삭제되지 않음.

// 하나씩 따로따로 압축하기 & 풀기
  // bzip2 /경로/파일명 /경로/파일명 ...  ::  파일들을 .bz2로 ★각각★ 압축
    // 압축 해제하기  ::  bzip2 -d 파일명.bz2
  // gzip /경로/파일명 /경로/파일명 ...  ::  파일들을 .gz로 ★각각★ 압축
    // 압축 해제하기  ::  gzip -d 파일명.gz

// .zip 만들기 & 압축 풀기
  // .zip : 윈도우즈와 호환되는 압축파일 확장자
  // zip 압축파일명.zip /경로(/파일명) /경로(/파일명) ...
    // 뒤에 적은 파일(혹은 디렉토리)들을 묶어서 압축파일명.zip로 저장
    // zip -r 압축파일명.zip /경로
      // 경로 아래에 포함된 모든 디렉토리들을 포함해서 압축한다.
  // unzip /경로/압축파일명  ::  압축 풀기

// tar  ::  "묶음"으로 하나의 압축 파일 만들기 & 해제하기
  // 무슨 파일이든지 묶어주는 것을 먼저 하고 다음에 압축해야한다.
  // tar cvfz 파일명.tar.gz {압축할디렉토리이름}
    // cvfz : 묶을 때 사용하는 명령어
      // c : 새로운 묶음을 만들어라
      // v : 묶은 것을 보여달라(숨김파일 여부 말하는듯)
      // f : 파일을 지정할 것이다
      // z : ★gzip 유형으로 압축하겠다.★
        // bzip2 유형으로 압축하려면 이 자리를 j로 바꿔 쓰면 된다.
    // 파일명 뒤에는 확장자를 꼭 붙여야 한다. 예시에서는 ".tar.gz"이다.
  // tar xvfj 파일명.tar.bz2
    // xvfj : 압축을 풀 때 사용하는 명령어
      // x : 압축을 해제해라
      // v, f 위와 같음
      // j : ★bzip2 유형의 압축파일★을 풀어라



// 스크립트 파일을 만들어 실행시키기
  1) touch a.txt
  2) vi my_script (이름 뒤에 확장자 없음)
  3) my_script 편집  ::  rm a.txt 를 적어놓고 저장
    // 즉 이 파일 안에 터미널 명령어를 적어놓으면 된다는 말임.
  4) ./my_script  ::  my_script를 이와 같이 실행시키면 a.txt가 사라짐.



// ★ crontab(크론, 크론탭) 스케줄러 만들기(스케줄링), 정기적 서버 작업 설정
  // 특정 시간에 스케줄된 작업을 처리하도록 만든다
  // 크론의 파일 권한때문에 루트로만 크론에 접근할 수 있지만, 일반 계정으로 사용하는 방법도 있음.
  // 실제로 실무에서 주기적으로 로그(기록) 파일을 삭제할 때 크론을 쓴다고 함.
  // 크론탭 만들기 전에 시스템 시간 먼저 체크하기.
  // 자세한 작성 방법 정보 : https://jdm.kr/blog/2
  1) 루트 권한으로 크론 만들기
    // vi /etc/crontab
    // 맨 밑에 "분 시 일 월 요일 사용자 실행명령"을 적고 저장
      // 분60 시24 일31 월12 요일0~7
    예) 00 05 1 * * root cp -r /home /backup
    // systemctl status crond  ::  크론탭이 동작하는지 확인하기
      // active 떠있으면 활성화되어있다는 뜻.
  2) 일반 계정으로 크론탭 만들기
    // crontab -e : 크론탭 에디터로 들어감
    // "분 시 일 월 요일 사용자 실행명령"을 적고 저장
    // crontab -l : 크론탭 잘 적용되고 있나 보여줌
    // 주의사항
      // 일반 계정으로도 크론탭을 만들 수는 있지만 루트 계정으로 만든 크론탭은 못 건드림



//// DBMS (database management system)

// 주요 DBMS들의 배경지식
  // 데이터베이스 소프트웨어(DBMS) : mySQL, mariaDB, 오라클 등
  // mariadb vs mysql
    // 오라클(회사이름)의 DBMS 제품 오라클이 있었음.
      // 비쌈.
    // 예전엔 기업에서 오라클 많이 씀.
    // 요새는 둘다 많이 쓰지만 MariaDB < MySQL
    // 오라클(기존따봉) >> 오픈소스(무료) DBMS들이 나오기 시작하면서 오픈소스 DBMS(MySQL이) 유명해짐
    // 오라클이 MySQL 인수함.
    // MySQL 오픈소스정책이 부분 유료로 바뀜.
      // MySQL 제작자 빡쳐서 MySQL과 똑같은 무료 DBMS(MariaDB)를 만듦.
  // 결론 : 둘 다 같은 프로그램인데 MySQL은 라이센스 걸려있고 MariaDB는 무료.

// 관련 용어
  // 데이터 : 앱에서 처리하는 자료
  // 테이블 : 데이터 묶음. 데이터를 표 형식으로 표현한 것
    // 테이블은 2차원 행렬로 이루어짐
      // 도식화할 때에는 표 그림, 네모박스 그림으로 나타냄.
    // ★ 테이블 설계 : 필요한 정보가 무엇인지 설계하고 구상하는 것
  // 행(raw) = 레코드(record) : 행단위로 들어오는 데이터(가로 한 줄)
  // 열(field) = 컬럼(column) : 열단위로 들어오는 데이터(세로 한 줄)
  // 데이터베이스 : 테이블 묶음
    // 저장소에 구분되는 가장 큰 단위
  // 데이터 타입 : DBMS에서의 데이터 타입.
  // DBMS : 데이터베이스를 관리하는 소프트웨어
  // RDBMS : 관계형 모델을 기반으로 하는 데이터베이스 관리 시스템
    // relational database management system
  // key : 주키, 외래키.
  // SQL : 데이터 저장, 갱신, 삭제시 사용할 수 있는 표준 언어 규약
    // Structured Query Language
    // RDBMS의 데이터를 관리하기 위해 설계된 특수 목적의 프로그래밍 언어
    // SQL을 활용해 쓴 문장을 SQL문이라고 한다.
      // Q의 쿼리를 따서 쿼리문이라고도 한다.
  // DBA : 데이터베이스를 설계하는 사람
  // 데이터베이스를 도식화할 땐 입체적 원통 모양으로 나타내는 것이 표준이다.



// ★ 프로세스, 데몬(백그라운드 프로세스), 서비스, 프로그램
  // 윈도우OS 작업관리자에서 볼 수 있는 그 이름들.
  // 프로세스 : 실행중인(컴퓨터 메모리에 올라온) 프로그램
    // "메모리에 로딩되어 활성화된 것"
      // 실행이 끝나면 메모리에서 내려감.
    // 각각의 프로세스에 고유 번호(아이디)를 부여해 프로세스를 구분한다.
    // 부모 프로세스, 자식 프로세스가 있음
  // 데몬 : 윈도우에서 말하는 "백그라운드 프로세스"
    // 실행하면 컴퓨터 끌 때까지 뒤에서 안보이게 계속 돌고 있는 것.
    // 데몬 프로그램 실행파일 뒤에는 보통 d가 붙음
    예시) sshd
  // 서비스 : 데몬이랑 비슷함.
  // 프로그램 : 실행파일
    // 프로그램은 하드디스크에 설치된다.
      // 프로세스가 설치되었다고 하지 않는다.
    // 프로그램이 실행되어 메모리에 올라와 있는(메모리를 차지하는) 상태를 프로세스라고 함.



// 네트워크 용어 설명
  // 프로토콜 : 전세계적 통신 규약
  예시) tcp/ip 프로토콜 = tcp/ip 통신규약.
    // tcp/ip는 컴퓨터 네트워크 통신 규약. 전화에 쓰는 통신 규약과 다름.
  // 호스트 이름 : 컴퓨터에 지정된 이름
  // 도메인 이름 : 예시) naver.com
    // co.나 com.은 회사라는 뜻
  // ★ IP : 고유한 컴퓨터 주소
    // 공인 IP(퍼블릭 IP) : 전 세계 어디서나 접속할 수 있는 주소
      예시) 192.168.0.1
      // 회사에서 쓰는 대부분의 웹서비스들이 공인 IP로 제공됨.
      // 각 자리마다 0~255까지밖에 못 들어가서(4바이트) 갯수가 정해져있음.
      // AWS 만들면 공인 IP를 만들어줘서 어디서든 접속할 수 있음.
    // 사설 IP : IP가 있어도 마음대로 접속할 수 없음.
      예시) 학원 컴퓨터들은 공인 아이피를 받아서 사설 IP로 쓰고 있다.
    // IP의 맨 앞자리가 같으면 서로 통신이 가능하다.
    // 127.0.0.1은 컴퓨터가 자기 자신을 가리키는 IP이다.
  // nic : 랜카드



// 서버, DBMS "원격" 접속 과정 설명
  1. 서버 역할을 하는 컴퓨터(A)에 리눅스를 설치 & sshd 설치
  2. 윈도우OS의 현재 컴퓨터(B)에서 A와 연결하기 위해 푸티를 썼었음.
  3. A에 접속해서 A에 DBMS를 설치하고, 또 DBMS를 실행함.
  // 여기까지의 접속 과정 요약 : B(윈도우) -<푸티>- A(리눅스) - DBMS
    // B가 리눅스인 경우엔 "B(리눅스) - A(리눅스) - DBMS"가 됨.
  // 이 과정을 B - DBMS로 줄여주는 프로그램이 "MySQL Workbench"
    // 워크벤치는 B의 운영체제를 가리지 않음.



// 어플리케이션이 돌아가기 위한 기본 구조 4가지
  예) //인터페이스(API)//
              ↑
      앱 <<http>> 웹"서버"(리눅스) / 데이터베이스(DBMS in Linux)
  1) 앱 : 코딩해서 만들어놓은 프로그램. 실행파일
  2) 인터페이스(API)
  3) 웹서버 : 서버는 앱에서 요청한 실행 코드를 돌림.
    예) 회원가입 담당 코드, 로그인 담당 코드
    // 이 때 필요한 데이터가 있으면 데이터베이스에 요청함.
  4) 데이터베이스(DBMS)



//// 자잘 정보

// 서버컴 켜지기만 하면 로그인 안 해도 퍼티 켤 수 있음.

// 컴 켜지면 자동으로 네트워크 연결되도록 하기(?)
  1) 슈퍼유저로 접속 후
  2) vi /etc/sysconfig/network-scripts/ifcfg-enp0s3
  3) ONBOOT="yes"
    // "no"로 되어있으면 딜리트키로 지우고 "yes"로 수정
  4) 제대로 고쳤으면 Esc :wq(저장하고 나가기)
  5) shutdown -r now  <-- 재부팅

// 데이터베이스 설치도 슈퍼유저로 함.

// 수업에서는 mysql-connector-dbdc 설치하려다가 실패
  // vsftpd 설치

// 소프트웨어 설치 의존성(다른 게 먼저 설치되어야 할 때) 문제
  // 뭔지 잘 모르겠지만 일단 메모 킵

// 일반 계정에 처음 들어가면 '호스트 도큐먼트 디렉토리(~)'로 입성
  // cd .. 으로 올라가면 home으로 감.

// home 디렉토리는 유저가 새로 생길 때 마다 유저 이름으로 디렉토리 폴더가 알아서 생성됨.

// root 계정을 부르는 명칭 : 루트 유저, 슈퍼 관리자, 슈퍼 유저, 슈퍼 어드민

// : 콜론 ; 세미콜론

// ★★★ "~"는 홈 dir가 아니라 홈 밑에 있는 유저이름의 dir를 가리키는 거 좀 주의하기.
  예시) /home/~
  // 루트는 그냥 /root
  ★ 근데 명칭은 홈디렉토리임 주의

// (자바) 생성자 디폴트는 퍼블릭. 디폴트 생성자는 퍼블릭. 이 말이나 저 말이나.

// 마리아디비도 리눅스 속에 설치한 것.

// 마리아 깔았는데 프로그램이름이 마이에스큐엘인이유
  // 마리아를 마이에스 제작자가 만들었기 때문에 프로그램 이름도 마이에스임. 똑같이 만들어놓음.

// ssh와 푸티를 이용해서 리눅스(CentOS) 서버접속해서 DBMS설치한거.

// 인터넷은 http프로토콜을 씀.

// *.conf
  // CONF 파일은 Unix 및 Linux 기반 시스템에서 사용되는 구성 또는 "config"파일입니다. 시스템 프로세스 및 응용 프로그램을 구성하는 데 사용되는 설정을 저장합니다.

// ★파일 "실행 명령"은 그냥 앞에 붙는 명령어 없이 파일 경로 적고 파일명까지 적고 엔터치면 됨.

// 파일 자료 '리눅스'에 올려놓으심.

// 앱 개발자가 네트워크 깊숙히 알 필요는 없음 소통할 수 있을 정도로만 알면 됨

// 리눅스(서버) 루트와 DBMS 루트는 다름. 고로 계정 비번도 각각임.

// 오늘까지는 웹서버와 데이터베이스를 담을 리눅스 틀(빈껍데기)까지를 배움.
  // 오늘부터 데이터베이스를 설치, 배우고 다음에는 웹서버를 설치하고 배움.

// 파일 위치 이동시 현재 위치에서 바로 밑에 있는 폴더가 아니면 해당 디렉토리 이름 앞에 경로를 꼭 적어줘야 함에 유의.★
  예) mv 파일명 /home/tenisme/Downloads/  <-- 시작 경로부터 적음
  예) mv 파일명 Downloads/  <-- 본인 위치에서부터 적음
  // 맨 뒤에 /는 안 적어도 됨. cd ..도 맨 뒤에 /가 생략된 경우임.
200519 화요일 수업 중요 키워드

yum  ::  설치 & 업데이트
  yum install 소프트웨어이름
  yum -y install 소프트웨어이름
  yum check-update
  yum update (소프트웨어이름)
  yum info 소프트웨어이름
  yum remove 소프트웨어이름

bzip2
  bzip2 /경로/파일명 /경로/파일명 ...
  bzip2 -d /경로/파일명.bz2

gzip
  gzip /경로/파일명 /경로/파일명 ...
  gzip /경로/파일명.gz

tar
  tar cvfz 파일명.tar.gz {압축할디렉토리이름}
  tar cvfj 파일명.tar.bz2 {압축할디렉토리이름}
  tar xvfz 파일명.tar.gz
  tar xvfj 파일명.tar.bz2

zip
  zip 압축파일명.zip /경로(/파일명) /경로(/파일명) ...
  zip -r 압축파일명.zip /경로
  unzip /경로/압축파일명

cron(crontab)
  1) 루트 권한
    1. vi /etc/crontab
    2. 분 시 일 월 요일 사용자 실행명령
    3. Esc :wq
    (4. systemctl status crond  ::  크론탭 동작 확인)
  2) 일반 유저
    1. crontab -e
    2. 분 시 일 월 요일 사용자 실행명령
    3. Esc :wq
    (4. crontab -l  ::  크론탭 동작 확인)

DBMS
  Database
    원통모양
  Data / Column
  Table
    네모박스, 표 그림
  Data type
  DBMS  ::  DataBase Management System
    MySQL = MariaDB / Oracle
  RDBMS  ::  Relational DataBase Management System
  Key  ::  Primary Key(PK)
  SQL  ::  Structured Query Language
  DBA

프로세스  ::  실행중인 프로그램

데몬  ::  뒤에서 실행중인 프로그램

서비스  ::  데몬과 비슷한 거

프로그램  ::  실행파일

네트워크 용어
  프로토콜
    tcp/ip
    http
  호스트 이름
  게스트 이름
  도메인 이름
  IP
    공인 IP
    사설 IP
  nic

어플리케이션 실행의 4가지 기본 구조
  앱
  인터페이스(API)
  웹서버
  데이터베이스(DBMS)

: 콜론
; 세미콜론

200519 화요일 수업 중요 키워드

yum  ::  설치 & 업데이트
  yum install 소프트웨어이름
  yum -y install 소프트웨어이름
  yum check-update
  yum update (소프트웨어이름)
  yum info 소프트웨어이름
  yum remove 소프트웨어이름

bzip2
  bzip2 /경로/파일명 /경로/파일명 ...
  bzip2 -d /경로/파일명.bz2

gzip
  gzip /경로/파일명 /경로/파일명 ...
  gzip /경로/파일명.gz

tar
  tar cvfz 파일명.tar.gz {압축할디렉토리이름}
  tar cvfj 파일명.tar.bz2 {압축할디렉토리이름}
  tar xvfz 파일명.tar.gz
  tar xvfj 파일명.tar.bz2

zip
  zip 압축파일명.zip /경로(/파일명) /경로(/파일명) ...
  zip -r 압축파일명.zip /경로
  unzip /경로/압축파일명

cron(crontab)
  1) 루트 권한
    1. vi /etc/crontab
    2. 분 시 일 월 요일 사용자 실행명령
    3. Esc :wq
    (4. systemctl status crond  ::  크론탭 동작 확인)
  2) 일반 유저
    1. crontab -e
    2. 분 시 일 월 요일 사용자 실행명령
    3. Esc :wq
    (4. crontab -l  ::  크론탭 동작 확인)

DBMS
  Database
    원통모양
  Data / Column
  Table
    네모박스, 표 그림
  Data type
  DBMS  ::  DataBase Management System
    MySQL = MariaDB / Oracle
  RDBMS  ::  Relational DataBase Management System
  Key  ::  Primary Key(PK)
  SQL  ::  Structured Query Language
  DBA

프로세스  ::  실행중인 프로그램

데몬  ::  뒤에서 실행중인 프로그램

서비스  ::  데몬과 비슷한 거

프로그램  ::  실행파일

네트워크 용어
  프로토콜
    tcp/ip
    http
  호스트 이름
  게스트 이름
  도메인 이름
  IP
    공인 IP
    사설 IP
  nic

어플리케이션 실행의 4가지 기본 구조
  앱
  인터페이스(API)
  웹서버
  데이터베이스(DBMS)

: 콜론
; 세미콜론

////시험에 뭐나오나


String클래스 - 문자열 함수에서 1문제
단답형 많아도 3개 new this 나머지 하나는~~?
15~20문제 사이에서 나옴
할 수 있는만큼만 하고 아는 만큼만 풀자.



컬렉션
스트링클래스 사용법 문법 나옴 이메일
매스클래스 라운드함수 나옴 소수점 몇째짜리까지만 보여주고싶을 때
어레이리스트
해시맵 데이터 엑세스

실습문제중에 하나 나올수도안나올수도.

실제(실무)로 사용하는 것들로만 냄.
100점용 문제는 따로 있음.200520 수요일 수업 메모 정리



=================



// 리턴의 데이터 타입 = 함수의 데이터 타입

// 함수는 클래스 아래에 있다.
  // 함수 아래에 함수는 없다.

// a.indexOf(b)
// 본 함수의 기능은 문자열 위치값을 찾아주는 것이다. "색인".
// 찾는 문자가 없을 때 -1값을 리턴하는 것을 이용해 if문에 !=나 ==와 같이 쓴다.
  ex) hello에서 llo를 찾아달라고 하면 llo가 시작되는 인덱스 번호를 리턴한다. ex) 2 리턴
  ex) hello와 hellO를 비교하면 -1을 리턴한다. (★대소문자 구분)
// 문자열 길이나 찾는 인덱스 번호에 따라 "-1부터 다양한 정수값을 리턴"한다.

// a.equal(b)
// a와 b를 "비교" 후 "true or false를 리턴"해주는 함수. 이외의 비교 대상은 필요하지 않다.
  ex) if(a.equal(b) == 0) 는 에러뜸.
// 대소문자를 구분하지 않고 똑같이 처리한다.

// a.compareTo(b)  // 실험 필요 : a>b, a<b일 때 반환값은 무조건 +1, -1인지 아니면 +n, -n인지
// a와 b를 "비교"해 "정수값을 리턴"하는 메소드
  // a와 b가 있을 때 이 둘을 제일 세부적으로 비교해줄 수 있는 함수. 색인아님 주의.
  // a값과 b값을 각각 유니코드 값으로 변환해 그 값을 비교한다.
// a와 b값이 같으면 0, a가 더 크면 +, a가 더 작으면 -를 리턴
  // a와 b값이 같을 때 0을 반환하는 것을 이용해 if문에서 !=나 ==와 같이 쓴다.
  ex) a = "A"고 b = "B'일 때 A의 유니코드 값은 feff0041, B의 값은 feff0042
      a.compareTo(b)를 하면 -1(음수)가 반환됨.
---



===================



// Port number(포트 번호)
// 여러가지 정의와 비유
  // 데이터를 받을 프로세스를 구별해주는 식별자
  // 논리적인 접속 장소를 나타내는 이정표
  // 외부세계와 접속할 수 있는 관문. 항구나 공항(Airport)에 비유됨.
// IP address는 "컴퓨터"를 찾을 때 필요하고,
// Port number는 그 컴퓨터 안에서 "프로그램(프로세스)"을 찾을 때 필요하다.
  // 프로세스마다 접속을 위한 식별자(Port)가 있어 접속할 프로그램을 고를 수 있다.
★ 한 기기에서 포트가 일치하면 안 됨.



// CentOS(ssh)와 MariaDB에 연결할 때의 "포트 번호"와 부가 설명
// 외부에서 CentOS(리눅스)에 접근할 수 있도록 해준 포트는 "ssh의 포트 22"
  // (호스트windows)22 - (게스트linux)22로 연결됨 in putty
  // 여기에서 이 서버컴에 설치된 DBMS를 켜서 맛보기 DB공부를 함.
  // "ssh로 접속한다"는 말을 씀.
// 워크벤치에 MariaDB 이름으로 만든 것은 윈도우 컴에 설치된 MySQL에 연결된 것이다.
  // ★로컬 접속★한 것임
  // (호스트windows)3306 - (게스트windows_mariadb)3306으로 연결됨
  // 윈도우즈의 "MySQL(MariaDB)로 접속한다"
// 워크벤치에 CentosMySQL 이름으로 만든 것은 리눅스 컴(CentOS)에 설치된 MariaDB에 연결된 것이다.
  // ★리모트 접속★한 것임
  // (호스트windows)11111 - (게스트linux_mariadb)3306으로 연결됨
    // 호스트의 포트 번호는 이미 로컬접속을 할 때 3306을 써버려서 11111로 바꿔 적은 것임.
  // MariaDB의 포트가 3306.
  // MariaDB의 "MySQL(MariaDB)로 접속한다"



=======================



// show databases;
  // 데이터베이스가 무엇무엇이 몇 개가 있느냐를 보여줌
  // MariaDB의 기본 제공 데이터베이스는 4개



// use DB이름;
  // 특정 디비에서 작업하기 위해 해당 디비를 사용하도록 하는 명령어
  // 건들고 싶은 테이블이 있으면 그 테이블의 상위 데이터베이스에 use를 써서 먼저 접속해야 한다.
  // 어떤 데이터베이스 안에 만들고 싶은 테이블이 있을 때에도 먼저 use를 써서 해당 DB에 접속 먼저 하는 것이 첫 순서이다.



// show tables;
  // 선행 : 특정 DB 진입 ex) use DBname;
  // 진입한 DB에 어떤 테이블들이 있는지 목록을 보여달라



// select문
// 셀렉트는 테이블 안의 내용을 조회하는 기능을 한다.
// select * from tableName;
  // tableName 안에 "저장되어" 있는 모든 데이터(의 실체)를 조회한다는 명령어.
  // 조회한다/보여준다 => select
  // 모든 컬럼 => *
  // ~ 테이블 안에 있는(경로) => from
// 여러개의 컬럼을 보기 위해서는 ,(콤마) 로 나눈다.
  ex) select a, b from c;



// where
  // 원하는 데이터 조건이 있을 때
    // select from 뒤에 where을 붙이고 필요한 조건을 쓴다.
  // =, !=, >=, >, <=, < 등 비교 연산자를 전부 쓸 수 있다.
    // 비교할 조건이 null이면 = null이 아니라 is null로 적는다.
	  // !=이면 is not null로 적는다.
  // 여러 조건을 붙이려면 and와 or을 쓴다.
    // and => ~이고(자바의 &&)
	// or => ~이거나(자바의 ||)
	  ★ and나 or 뒤에 조건을 계속 쓸 땐, 이 데이터가 어떤 컬럼에 해당하는 데이터인지를 알기 위해 앞과 같이 컬럼명을 꼭 다시 적어줘야 한다.
	  ex) a = b and d  (X)
	  ex) a = b and c != d  (O)
---



// distinct
  // 중복된 데이터들의 중복값들을 제거하고 하나씩만 조회하고 싶을 때
    // select 옆에 붙어서 뒤에 붙는 컬럼의 중복을 제거한다.
	  // 컬럼'들'인가...?? 디스팅트 뒤에 컬럼 추가로 더 붙이는 건 되던데.
  ex) 시티테이블에서 컨트리코드 kor인것만 가져와라.
		그리고 디스트릭트 중복제거하고 디스트릭트만 표시해라
		>> select distinct District from city where CountryCode = "KOR";
	// 이 때 select 옆에 적힌 distinct가 적용된 컬럼들만 표시된다.
	  // 모든 컬럼을 다 볼 수는 없다..?? 다른 컬럼들 이름을 다 적으면 안될까?

=======================











=======================



//// 데이터베이스에 대한 설명

// SQL : 데이터베이스 문법(중 하나?)
  // 지금 배우는 것이 SQL문 작성법.
  // SQL문으로 DB를 제어한다.
    // DB 접근 명령, 데이터 추가 명령 등등

// mysql 데이터베이스는 DB 관리를 위한 "시스템" DB이므로 함부로 건드리면 안된다.
  // sys 데이터베이스 역시 "시스템" 관련 데이터 묶음. 건드리지 말기.

// 데이터베이스 : 물리적인 커다란 집합. 보통 프로젝트 이름을 DB 이름으로 적는다.
  // 여러 테이블들을 묶은 것의 대표적인 이름일 뿐이다.

// 테이블은 항상 데이터베이스 밑에 있다.
  // 테이블은 항상 속해있는 데이터베이스가 있다.
  // 테이블은 "하위 개체", 데이터베이스는 "최상위 개체"
  // 테이블은 "실체"가 있다
    // 테이블 형식(행렬)로 "저장"되기 때문에 명칭이 "테이블"이다.

// 테이블 설계는 자바의 클래스 설계와 비슷함.
  // 테이블을 설계하고 데이터를 저장하기 위해 쓰는 언어가 SQL.

// 새 프로젝트를 만든다 => DBMS(MariaDB)에 새로운 DB를 만든다
  // MariaDB(MySQL)도 DB고, 그 안에 있는 sys나 mysql도 DB이다.

// 데이터를 분석한다 : 보통 테이블 안의 데이터를 분석한다는 뜻이다.

// 컬럼 이름 : 데이터를 조회했을 때 맨 위쪽에 보이는 컨

// 데이터베이스도 데이터 타입을 적어줘야 한다.
  // 컬럼마다 데이터 타입을 지정한다.
  // 데이터 타입을 알고 싶으면 좌측에 표시된 테이블 우클릭 > > 알터 테이블 >> 데이터타입 항목
  
// SQL 파일 저장은 .sql로 한다.
  // .txt로는 안된다. .sql을 메모장에서 열 수는 있다.
  
★ 쿼리문의 =과 같은 것은 자바의 ==이다. =아님 주의.  

★ SQL문 작성시 실제 컬럼 이름의 대소문자를 가리지는 않는다.
  // 그렇지만 왠만하면 정확하게 써 주는 것이 좋다.
  
// 탭 누르면 오름차순 내림차순으로 정렬됨?? 어디서 눌러야 하지



//// 워크벤치 관련 설명

// 개발자에게 필요한 부분은 Administration이 아니라 그 옆에 있는 Schemas(스키마) 탭이다.

// 보통 터미널로 DBMS 접속해서 작업하진 않음.
  // 워크벤치가 훨 쓰기 편하고 보기가 쉽기 때문.

// 워크벤치로 MariaDB에 연결하기 : 설치 방법 설명 파일에 관련 내용 다 있음.

// DB를 열면 나오는 Tables 탭이 "테이블"들을 작업하는 공간. 우리가 쓰는 공간.
  // 다른 탭들은 서버 개발자 단계에서 건드리는 것들임. 굳이 신경 쓸 필요 없음.

// 에디트 >> 프리퍼런스 >> 폰트앤컬러에서 폰트 설정이 가능하다.



//// 기타 설명

// (mysql in putty) >의 명칭 : 커서

// MariaDB(DBMS)에서는 보안때문에 보통 외부에서 루트권한으로 원격접속을 못하도록 막아놓는다.

// 이해하면서 천천히 하자.

// SQL은 자격증 시험도 있음.

// 일반 앱 개발자에게 있어서는 테이블 중요도가 90이고, 나머지는 10이다.

200520 수요일 수업 메모



// 퍼티, CentOS, MySQL Workbench 설치랑 마리아디비 연결 과정은 별도로 정리함. 해당 내용은 필요한 부분만 제외하고 지워도 됨.



======================



셀렉트 프롬 사이는 컬럼이름 쓴다 ★★★

-- 주석. 자바의 // /.

★ 데이터의 전체개수 알아보기 (★컬럼값 합산 아님 주의)
select count(*) from city;
select count(*) as cnt from city;  <-- 이건 어떻게 해석하는 거지

★ 행(가로)으로 들어가는 게 "데이터"
  예시) 데이터 추가 > 가로 추가
★ 열로 들어가는 건 "컬럼"

★ = 주의 ( 자바의 == 기능 )

예시) 시티 테이블의 국가명이 KOR인 데이터를 인구수로 "정렬"해라
select * from city;
시테테이블에 저장되어있는 값을 모두 보여달라.

select * from city where CountryCode = "KOR" order by Population desc;
  order by 컬럼이름 :: 컬럼이름 으로 정렬해라
기본은 작은거에서 큰걸로 정렬.asc (어센딩). 안 적어도 디폴트임.
큰거에서 작은 거 정렬은 desc (디센딩)

불러내는 순서 중요
별표 이름 스타마크
mySQL select 검색하면 셀렉트 문법 관련 정보 주루룩 나옴.
	메뉴얼 페이지(영문) 이 정보가 정확함.
	문법 다 외우는 건 도라이짓. 실무에서 쓰는 것만 가르쳐주실 거고 그거 외우면 됨.
	나머지 필요한 건 검색해서 쓰면 됨.
워크벤치로 문법 배우고 리눅스 리모트해서 본격 실습할 거임.

==정리==
SQL문도 실행문 마지막에 ;붙여주는 거 잊지말기.

select --(4)-- from --(1)-- where --(2)-- order by --(3)-- asc;
(4) select + 보여줄 "컬럼" 이름
  // 해당 이름의 컬럼 보여줌. 필요한 데이터만 보여줌(셀렉트)
    // 데이터를 가져와라
  // *  <-- 전체 컬럼을 의미
  // 다수의 컬럼을 불러오려면 , 로 구분
    // ★ 여기에 쓴 컬럼만 가져옴(보여줌)
    // 안 보이는 데이터 보고 싶으면 해당하는 컬럼 여기다 쓰면 됨.
    // ★ 컬럼을 , ,로 구분해 적은 순서대로 보여준다 (순서 바꿔서 볼 수 있음)
  // distinct + 컬럼 이름  <-- 해당 컬럼에서 중복값을 전부 제거하고 보여줌.
    // ★★★ 중복 제거한 한 컬럼의 전체 데이터 개수를 알고 싶으면 이걸 사용해서 구함.
      // 화면에 보여지는 데이터의 총 개수는 화면 하단의 Action Output 밑에 ~row(s) returned 앞에 적혀있음.
  // count(*) 
(1) from + 컬럼이 소속된 "테이블" 이름
  // 이 테이블에 소속된 ~
(2) where + "컬럼"이름 = 컬럼데이터(문자열or숫자)
  // 컬럼 안에 있는 특정 "데이터"들만 골라서 가지고 와라.
  // and, or을 써서 여러가지 데이터를 연결, 여러 조건을 붙여서 볼 수 있음.
(3) order by + "컬럼"이름 + asc
  // order by 뒤에 있는 컬럼 이름으로 정렬
  // asc : 오름차순 정렬
  // desc : 내림차순 정렬200520 수요일 수업 키워드

Cn = 컬럼 이름
Tn = 테이블 이름
Dn = 데이터베이스 이름
Jo = 조건문
Ha() = 함수
St = 문자열
Int = 정수
Dt = 데이터 타입

---

리턴의 데이터 타입

클래스 아래의 함수(메소드)

a.indexOf(b)	vs	a.equal(b)	vs	a.compareTo(b)

---

Port number

=====★SQL (Query)=====

save as .sql

basic query
	show
		show databases;
		show tables;
	use Dn;
	*
	;
	--

★select
	select Cn1, Cn2, Cn3

from
	from Tn

as (in select)
	a as b
		a  =>  Cn, Tn
	b  =>  St, "S  t"

where
	where Jo;
		=, !=, >=, <=, is null, is not null
	★where Jo1 and Jo2 and ...;
	★where Jo1 or Jo2 or ...;
	 where Cn like "%A%";
		A  =>  St, Int
		A가 영문 St인 경우 대소문자를 가리지 않는다.

★distinct (in select)
	distinct Cn
		"distinct"는 select 바로 옆에서 딱 한 번만 쓰인다.
		ex) select Cn1, distinct Cn2 from Tn는 에러뜸.

count() (in select)
	count from Tn;

order by
	order by a asc, b desc, ...;
	asc : ascending(오름차순)
	desc : descending(내림차순)

★ select문 순서
select Cn1 as "St1", Cn2 as "St2"
from Tn1 as "St3", Tn2 as "St4"
where Jo1 and/or Jo2 and/or Jo3
group by Cn3 having "%St5%"
order by Cn4 asc/desc
limit Int;

====================

Database
	★table
		column |
		data ㅡ
	data type
		int
		varchar(1~Int)
		char
		date
		time
		datetime
		timestamp
		year

---	

in DBMS
	mysql
	sys200521 목요일 수업 메모 정리

금욜요약
테이블에 있다 = 계속 저장하고 있다
서비스에 필요한 데이터들을 저장하는 것 = 데이터베이스
껐다 켠다고 데이터가 사라지지 않는다. 살아있다.
한번 지우거나 변경하면 복구가 귀찮음.
덤프 : 테이블과 함께 그대로 백업파일을 만드는것
일반 개발자들은 슈퍼관리자가 계정파주면 그걸로 접속.
몇개의 데이터를 그룹핑했는지 


기타
시험에 설치 방법도 들어있음.
  포트입력 등이 아닐까 싶음
로컬 연결(지역연결)과 리모트 연결(원격연결)은 다름.
데이터베이스나 서버 접속시 호스트네임(아이피주소)를 알아야 한다
포트 : 아이피를 구별하기 위한 번호
root 최상위계정
  보안상 이유로 루트 계정은 네트워크 로그인이 안 되게 막아놓은 게 일반적.
  리모트 연결할 때는 안 쓴다는 뜻.

데이터베이스는 뭘로 접속했는가
워크벤치로 접속하고 워크벤치로 작업했다.
SQL문으로 작업했다.

★ 데이터베이스 : 논리적 묶음
  데이터베이스는 "테이블"이 9할. 앱 개발자한테는.

지금 배우는 것 중에서 SQL문이 핵심이다.

툴에서 데이터 확인하기
  툴 : 왼쪽 창
  데이터 확인 :  테이블 선택하고 우클릭 > select lows > sql 셀렉트문 아니어도 바로 데이터들을 불러올 수 있음.

use 쓰고 테이블 치면 왼쪽 툴에서 굵은 글씨로 표시됨.

번개마크 i 는 한 줄만 실행. Ctrl+Enter
그냥 번개마크는 전체를 순서대로 한번에 쫙 실행.

어떤 데이터베이스에 들어간(use) 상태로 다른 디비 테이블에 접속하고 싶을 때
  다른디비이름.거기서보고싶은테이블이름
  . (점)으로 나눠서 적으면 현재 데이터베이스를 나가지 않고 조회(셀렉트) 가능 ㅇㅇ 셀렉트에서 사용
  나중에 작업할 때 어디 디비에 접속했는지 모를 수 있으므로 보통 디비명.테이블명으로 쓴다.

워크벤치는 가져온 데이터를 눈으로 볼 수 있게 해주는 것.

쿼리문, SQL의 Q. 쿼리한다고 말함.

★셀렉트문
200521 목요일 수업 메모


select ~~~는 셀렉트문이라고 부름.
셀렉트 : 데이터를 가져와라.

★★★ 실행은 from부터

!! 중복 제거한 컬럼과 다른 컬럼까지 보여주는 기능
  원래는 그렇게 못 봄. 중복 제거한 컬럼만 보여줌.

시티테이블에서(from) 어느 컬럼에서 kor만 가져오고(where) 그걸 특정 컬럼을 기준으로 정렬해라(order by) 어떤 기준으로(asc, desc)

select count(*) from city where CountryCode = "KOR";
컨트리 코드의 총 "개수"를 구해라 (★컬럼값 합산 아님 주의)

최대값최소값토탈평균값

select * from city; 시작은 항상 이렇게 해서 데이터컬럼을 띄워놓고 데이터를 보면서 작업하는 것임

★ 컬럼의 최소값 찾기 min()함수
select min(Population) from city;
전체 시티 테이블 안 팝퓰에서 가장 적은 수를 구함
팝퓰은 컬럼이름

경기도 중에 최솟값 구하기
select min(Population) from city where District = "Kyonggi";
최소로 되어있는 도시를 찾는 것(보는 것)은 여기에 쿼리 한 줄 더 쓰면 됨.
!! 

★ 최대값 max()함수
select max(Population) from city;
도시의 최대 인구수 찾기

한국의 최대 인구수 찾기
select max(Population) from city where CountryCode = "KOR";

★ 토탈값 구하기 sum() 함수
전세계 도시의 인구수 합한 값 구하기
select sum(Popualtion) from city;

★ 평균 구하기 avg()함수
select avg(Population) from city;

한국 도시의 인구의 총 합과 평균을 컬럼으로 나타내기
두개를 동시에 보여달라? ㅇㅇㅇ
함수 두 개 가져올 때도 ,로 나눔
★ 함수도 , ,로 나눌 때 적은 순서대로 보여줌
select sum(Population), avg(Population) from city where CountryCode = "KOR";

; 잊지 말기 ;;;;;;;;;; 세미콜론

SQL문에 명령한다고 표현.

★ SQL은 컬럼 이름이 중심

셀렉트 앞이 제일 나중에 사용되는 것 같다.

★★★ 집계문법 group by
중복된 값(데이터가 여러개) : 중복된 값들의 ★각각의★ 합은 어떻게 되는가
이걸 집계해봐라 하는 명령.
예제) 시도를 기준으로 개수를 집계해달라.
select count(*) from city where CountryCode = "KOR" group by District;
예제) 시티에 컨트리코드가 kor인 것만 가져와라. 디스트릭트로 그룹바이해라.
경기도 다섯개를 하나로 만들어라. 만든 것을 카운트를 세라.

예제) 위 명령에서 "어느 도시"가 몇개인지 나타내줘라(골라줘라).
나타낸다? 셀렉트 바로 뒤~
select district, count(*) from city where CountryCode = "KOR" group by District;
//district(컬럼이름)을 먼저 적어서 destrict 컬럼이 앞에 표시됨.

인구수. 인제 숫자 세지 말기
예제) 각 시도별 인구 수(합)을 "각각" 묶은 것을 알고 싶다.
디스트릭트로 합치면서 sum도 해주면 됨.
select district, sum(Population) from city where CountryCode = "KOR" group by District;

★★★ 컬럼 이름 바꾸기 as "별칭(닉네임)"
select District as "시도", sum(Population) as "인구수" from city where CountryCode = "KOR" group by District;
실제 컬럼 이름을 변경하지는 않음.
셀렉트는 사람 눈에 보이는 것만 바꿔줌.
장점 : 복잡한 식을 쓸 때 활용 가능
셀렉트 안, from 옆에도 붙여서 쓸수 있음.
★ 한 문장 안에서만 쓰임. 쓰이고 휘발됨.
함수도 as로 별칭을 추가할 수 있음.
별칭은 셀렉트 바로 옆에서 지정.

SQL은 한문장 한문장씩 별개임.

테이블을 쪼개는 조인. 분리 자주 함. 성능때문에.

함수도 컬럼이라고 부름.

★★★ having
도시를 합칠건데(group by) 합한 개수가 6인 것을 구함
그룹바이를 하되 거기서 6개 있는 것들만 가져와라.
select District, count(*) from city where CountryCode = "KOR" group by District having count(*) = 6

예제) 각 시도별 갯수가 가장 많은 것부터 적은 순으로 가져오기
select District, count(*) as cnt from city where CountryCode = "KOR" group by District order by cnt asc;
select *, count(*) as cnt from city where CountryCode = "KOR" group by District order by cnt asc;

예제) 한국 각 시도(그룹바이)의 인구수 총합(썸)을 내림차순으로 정렬(오더바이)한 데이터. 해결 :)
select *, sum(Population) as sum from city where CountryCode = "KOR" group by District order by sum desc;

웨어문 빼면 조건이 없으므로 조건으로 거르지 않은 전체 컬럼이 출력됨.

Q.
번개i 단축키 : 컨트롤 엔터
순서대로 다 전체 실행시키고 싶다. 단축키는 검색해보세여.

as에서 뭐는 ""이거 안에 적고 뭐는 그냥 cnt 이렇게 적고의 차이 : 데이터 타입의 차이인 건가? 앞에서는 "sum"적고 뒤에 활용할 때 sum으로 적었는데도 적용이 되는 이유는?
A. 데이터 저장값에만 "" 붙임.
컬럼이름 나타낼 땐(예시 : as) 컴파일러가 잘 돌아가도 ""안에 안 씀.
제일 위에 컬럼 빼고 다 데이터. 그 중 문자열을 불러낼 때 ""를 쓰는 거임.
as 옆에 한글 절대 쓰지 말기. 처리 안됨(실행은 되는데 컴퓨터가 나중에 처리를 못함).

셀렉트 옆에서 중복 거르는 것(distinct)과 그룹바이의 차이 : 거른 걸 디스팅트한 것만 보여주느냐 그룹바이해서 다른 컬럼들이랑 같이 볼 수 있느냐의 차이인가??
A. 그룹바이는 묶어서 sum(연산) 등을 함
디스팅트는 연산 같이 안 쓰고 중복 제거만 해줌.
예시) 회사에 접속한 기록 카운트(수)에서 누가 몇번을 중복해서 접속했는지(총 접속 인원수. 접속수 말고) 아이디를 디스팅트해서 순 방문자를 알아볼 수 있음.

혼자 해봄 : 파퓰레이션으로 묶은 걸 이름 중복 제거해서 보여줘라...??
select distinct Name as "이름" from city group by Population;

★★★ having
select district, count(*) as cnt from city where CountryCode = "KOR" group by District having count(*) = 6;
시티 옆에 한국 데이터를 가져와서 디스팅트를 그룹바이하고 그룹바이한 것 중에서도 카운트가 6으로 된 것을 가져와라.

count(*)의 의미..?

코드는 나혼자 보는 게 아니므로(나 혼자 보는 거여도) 보기(해석하기) 쉽게 써야한다.

워크벤치는 테이블 만들 때 씀. 쿼리문이 잘 동작하는지 실행시켜볼 수 있음. 잘 실행된 쿼리 한 줄을 서버에 복붙하는 거. 테스트용.
서버 실행하기 위한 보조 툴. 앱 개발시 연동되는 게 아님.
서버쪽 코드를 개발하기 위한 용도.

셀렉트 문법대로 쓰십쇼.
select district, population from city where countrycode = "KOR" group by district;
상황에 따라 오답 혹은 정답이 될 수 있음.
지역을 그룹바이. 같은 지역이 10개면 지역을 하나로 표시하는 것.
그룹바이는 묶기만 하라는 거임. 팝퓰레이션은 걍 아무 처리도 안 하고 가장 앞(위)에 있는 데이터 가져온다.

안되나염. 되는지 안 되는지 해보세여.
이게 이걸 하려고 이걸 썼는데 이게 되는 줄 알았는데 왜 안되나여.
안 될 때 물어보세여.

별표 * 어떻게 나오는지 연습필요할듯.

count(*) as cnt 이거는 거의 공식.
개수 구해라 하면 카운트~~

★★★ having
select district, count(*) as cnt from city where countrycode = "KOR" group by district having cnt >6;
★★★ 해빙은 그룹바이가 있을 때"만" 같이 쓸 수 있음.
이거를 정렬(오름차순)
select district, count(*) as cnt 
from city 
where countrycode = "KOR" 
group by district having cnt >6 
order by cnt asc;
asc 안 붙여도 오름차순임.
★★★ 이 문법 순서 외워야 함.
각 키워드의 순서를 잘 기억해야 함.
보통 문법은 맨 앞에 오는 것과 관련된 문구를 한 줄에 묶어서 표시함.

CRUD
c : create
r : read <-우리가 한 거. 데이터 불러온 거 읽은 거(보여준 거) 셀렉트문.
u : update <- 값 변경. 업데이트문.
d : delete
데이터베이스는 이 crud 기능을 기본적으로 제공함.
데이터베이스? 데이터?는 파일이라고 생각하면 됨. 파일은 계속 하드디스크에 저장되어 남아있음.

★ 데이터를 가져오는 게 셀렉트다.

select * from city where countrycode = "KOR" and district = "Kyonggi";
한국과 경기를 만족하는 조건만 동시에 표시
데이터가 잘못 저장되어있을 때(오타 등) 수정하기
예시 ) shihung => shiheung으로 바꾸자.
update city set name = "Shiheung"
	where countrycode = "KOR" and
	district = "Kyonggi" and
	name = "Shihung";
이 값의 위치(해당 행(데이터))로 가야하는 것이 제일 먼저임.
바꾸겠다 = 업데이트
시티(테이블)에서
이름을 ""으로 이렇게 바꾸겠다
이 뒤를 안 써주면 전부 다 앞에 쓴 이름으로 바뀌므로 주의. 위치를 명시를 꼭 해줘야 함.
위 예시는 조건이 세 개임.(경로 찾아간 거임)
시흥이 하나만 있으면 다른 조건 안 쓰고 이름만 써도 됨. 하나만 있는지 알아보고 싶으면 셀렉트로.
마지막 앤드를 빼면 경기와 kor을 만족하는 name이 전부 시흥으로 바뀜.
데이터 잘못 바뀌면 답이 없음. 뒤로 못 돌림.
그래서 항상 덤프, 백업을 해두는 것임.
복구 소스코드 불러오는 방법.. 덤프 뜬 거 가져와서 임포트하면 됨.
★ 위 예시의 값을 확인하려면 select로 찾아서 봐야 함.
select * from city where countrycode = "KOR" and district = "Kyunggi";

인구가 잘못돼서 바꾸자.
한국-경기-시흥의 인구를 133445로 바꾸자.
여기서 아이디가 중복되는 게 없으면(★데이터가 하나면★) 아이디를 사용해도 됨.
select * from city where id = 2383;
여기의 인구 데이터를 바꿈
update city set population = 133445
where ID = 2383

아이디의 필요성. 간단하게 데이터 골라서 바꿀 수 있음.

셀렉트 코드 복붙 안 해도 됨. 하려는 작업이 같으면 아까 적어놓은 작업에 커서 갖다대고 컨트롤 엔터 누르면 됨.

컬럼 이름 대소문자 안 가림.

줄 순서 상관없이 실행하는 건 

아이디는 유니크하게..?

--------------------------------------------
셀렉트는 윗줄에 있고
업데이트는 밑줄에 있을 때

아까는 밑에 있는 업데이트 먼저 실행하고
위에 있는 셀렉트를 실행한 건데
커서를 포함한 한줄씩만 실행하게 되니까
그렇게도 작업이 된다는 이야기인 거 같고(순서 상관없이 한줄씩만 실행해서 원하는 작업 가능)

전체를 순서대로 실행하는 걸 누르면
셀렉트로 표현 먼저 하고
업데이트로 바꾸게 되니까
일단 셀렉트문으로 바뀌기 전이 표현되고
업데이트는 그 뒤에 되는 거니까 값이 표현되지 않고 바뀌기만 하는 거고
전체를 실행하는 아이콘으로 업데이트한 값을 보고 싶으면
업데이트 밑에 셀렉트문을 추가하면 되는 건가

★같은 데이터를
셀렉트문->업데이트->셀렉트문 이렇게 적고 전체를 실행하는 버튼을 누르면 결과는 어떻게 표시되지?
마지막 셀렉트만 표시되나? 
ㅇㅇ!
다 처리되고 마지막 줄(결과)만 표시됨.
--------------------------------------------

업데이트문으로 값 한 번 바뀌면 실제 저장소의 값도 바뀌는 거임.

★update 테이블명 set 바꾸고싶은컬럼 = 바꿀 내용
	where 바꾸고 싶은 데이터(들)의 경로(위치);★
경로 범위 신경써서 세심하게 지정해주기.
경로로 갔을 때 데이터가 하나뿐이면 아이디 경로 적어주면 됨.

예제) 안양 데이터를 KOR이 아니라 ENG로 바꾸고 인구수를 591110으로 바꿔라.
여러개 같이 바꿀 때는 역시 , 로 구분.
update city set CountryCode = "ENG", Population = 591110
	where ID = 2341;
근데 컨트리 코드는 못 건드리게(바꾸게) 해놨음.
안양의 이름을 안양2로 바꾸는 걸로 예제 변경.

테이블을 정의한 것 : 스키마!

★ crud중 create 해보기 (실무에서 많이 쓰는 거)
데이터 새로 넣기
데이터 한 줄 추가하기
새로운 도시추가하기
시티에는 다섯개 컬럼이 있어야됨.
이것도 한 번 데이터 넣으면 넣은 상태로 계속 지속이 됨. 저장된다는 뜻.
insert into city
	values(DEFAULT, "Gimpo","KOR","Kyonggi",359584);
시티 테이블에 데이터 넣겠다는 뜻.
초기에 컬럼이 나열된 순서대로 데이터를 입력해야 함.
아이디는 일단 디폴트로 설정하면 알아서 순서대로 아이디를 지정함.
insert into city
	values(DEFAULT, "Hwagok","KOR","Kyonggi",50000);

예제) 데이터 김포의 디스트릭트를 abc로 바꿈.
화곡의 디스트릭트도 abc로 변경.
하나씩하나씩 따로 만들기.

select * from city where ID = 4081;

예제) 데이터 두 개를 같이 업데이트하기
두 지역의 인구수를 동시에 10만으로 변경
소속은 상세히 적는 것이 좋음.
update city set Population = "100000"
	where CountryCode = "KOR" and District = "abc";
바꾸려는 데이터들의 공통점을 잘 생각해볼 것.

업데이트문은 조심해서.

★ crud의 d(삭제) 딜리트문
delete from city where ID = 4080;
조건명시
웨어 안 쓰면 시티 안의 내용 다 지워버림.
웨어라는 조건식을 조심조심 처리해야 함.

샘플 테이블 만들기
create database emp_test
default character set UTF8;
이엠피테스트가 테이블 이름임.
치고 거기에 커서대고 엔터하면 이엠피 테스트 "데이터베이스" 만들어짐.
문자 처리는 UTF8로하면 세계공통표준.안드로이드개발도이걸로함
문자처리를유티에프8로 하겠다
이엠피테스트로이동(use)
강사님 페이지에 12번
크리에이트 3개만 복사
맨 왼쪽 파일아이콘 버튼 클릭해서 에스큐엘 생성
최상단에 이거 붙여넣기쓰기
유즈이엠피 컨트롤엔터 치는 거 잊지말기

뎁테이블에는 컬럼세개를만들겠다
테이블이름은 우측
컬럼이름은 좌측
이엠피는 직원정보

드랍테이블 테이블 지우는 거

새로고침 눌러야 만든 거 뜸.
여기까지 디비랑 테이블 만든 거

새 에스큐엘파일만들기
방금작업한거냅두기
빈파일에 셀렉트
select * from dept;
널 : 데이터없음
새 파일에 업로딩파일나머지 드래그해서 붙여넣기

커밋은 뭐지commit;

그룹바이 뒤에는 컬럼이름만 표시함

많은 데이터 추가(생성)작업을 한꺼번에 할 때는 그냥 번개아이콘.
전체실행누르고 empinsert로 저장
또 새 에스큐엘파일만들기
새로운데이터베이스에 테이블 만들고 싶으면 데이터베이스 만들기
새로 만든 데이터베이스로 진입
데이터테이블 만듦
새로 만들 때 데이터는 들어있지 않음
그 다음에 데이터를 인서트해줌

파일 잘 들어가있는지 셀렉트로 확인

실행 컨트롤엔터까먹지마셈..
셀렉트만 실행해야 하는 게 아님..
다른 명령어도 적었으면 외면하지말고 컨트롤엔터좀쳐주세오.
웹이든 앱이든 조건문이 많이 쓰이고 중요

★★★ 조건 자아아아아아아아아알 관찰
★★★ 특히 >= <= > < 이거랑 정렬해라 이런거 빼먹지 마로라.
★★★ count(*) 좀 헷갈린다.

컬럼은 데이터의 종류를 분류.

예제)★★★
컬럼이
사번empno, 이름ename, 직급job, 사원번호mgr, 입사일hiredate, 연봉sal, 커미션(보너스)comm, 부서번호deptno일 때

// 사원 이름순으로 정렬하시오.
// 그냥 정렬은 abc순서. 역순은z부터. 오름차순이 asc, 내림차순이 desc.
select * from emp order by ENAME;

// 급여 내림차순으로 정렬하시오.
select * from emp order by SAL desc;

// 급여 내림차순으로, 사원 이름, 급여, 부서 코드를 조회하시오.
뎁트~ : 부서
select ENAME, SAL, DEPTNO from emp order by SAL desc;

// 부서코드 오름차순, 급여 내림차순으로
  사원이름, 급여, 부서코드를 조회하시오.
select ENAME, SAL, DEPTNO from emp order by DEPTNO, SAL desc;
웨어에만 앤드오어있나보다. 여기서는 컴마로 오더바이 나눔.
오더바이가 두개면 앞에서 먼저 정렬, 다음에 그 다음 항목을 정렬.
(테스트해보고 이해하기)

// 이름, 입사일자, 부서코드를 부서코드 오름차순, 입사일자 오름차순으로 조회
select ENAME, HIREDATE, DEPTNO from emp order by DEPTNO asc, HIREDATE asc;
부서번호가 같으면 그 다음에 적혀있는 조건으로 정렬됨.

// 직급 칼럼의 중복을 제거하고, 하나씩만 나오도록 하시오.
select distinct JOB from emp;
select JOB from emp group by JOB;
위 두개는 같은 결과.

// emp테이블의 job 오름차순, sal 내림차순 정렬하여 ename은 이름, job은 직급, sal은 급여로 컬럼명을 변경해서 ★조회(셀렉트)★하시오.
select ENAME as 이름, JOB as 직급, SAL as 급여 from emp order by 직급 asc, 급여 desc;
  as 뒤에 붙은 것은 지가 알아서 처리하니까 큰따옴표 붙여도 되고 안 붙여도 됨.

// 급여가 1000아래이고 4000을 넘는 직원을 조회하되 급여 내림차순으로 정리
select * from emp where SAL >= 1000 and SAL < 4000 order by SAL desc;

// 급여가 1000 이하이거나 4000 이상인 직원 검색
select * from emp where SAL <= 1000 or SAL => 4000;

// 직책이 ANALYST이거나 MANAGER인 직원들을 이름순으로 조회하세요.
select * from emp where JOB = "ANALYST" or JOB = "MANAGER" order by ENAME;

// 부서코드가 30인 직원들을 조회하시오.
select * from emp where DEPTNO = 30;

// 부서코드 종류가 몇개인지 확인하시오
select distinct DEPTNO from emp;
select deptno from emp group by deptno; 이거는 위와 같은 결과 나옴
select count(*) from emp group by deptno; 이거는 일부러 틀어준 다른 예시임

// 부서코드가 10이거나 20이거나 30인 직원 조회.
select * from emp where DEPTNO = 10 or DEPTNO = 20 or DEPTNO = 30;
이걸 새로운 방법으로 검색하기 새로운 문법으로
select * from emp where DEPTNO ★in (10, 20, 30);★ <<외워야하는 거
deptno에서 10,20,30안에 있는 것들을 다 가져와라. ★
여기서 , 은 or와 같음. 이거는 앤드연산 아님 주의 ★
deptno = 10, deptno = 20, deptno = 30을 말하는 것과 같음.
>=나 <=로는 쓸 수(활용할 수) 없음. 

// 급여가 3000~5000인 직원을 조회
select * from emp where SAL >= 3000 and SAL <= 5000;
// ★ 컬럼이름 between ~ and ~ ★ 많이 쓰는 거니까 외우셈.
select * fromm emp SAL between 3000 and 5000;
바로 위 예시와 같은 결과값 나옴. &&, where ~ and ~ 와 같음.

// 커미션이 300, 500, 1400 이 "모두 아닌(&&)" 사원의 사번, 이름, 커미션을 ★조회(셀렉트)★
두가지방법 중 하나
select EMPNO, ENAME, COMM from emp where comm != 300 && comm != 500 && comm != 1400;
두가지방법중 둘 not in 
select EMPNO, ENAME, COMM from emp where comm ★not in (300,500,1400);★<<외워야하는 거

// 총 사원 수를 구하시오
썸아님카운트임..
select count(*) from emp; // 총 데이터개수

// 이 emp테이블에 있는 직책(job)의 목록을 조회.
디스팅트해라.
select distinct job from emp;

// 이름이 KING인 사원을 조회하시오
select * from emp where ENAME = "KING";
//이름이 King인 사원도 조회하시오
select * from emp where ENAME = "King";
원래 대소문자 구분함. 지금은 구분 못함. 설정 중에 뭐가 어떻게 잘못됐나봄. 이라고 강사님이 말함.
실무에서는 다 구분함.

// 사원 이름 중에서 S로 시작하는 사원 번호와 이름을 조회
한글로 데이터 저장되어있었으면 한글 색인도 가능.
사원 이름 중에서 s로 시작사는 사원 이 조건.
검색하기 기능
select empno, ename from emp where ename ★like★ "S%";
"S%" : S로 시작하고 그 뒤는 아무거나 나와도 된다.
  이거 현업에서 많이 씀. 검색할 때.
★이것도 " "안에는 "원래" 대소문자 구분함 주의.

// 사원 이름에 T가 포함된 사원의 사원번호와 이름 조회 ? 해결함
select EMPNO, ENAME from emp where ENAME like "%T%";

// 직급이 매니저이고 부서 번호가 30인 사원의 이름, 사번, 직급, 부서번호를 조회 혼자 해결 :0
select ENAME, EMPNO, JOB, DEPTNO from emp where JOB = "MANAGER" && DEPTNO = 30;

데이터 조회할 때는 컬럼 표현 순서 바꿀 수 있음 항상 유의.

// 위 예제와 연관된 예제
// 부서번호가 30이 아닌 사원의 사번,이름,부서번호 조회
select EMPNO, ENAME, DEPTNO from emp where DEPTNO != 30;
!=와 같은 것(아래 두개 다)
select empno, ename, deptno from emp where not deptno = 30;
select empno, ename, deptno from emp where deptno not in (30);
이렇게(아래처럼)는 쓰지 말자 강사님이 이렇게 써보신 적이 없댔음.
select empno, ename, deptno from emp where not deptno in (30);
그치만 되면 써도 된다 .컴퓨터가 더 정확하니까.

// 이름에 S가 포함되지 않은 사원의 사번, 이름 조회.
select empno, ename from emp where ENAME ★not like★ "%S%";

// 직속 상사가 NULL인 사원의 이름과 직급 조회.
select ENAME, JOB from emp where MGR is NULL;
★★★ MGR is NULL; 널이 뒤에 붙으면 같다고 표시할 때 =이거말고 is를 붙여야 함. 예외문법.

// "부서"별(group by) 평균(avg()) 급여(SAL)를 구하시오.
select avg(SAL), DEPTNO from emp group by DEPTNO;
*, avg(SAL) 하니까 기존 컬럼 전부 나오고 맨 뒤에 avg(SAL) 뜸.
JOB, avg(SAL)로 쓰면 부서만 나눈 거 나옴.
연산해주는 거( 썸, 최대값최소값, 평균) 랑 그룹바이는 친구
★★★★★ 부서랑 직업이랑 다름ㅜㅜ... 주의.. "부""서"를 나눈 건 부서번호임..
★★★★★그룹바이해서 합쳐지는 데이터를 표시해달라고 적은 거면 틀린 거임. 틀렸어 허으으

// sal이 2000 이상인 사원들을 대상으로 부서별 sal 평균을 구하세요.
맞았당.
select avg(SAL), DEPTNO from emp where SAL >= 2000 group by DEPTNO;

문법 나열 순서 중요하다아 순서
그룹바이는 벼어얼

// 부서별(group by deptno) 전체 사원 수(count(*))와, 커미션을 받는 사원 수를 구하세요
(결과컬럼3개)
썸아니고카운트응으
select deptno, count(*) from emp group by deptno // 부서별전체사원수
select deptno as "부서", count(*) as "전체 사원수", count(comm) as "커미션 사원수 " from emp group by deptno; // 이게정답
이코드카피해서서버만들땐에러남. 한글들어있기때문임.
count(*)전체 수
count(comm) 커미션 가진 사람 수

별명만들때 중간에 공백있으면 ""이거 꼭 붙여줘야함.

?? 나중에 문제 낼 때는 조회 조건 붙은 거랑 상관 없는 거랑 구분하실 건지

// 부서별 최대 급여와 최소 급여를 구해서 표시
select DEPTNO, max(SAL), min(SAL) from emp group by DEPTNO;

셀렉트 옆에 나온 걸 표시함.

// 급여가 높은 순으로 조회하되, 급여가 같을 경우는 이름의 철자가 빠른 순으로 사번, 이름, 급여를 조회 (나열 조건이 2개인 경우임)
맞오따
select empno, ename, sal from emp order by sal desc, ename asc;

===========예제끝=============


★★★★★★★★★★★★조인★★★★★★★★★★★★
// 두개의테이블을 하나로 "합쳐서 보는" 것 : 조인
join 여러개의 테이블을 하나로 합치는 것.

dept테이블로 ㄱㄱ

select emp.ename, dept.dname from emp, dept;
프롬 뒤에 테이블 여러개를 쓰려면 , 로 나눔.
★★★ 두개를 합쳐서 보여줘라 라는 뜻.

select emp.*, dept.* from emp, dept;
위와같이 쓰면 안 됨. 이렇게 쓰면 데이터들이 다 곱해짐(?).
그니까 위랑 같이 쓰면
emp 데이터가 4개고 dept데이터가 5개면
emp 데이터 하나당 dept데이터 5개가 붙음.
즉 데이터가 4 X 5가 된다는 뜻임. 왜 그런지는 분석해보자.
일단 공통되는 컬럼을 찾는다.
실무에서는 공통되는 컬럼을 ★매칭★시켜 완성된 테이블을 만든다.


★★★ 이하 중요한 예시
select emp.*, dept.* from emp, dept where emp.deptno = dept.deptno;
where emp.deptno = dept.deptno;
 // 두 테이블에서 "공통된 컬럼만 묶어서(조건)" 하나의 테이블에 보여줘라. 합쳐서 보여줘라.
공통된 정보(저장하는 데이터가 부서에 대한 번호를 저장하는 공통점)이 있으면 컬럼 이름 달라도 됨. 이름보다는 
이거는 각 테이블에 있는 deptno끼리 "연결" 되어서 같은 데이터가 "매칭"된다.
예시) emp.deptno에 20이 있고 dept.deptno에 20이 있으면 이거끼리 연결되고 이것과 연결되는 다른 데이터들도 같이 가져와진다.
예시 이해를 돕기 위한 예시) emp테이블에 있는 ename 컬럼에 "david"라는 데이터가 있고 이 데이터의 deptno컬럼 값은 20이다. dept테이블에 deptno가 20인 것이 있고 해당 데이터의 지역 컬럼 데이터가 "seoul"인 것이 있을 때,
emp와 dept가 deptno로 연결되었을 때 가져다 주는 정보는 ename "david", deptno 20, 지역 "seoul"이 ★★★한 줄★★★에 합쳐져서 출력되는 것이다!!!!!!!!!!!!!! 이게 쪼인이다!!!!!!!!!!!!!!!!!!!!!!!

뭔뜻이여.
즉 연결고리 컬럼 하나(deptno)로 두가지 테이블을 연결해서 한번에 보여주는 것.

========================================

select * from emp;
select * from dept;
테이블들은 각각 개별적으로 돌아가기 때문에 내용이나 컬럼 이름 등이 겹칠 수 있다.
★★★ 그러므로 .Cn 앞에 테이블 이름(Tn)을 적어서 컬럼이 소속된 곳을 명시해주는 게 정확하다.
emp 사원정보 담은 테이블(중요정보아님)
200521 목요일 수업 키워드

Cn = 컬럼 이름
Tn = 테이블 이름
Dn = 데이터베이스 이름
Jo = 조건문
Ha() = 함수
St = 문자열
Int = 정수
Dt = 데이터 타입

---

Schema

=====★ SQL (Query)=====

-----	in ★select	-----

min() 
	min(Cn)

max() 
	max(Cn)

avg() 
	avg(Cn)

sum() 
	sum(Cn)
	
count()
	count(Cn)
	왠만한 경우는 거의 count(*)로 쓴다.

---------------------

★★★group-by
	group by Cn;
	group by Cn having "A";
		"A"  =>  "%St%", "St%", "%St", "St"
	GROUP BY를 사용하는 경우, SELECT할 수 있는 컬럼은 GROUP BY에 나열된 컬럼과 SUM(), COUNT() 같은 집계 함수(Aggregation Function)으로 한정된다.
	
★order-by
	order by Cn asc;
		asc	=>	1 > 10, A > Z
	order by Cn desc;
		desc	=>	10 > 1, Z > A

from-Tn1, Tn2
	연관없는 테이블들을 한번에 조회하고 싶을 때
	(연관있는 테이블들을 where로 붙여 쓸 수 있지만 잘 쓰이지 않음)

as
	A as B
		A  =>  Cn, Tn
		B  =>  St, "S  t", Int
	
★★★where in-(), where not-in-()
	where Cn in (a1, a2, ...);
	where Cn not in (a1, a2, ...);
		a	=>	"St", Int
		where in = where or
	
★★★between and
	1. where Cn between A and B
		A & B  =>  Int, Tn.Cn
	2. from Tn1 join Tn2
			on Tn1.Cn1 between Tn2.Cn2 and Tn2.Cn3

where-not
	where not Cn = a;
		a  =>  "St", Int, Ha(), Cn
	"where Cn not = a;" are same
			"where Cn not in (a);"  and  "where Cn != a;"

null
	is null
	is not null

-----  CRUD  -----

CRUD
	C : create & insert
	R : read(select)
	U : update
	D : delete

★create
	create database Dn;
		default character set UTF8;
	create table Tn1 (
		Tn_id Int not null auto_increament primary key
		Cn1 Dt
		Cn2 Dt
		...
	);

★insert-into values
	insert into Tn (Cn0, Cn1, Cn2, ...) values ( a, b, c, ...), (d, e, f, ...);

★update set
	update Tn set Cn = a;
		a  =>  "St" or Int
	update Tn set Cn1 = a, Cn2 = b, ... where Jo;
		update의 경우 CPU가 where먼저 처리하는 것에 유의.

★delete-from
	delete from Tn;
	delete from Tn where Jo;
		Jo ex)  =>  Cn = Int; Cn != "St"; ...

★drop
	drop Dn;
	drop Tn;
	
--------------------

====================


200522 금요일 수업 메모 정리

자잘정보
디비 정보는 주기적으로 백업도 하고 업로드고 하고 그런댔음.
작성한 SQL을 실행(Ctrl+Enter) : 쿼리가 실행된다고 표현함.

중요한 정보(전에 배운 거 기준)

오늘 처음 배운 거

200522 금요일 수업 메모

백업과 업로드

백오피스 : 관리자

여기서 작성한 게 실행된다 = 쿼리가 실행된다고 표현.

스키마 뜻 검색

첫 접속은 어느 데이터베이스에도 접근이 안 된 상태.
use~를 실행을 시켜줘야 실행된다.

그룹바이는 묶어서 처리한다.
묶을 컬럼을 그룹바이 옆에 적음.

INSERT INTO 데이터를 넣을 때 사용하는 SQL
INSERT INTO song (_id, title, lyrics)
	 VALUES (101, 'Tell Me', 'tell me tell me tetetete tel me');
song 테이블에 이 순서대로 컬럼을 넣겠다
그리고 거기에 해당하는 값은 value 뒤에 넣겠다

문법은 법칙. 그대로 따르면 해결 가능.

뭘 조회할지는 나중에 결정. 고로 셀렉트에는 * 붙여놓고 나중에 수정.
조인 온은 연결고리.

★★★★★★
1. 조건이 해당되는 테이블 먼저 찾기(이거저거 조회하기)
2. 조건(where) 적기 전에 포함되는 테이블들 묶어서(join on) 전체 조회(select * from) 먼저.
★★★★★★

★★★★★★★★★
SQL에서 select 문법 적는 순서
크게 "조회 범위 조건 그룹 정렬 컷팅"인 것 같음.
★★★
조회 : select, distinct, as
범위 : from, join on, left join on, as
조건 : where, and, between, or, in (), not in (), not, like "%", not like "%"
그룹 : group by having Jo
정렬 : order by asc/desc
컷팅 : limit Int
★★★★★★★★★

★★★
조건에 해당되는 DB나 테이블이나 컬럼은 무엇인지,
합칠 테이블은 무엇인지,
그 안에서 비교할 컬럼은 무엇인지 잘 찾는 게 중요한 거 같다.
★★★

----------
데이터베이스 만들기
테이블들을 저장할 폴더를 만든다고 생각하기.
create database songs;
songs라는 데이터베이스를 만듦.
use songs;
songs 데이터베이스로 이동.
그 안에 테이블 만들기
create table~~을 실행
여기서 전체실행하면 크리에이트 디비랑 유즈송이 중복되서 처리되지 않음.
두줄은 주석처리해놓고 돌리면됨.
데이터 잘 들어있는지 확인하기 : 테이블 우클릭 - select rows
----------

---------- ★★★ .(점) 쓰기 :: 조인에서 활용 
테이블을 두개 이상 쓸 때,
★★★ 그냥 테이블 이름만, 컬럼 이름만 적었을 때 이게 어디 데이터베이스 소속, 어디 테이블 소속인지 알 수 없을 때에는 실행시 에러가 난다.
그래서 테이블 이름이나 컬럼 이름 왼쪽에 .을 붙여서 그 옆에 데이터베이스 이름 or 테이블 이름을 적는 것이다.

★★★ 조인의 on에서 쓰는 . 왼쪽이랑 from 옆에 쓰는 . 왼쪽이랑은 다름.
조인에서 on 오른쪽에 붙는 건 ★ 테이블 이름 . 컬럼이름 ★
프롬(조인포함) 오른쪽에 붙는 건 ★ 데이터베이스 이름 . 테이블이름 ★

from 옆 .(점) 설명
앞에 데이터베이스 이름 적고 .테이블이름 이렇게 하면
어느 데이터베이스에서도 다른 데이터베이스 테이블에 접근 가능
다른 데 말고 from 옆에만
----------

커서 맨 앞에 두고 컨트롤 슬래시 = 주석처리 --

테이블은 틀, 껍데기.

컬럼 column


★★★ """"""비교하는 테이블 안""""""에 컬럼 이름이 겹치는 게 없으면
컬럼 이름 앞에 테이블. 붙이지 않고 그냥 써도 됨.
from에서 가져온 테이블들 안에서 겹치는 게 없으면 됨.
그 범위 밖에 있는 테이블들은 아아아아아아무 관련이 없음.


csv comma seperated values
데이터가 ,나 ;로 연결된 파일
글로벌 포맷

★★★ 셀렉트는 나중에 보여줄 컬럼만 조회해주는 기능이므로
SQL을 작성할 땐 from부터 다 적고 나서 마지막에 조회할 컬럼(select)를 적어준다.

순서만 잘 지키면 어렵지 않다.

===============

★★★ Join(조인) ★★★
조인하다.
★매★칭★
일반적 조인(디폴트)은 이너 조인.

테이블의 구조를 알아야 조인을 할 수 있다.
테이블의 구조를 보는 것 : 스키마?

유니크하다 = 중복데이터가 없다

이어질 수 있는 정보들이 두개의 테이블에 나뉘어져(분리되어)있을 때
두 테이블에서 연관되어있는 데이터를 연결해서(이어서) 한 곳에서 한번에 볼 수 있는 것
이 때 데이터 내용간 연결고리(데이터 형식, 데이터가 의미하는 내용)가 있어야 함

소속된 테이블의 컬럼 옆에는 소속 테이블을 보통 잘 안 적어줌.

두 테이블을 연결시키는 게 on의 역할.
on 뒤에는 연결고리가 될 컬럼들(공통된 데이터가 있는 컬럼)을
on 뒤에 = 로 연결해서 적는 것.
차피 연결고리는 같으므로 ""레프트 아우터 조인""의 테이블 위치가 바뀐다고 온 뒤에 오는 컬럼들 위치가 바뀔 필요는 없다. 사실상 바뀌나 마나 상관없음.

★★★Join 문법 요약(2개 연결)★★★
select 테이블.보여줄'컬럼', 테이블.보여줄'컬럼'
from 디비.연결할'테이블' as '요약어'
Join 디비.연결할'테이블' as '요약어'
on 테이블.연결할'컬럼' = 테이블.연결할'컬럼';
★★★★★★★이하 설명★★★★★★
선행 : 각각의 테이블에 무슨 컬럼과 데이터가 있는지 알아야 함
  >> select * from 디비.조회할'테이블' << 필요할 때마다 계속 조회
★ 1. 연결할 컬럼에 핵주의
  연결하는 컬럼끼리 매치되는 데이터가 없으면 데이터 표시안됨 핵주의
    left join 제외
  각각의 테이블에 공통점이 있어도 일치하지 않는 데이터 컬럼들끼리 연결을 하면 아무 데이터도 표시되지 않음
    ★ 데이터들이 얼핏 보기에 일치한다 하더라도(ex. ~_id는 전부 정수) 연결고리를 잘못 찾아 연결하면, 조회가 될 수는 있지만 원하는 데이터를 제대로 조회한 것은 아니다.
★ 2. 연결할 테이블에 주의
  각각의 틀(테이블) 안에 연결할(연결되는) 컬럼이 있어야 함
★ 3. 보여줄 컬럼에 주의
  from에서 만든 테이블 요약어(as ~) 쓸 수 있음
★★★★★★★★★★★★★
★ 강사님 설명(내가 이해하기 쉽게 변경)
  내가 찾을 정보와 관련된 "테이블"을 찾아 전체 "컬럼"을 select해서 조회한다.
  찾는 정보가 ""하나""의 테이블에 있는지 확인한다.
  하나의 테이블에 존재하면, 테이블 ""하나만"" select하고 (어제까지 배운 거)
  여러 테이블에 존재하면, join을 사용하여 select한다. (오늘 배운 거, 테이블 연결)
★★★★★★★★★★★★★

--예시 테이블을 활용한 설명--
경로 : https://github.com/blockenters/android에서 sample db (join)
---------- (1)
select girl_group.*, song.*
from girl_group
join song
on girl_group.hit_song_id = song._id;
---------- 분석
from girl_group join song
★ girl_group을 song과 join한다. ★

on girl_group.hit_song_id = song._id;
두 컬럼(테이블)을 매칭해서 엮어라
on 말고 where로 쓸 수도 있다(똑같이 나온다) 오리지날은 on이다.
웨어문법은 옛날에 나온 거. 조인 종류 여러가진데 웨어로 쓰면 이게 무슨 조인인지 헷갈림.
----- (2) 위 내용의 이해를 위한 예시
select girl_group.*, song.*
from girl_group, song
where girl_group.hit_song_id = song._id;
----- 분석
(2)에서는 join on이 없지만 join on을 쓴 것과 같이 나온다.
(1)과 (2)의 결과물은 같지만 요새는 join ~ on ~을 쓴다.
★ 조인은 그냥 (1)의 방식으로 쓰는 걸로 알아두면 됨.

select girl_group.*, song.*
테이블이 두 개 이상일 때(★조인★ 등등에서 쓸 때)는 그냥 별*만 쓰면 안되고 해당 테이블명.* 이렇게 써야한다. 셀렉트 옆에서!
다른 테이블의 두 컬럼을 다 표시하고 싶으면 위와같이 쓰고 콤마로 구분.

붙인 것의 결과 :: (1)의 결과
1 원더걸스 2007-09-12 101 101 Tell Me tell me tell me tetetete tel me
...hit_song_id랑 _id랑 붙여서 나올 수 있는 데이터들은 다 나옴.

----- (3) 명칭 줄이기(내용은 1과 같음)
select g.*, s.*
from girl_group as g
join song as s
on g.hit_song_id = s._id;
----- 분석
약자를 만들어줘서(as) 테이블 명칭을 축소,
이후의 문장을 간략하게 만들 수 있다.
문장 분석 시작은 from부터이기 때문에
'보이는' 문장의 시작인 select 옆에 축약어 g나 s를 적어줘도 먹힌다.

----- 조인 예제
-- 걸그룹 이름(girl_group.name)과 노래 제목(song.title)을 조회하시오.
select g.name, s.title
from songs.girl_group as g
Join songs.song as s
on g.hit_song_id = s._id;
-----
★ 연결할 컬럼에 주의
★ 연결할 테이블에 주의
★ 보여줄 컬럼에 주의

-- 가수 이름, 데뷔날짜를 조회하세요.
select name, debut from girl_group;

-- 데뷔 날짜가 2008년 1월 17일인 그룹의 이름과 데뷔날짜를 조회하세요
select name, debut
from girl_group
where debut = "2008-01-17";
-- 결과
name debut
브라운아이드걸스 2008-01-17

-- 데뷔 년도가 2009년 1월 1일 이후에 데뷔한 그룹의 이름과 데뷔날짜, 노래제목을 조회하세요.
select g.name, g.debut, s.title
from songs.girl_group as g
Join songs.song as s
on g.hit_song_id = s._id
where debut >= 20090101;
-- 분석
프롬이랑 조인은 한쌍잉게 거기 사이에 웨어 넣지 마라.
조인이랑 온은 한쌍잉게 거기 사이에 웨어 넣지 마라.
결론은 프롬+조인+온 한쌍이고 웨어는 프롬 뒤에 와야하니까
웨어 위치는 (프롬+조인+온) 웨어. 조건이 맨 마지막에 들어감.

부등호 옆에 날짜 쓸 때 되는 것 vs 안되는 것
날짜비교는 --붙이지 말고 그냥 20090101 이런 식으로 적는다. ""는 붙여도 되네. "2009-01-01" 이것도 되네. 2009-01-01만 안됨.
부등호 잘 적어라!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

-- 이름에 "스"자가 들어가는 걸그룹의 걸그룹 이름과 데뷔날짜, 타이틀을 조회하세요.
select g.name, g.debut, s.title
from girl_group as g
join song as s
on g.hit_song_id = s._id
where g.name like "%스%";
-- 풀이
where 테이블.컬럼 like "%찾을 거%";
★★★ 웨얼~라이크~ 들어있는 숫자 문자(데이터!!!!) 찾을 때

-- 데뷔 년도가 2008년 5월 1일 이후에 데뷔한 그룹의 이름과 데뷔 날짜, 노래 제목을 최근 데뷔한 걸그룹부터 조회하세요.
최근 데뷔한 걸그룹 (order by g.debut desc)
그룹의 이름과 데뷔 날짜, 노래 제목을 조회하세요. (select g.name, g.debut, s.title)
데뷔 년도가 2008년 5월 1일 이후에 데뷔한 (where debut >= 20080501)
조회하려는 컬럼들은 각각 다른 테이블에 있으므로 조회 영역을 가져올 땐 (from girl_group as g join song as s on g.hit_song_id = s._id)
-- 조합
select g.name, g.debut, s.title
from girl_group as g
join song as s
on g.hit_song_id = s._id
where debut >= 20080501
order by g.debut desc;
-- 분석
테이블 조인 할 때는 프롬에 ,(콜론) 붙여서 "테이블, 테이블"로 나누지 말고
"프롬 테이블 조인 테이블 온" 이렇게 쓰셈.
그거 말고는 잘한듯.

======================

★★★ 레프트 아우터 조인( left outer join )
데이터 매치되는 거 없는 애들도 표시하고 싶을 때 사용
레프트 조인 왼쪽에 적은 테이블은 다른 테이블과 겹치는 게 없어도 전부 다 살린다.
대신 매치되는 데이터가 없는 컬럼을 조회(select)할 땐 없다고(null) 표시해라.
--- (4) 레프트 조인 예시
select g._id, g.name, s.title
from girl_group as g
left join song as s
on g.hit_song_id = s._id;
--- (5) 레프트 조인 예시
select g.*, s.*
from song as s
left join girl_group as g
on g.hit_song_id = s._id;
-----

★★★★★★★★★이거 두 개 분석(아직 이해 덜됨)
-- 걸그룹 중에서 히트곡(노래 타이틀)이 없는 걸그룹의 걸그룹 이름과 데뷔날짜를 조회하세요.
-- (6) 내가 쓴 거
select g._id, g.debut  -- 걸그룹 이름은 g.name임
from song as s
left join girl_group as g
on g.hit_song_id = s.id
where g.hit_song_id is null;
-- (7) 강사님 답
select g.name, g.debut
from girl_group as g  -- "걸그룹 중에서" : ★전체★ 걸그룹이 ★조회★되어야 하기 때문에 girl_group as g가 이 자리에 와야 함.
left join song as s  -- 노래타이틀을 봐야하기 때문에 해당 컬럼이 있는 송을 연결
on g.hit_song_id = s._id
where s.title is null;
-- 분석
null이 표시된 항목을 조회하려면

-- 노래 피노키오를 부른 가수의 이름을 조회하세요.
송테이블왼쪽 걸그룹 오른쪽
일단 모든 노래 항목을 봐야하고 (피노키오가 있는지)
거기에 매치되는 가수가 있는지
그러기 위해서는 일단 모든 노래 항목을 표시
-- (8)
select s.title, g.name
from song as s
left join girl_group as g
on g.hit_song_id = s._id
where s.title = "피노키오";
-- 해설

★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

---이하 emp_test 데이터베이스로 실습---
-- DALLAS에서 근무하는 사원의 이름, 직위, 부서번호, 부서이름 조회
-- 혼자 성공 :3
select e.ename, e.job, e.deptno, d.dname
from emp as e
Join dept as d
on e.deptno = d.deptno
where d.loc = "DALLAS";

-- 이름에 A가 들어가는 사원들의 이름과 부서이름을 조회하세요.
-- 혼자 성공 :3 짜란다
select e.ename, d.dname
from emp as e
Join dept as d
on e.deptno = d.deptno
where e.ename like "%A%";
--분석
컬럼 적든 테이블 적든 소속 붙여주는 거 까먹지 말기.
수정 전에는 표시 안 한 곳이 있었음.

-- 사원이름과 그 사원이 속한 부서의 부서명, 그리고 월급을 조회.
-- 단, 월급이 3000 이상인 사원 대상으로.
-- 혼자푸로따~
select e.ename, d.dname, e.sal
from emp as e
Join dept as d
on e.deptno = d.deptno
where e.sal >= 3000;

-- 직위가 SALESMAN인 사원들의 직위, 사원이름, 부서명 조회.
-- 해결 :3
select e.job, e.ename, d.dname
from emp as e
Join dept as d
on e.deptno = d.deptno
where e.job = "SALESMAN";

-- 커미션이 책정된 사원들의 사원번호, 이름, 연봉, 연봉+커미션, 급여등급을 조회하되, 각각의 컬럼명을 한글로 사원번호, 사원이름, 연봉, 실급여, 급여등급으로 출력.
-- 문제를 "모든 사원들"로 바꾸셨음.
--- 내가 풀다가 만 거
select e.empno as "사원번호", e.ename as "사원이름", e.sal as "연봉", sum(e.sal+e.comm) as "실급여", s.grade as "급여등급"
from emp as e
Join salgrade as s
on e.sal >= s.losal, e.sal <= s.hisal
where e.comm is not NULL;

e.sal >= s.losal, e.sal <= s.hisal  -- 여거는 삐

select e.sal+e.comm as "실급여" from emp  -- 여거는 잘씀 맞았음.
---수강생이 알려줘서 수정한 거(커미션이 책정된 사원들만)
select e.empno as "사원번호", e.ename as "사원이름", e.sal as "연봉",
e.sal+e.comm as "실급여", s.grade as "급여등급"
from emp as e
Join salgrade as s
on e.sal between s.losal and s.hisal
where e.comm is not NULL  -- null인 사원은 제외
and e.comm > 0;  -- 이거는 강사님이 > 이걸로 수정함. 처음엔 != 0이라고 수강생이 써주셨는데 이러면 마이너스가 적혀있어도 맞다고 뜨것지. ★★★ 그리고 > 0이라고 쓰면 이 0에는 널이 포함됨. ★★★
and e.comm > 0;  -- 이거는 강사님이 > 이걸로 수정함. 처음엔 != 0이라고 수강생이 써주셨는데 이러면 마이너스가 적혀있어도 맞다고 뜨것지. ★★★ 그리고 > 0이라고 쓰면 이 0에는 널이 포함됨. ★★★
----이하 강사님이 쓴 코드(모든 사원들)
select e.empno as "사원번호", e.ename as "사원이름", e.sal as "연봉",
e.sal + ifnull(e.comm, 0) as "실급여", s.grade as "급여등급"
from emp as e
Join salgrade as s
on e.sal between s.losal and s.hisal;

------해설
from 테이블1 Join 테이블2 on 테이블1.컬럼1 between 테이블2.컬럼2 and 테이블2.컬럼3
컬럼1을 컬럼2와 컬럼3 사이에 있는 범위와 연결함

★ e.sal+e.comm as "실급여"
★★★ e.sal + ifnull(e.comm, 0)
  ★★★이프 널 함수( ifnull() )★★★ 안에 커미션 컬럼( e.comm )이 널이면 "숫자 0"으로 바꾸겠다. 0자리에 문자열도 추가 가능.
  여기서 널값이 실제로 0으로 업데이트되는 것은 아님.
    ★★★ 데이터의 실질적 추가와 변경은 update문인 거 꼭 기억.
    ★★★ 셀렉트 뒤에 쓰이는 건 말 그대로 조회할 때 "표시"만 그렇게 되도록 바꿔주는 것임. 이것도 중요.
  디비프로그램마다 이즈널, 이프널로 쓰임. 둘 다 같은 거.

★★★ null은 더할 수 없음. 0이 아님. 숫자와 null이 더해지면 null로 조회됨.

★★★ where e.comm is not NULL;
  이거는 where e.comm > 0; 이게 더 정확함. 위의 문장은 null값이 아닌 0값도 널이 아니라고 치기 때문임.

-- 부서번호가 10번인 사원들의 부서번호(e.depno), 부서이름(d.dname), 사원이름(e.ename), 월급(e.sal), 급여등급(s.grade)을 출력하시오.
select e.depno, d.dname, e.ename, e.sal, s.grade
from emp as e
Join dept as d, salgrade as s  -- 콤마 찍을 거면 프롬 옆에 콤마로 연결해가면서 쓰는 게 낫고, 이거는 테이블 데이터끼리 매치해서 보여줘야 하는 작업이므로 조인으로 나눠 써야한다.
on e.deptno = d.deptno
and e.sal between s.rosal and hisal
where e.deptno = 10;
--- 강사님이 해주신거 (★★★join조인 3개 쓰는 방법★★★)
select e.deptno, d.dname, e.ename, e.sal, s.grade
from emp as e
Join dept as d
on e.deptno = d.deptno
Join salgrade as s 
on e.sal between s.losal and hisal
where e.deptno = 10;
-- 해설

다양한 테이블과 연결되는(join) 테이블이 테이블의 중심이 되어야 한다.
그리고 중심이 되는 테이블은 from 옆에 써야한다.

Join이 두개 이상 쓰였을 때
left는 프롬 바로 옆에 쓴 Join 옆에 한 번만 쓰는 게 맞다.
left join은 바로 앞에 쓴 테이블과 연결이 되게 되는데 이걸 여러개를 쓰게 되면 연결이 이상하게 꼬일 확률이 높으므로.
그리고 일반적인 조인은 from 옆의 테이블과 조인된다.

-- 부서번호가 10번, 20번, 30번인 사원들의 부서번호, 부서이름, 사원이름, 월급, 급여등급을 조회하시오. 단, 부서번호가 낮은 순, 같은 부서면 월급이 높은 순으로 정렬.
-- 꺅 해결
select e.deptno, d.dname, e.ename, e.sal, s.grade
from emp as e
Join dept as d
on e.deptno = d.deptno
Join salgrade as s
on e.sal between s.losal and s.hisal
where e.deptno in (10, 20, 30)
order by e.deptno asc, e.sal desc;
-- 분석
★★★ where 테이블.컬럼 in (a,b,c) 여거 까먹지 말기
컬럼 안에 있는 a, b, c 데이터를 선별적으로 뽑아주는 함수 in!! or 대용.

=====================

-- 이하 sakila 데이터베이스로 실습

실무에 투입되고 처음 보는 디비(디비 뿐만이 아니라 자바 코드든 뭐든)가 있으면 무슨 정보들이 있는지 한 번 다 살펴봐야 한다.
유지보수하기 위해서는 처음에 남이 만들어 놓은 거 다 분석하는 과정을 거침.
★일관성 있는 설계 및 네이밍이 중요.
sakila는 실무 디비에 가까움.

★테이블을 만들 땐 아이디값을 꼭 부여해준다.
★컬럼 이름은 "테이블이름_id"의 형식이 디폴트.

-- 액터테이블에서 퍼스트네임, 라스트네임 조회.
select first_name, last_name from actor;

★★★ concat()함수 ★★★
원래 디비는 냅두고(업데이트 노노) 원하는 데이터들을 붙여서 보여주는 방법(아래 예시). 자바의 concat(문자랑 문자 계속 붙여주는 함수)이랑 비슷함.
-- 퍼스트 네임과 라스트 네임을 붙여서, 'Actor Name' 별칭으로 출력
출력은 모다 조회다. 조회는 모다 select다.
select concat(first_name, " ", last_name) as "Actor Name" from actor;

-- 데이터 안의 내용을 소문자로 바꾸고 싶으면 lower()
select lower(concat(first_name, " ", last_name)) as "Actor Name" from actor;
select lower(first_name) from actor;
-- 데이터 안의 내용을 대문자로 바꾸고 싶으면 upper()
select upper(concat(first_name, " ", last_name)) as "Actor Name" from actor;

-- 퍼스트네임이 Joe인 배우의 액터아이디, 퍼스트네임, 라스트네임 조회
select actor_id, first_name, last_name from actor
where first_name = "Joe";
-- 분석
아 조건 좀 잘 보세요...
조회만 열심히 하지 말고...

-- 컨트리 테이블을 조회해보시고, 컨트리 테이블에서 컨트리가 Afghanistan, Bangladesh, China인 컨트리 아이디와 컨트리를 조회하시오.
select country_id, country
from country
where country in ("Afghanistan", "Bangladesh", "China");

★★★★★★ CRUD 기똥차게 잘해야한당. ★★★★★★

★★★ 컬럼 추가하기 ★★★
-- 액터 테이블에 middle_name 컬럼을 추가할 겁니다. 이 컬럼의 위치는, 퍼스트 네임 다음에 위치합니다. 이 컬럼의 데이터는 "문자열 20개"까지 저장하는 컬럼입니다.

데이터베이스는 저장할 수 있는 문자열의 한도가(제한이) 있음(한도를 설정해야함).
SQL이 아니면 (이 뒤에 문자 깨져서 지움)
1. 쿼리문으로 해결하는 방법 (알아만 두자)
-- middle_name 컬럼 actor 테이블에 추가하기 --
alter table actor
add column middle_name varchar(20)
after first_name;
-- middle_name 컬럼 삭제하는 SQL --
alter table actor
drop column middle_name;
-- 실제로 위와같이는 잘 안한다. 앞으로는 아래에 적힌 방법으로 만들어라.
2. 워크벤치(mysql) 프로그램을 활용해서 쉽게 만드는 방법.
!! 순서쓰기
알터테이블창켜기
입력하기/타입고르기
위치옮기기
마지막은 어플라이 어플라이
워크벤치로 삭제하는 방법
---------------------------------------------
★ 결론 : 테이블 & 컬럼 조작은 마우스로 하자. ★

알터 테이블 : 테이블 수정하기(컬럼 추가/ 이름이나 데이터타입 수정)

★ char / varchar 차이 ★
char 공간이 20이면 20개 다 채워야함
varchar는 공간이 20개까지로 설정해도 가 안 되도 가능하고 나머지를 그냥 세이브해줌.

-- 라스트네임렬로 묶되, 같은 라스트네임이 몇개씩이었는지 세어서 출력.
-- 라스트네임과 카운팅한 숫자를 조회합니다.
-- 맞았당. !! 근데 카운트는 더 이해해야 할 거 같음.
select last_name, count(last_name)
from actor
group by last_name
having ;

-- 위의 결과에서, 사람 수가 3명 이상인 데이터만 조회하라.
select last_name as ln, count(last_name) as cnt
from actor
group by last_name
having cnt >= 3;
-- 분석
★★★ 그룹 안에서 조건을 따질 때는 having!!!!!!!!
위 예제 잘 이해하기

-- 퍼스트네임이 GROUCHO이고, 라스트 네임이 WILLIAMS인 사람의 퍼스트 네임을 HARPO로 변경하시오.
1) 일단 조회 먼저.
select first_name, last_name from actor
where first_name = "GROUCHO" and last_name = "WILLIAMS";
2) 그리고 변경
update actor
set first_name = "HARPO"
where first_name = "GROUCHO" and last_name = "WILLIAMS";
3) 그리고 잘 바뀌었나 조회
select first_name, last_name from actor
where first_name = "HARPO";
-- 이 과정 세 개 다 혼자 성공 :3

200522 금요일 수업 키워드

Cn = 컬럼 이름
Tn = 테이블 이름
Dn = 데이터베이스 이름
Jo = 조건문
Ha() = 함수
St = 문자열
Int = 정수
Dt = 데이터 타입

---

=====★ SQL (QUERY)=====

QUERY
	쿼리가 실행된다

★INSERT INTO Tn (Cn0, Cn1, ...) VALUES (A, B, ...), (C, D, ...);
	((200521))

★JOIN
	INNER JOIN
		FROM Tn1 JOIN Tn2 ON Tn1.Cn1 = Tn2.Cn2 JOIN ...
	LEFT OUTER JOIN
		FROM Tn1 LEFT JOIN Tn2 ON Tn1.Cn1 = Tn2.Cn2 JOIN ...
			Tn1의 컬럼들은 매칭되는 데이터가 없더라도 전부 조회된다.
			LEFT JOIN은 한 쿼리문에 하나만 들어가는 것이 이상적이고 꼬이지 않는다.
	-- Use Manual
	1. 먼저 보고자 하는 조건에 맞는 테이블들을 찾는다.
	2. 필요한 테이블들을 먼저 JOIN하고 다음에 조건(WHERE)를 적는다.
	3. 원하는대로 조합이 되었는지 SELECT * 로 확인한다.
	4. 조회 조건대로 SELECT 우측을 수정한다.

SELECT Tn1.*, Tn2.*;

SELECT T.* FROM Tn as T

날짜 데이터 입력
	possible	=>	"2009-01-01", 20090101, "20090101"
	impossible	=>	2009-01-01

CREATE DATABASE Dn;
	((200521))

★★★USE Dn;
	((200520))

CREATE TABLE Tn2 (
Cn1 Dt Jo1,
Cn2 Dt Jo2,
...,
FOREIGN KEY (Cn1) REFERENCES Tn1(Cn3)
ON DELETE CASCADE
);
	Jo	=>	NOT NULL, AUTO_INCREMENT, PRIMARY KEY, default?????

WHERE LIKE "%"
	((200520))

Tn.Cn

★ FROM Dn.Tn

CONCAT()
	CONCAT(A, B, C, ...)
		A, B, C  =>  Cn, "St", "Int"

LOWER() / UPPER()
	LOWER(A) / UPPER(A)
		A  =>  Cn(Dt is St), "St"

ALTER TABLE
	ALTER TABLE Tn
		ADD COLUMN Cn1 Dt
		AFTER Cn2;
	ALTER TABLE Tn
		DROP COLUMN Cn1;

CHAR() vs VARCHAR()



====================

COLUMN

.csv
	Comma Seperated Values

Unique Data200526 화요일 수업 메모



★★★ 테이블 만드는 방법 (테이블 설계)
  테이블에는 저장하기 위한 구성 요소가 있다 (고양이 이름, 품종, 나이 등)
    무엇(이름 등)을 어떻게(데이터타입) 저장해야 하는지를 스스로 생각해야한다
    저장될 수 있는 모든 데이터와 수를 고려한다.
  조인을 염두에 두고 테이블을 만든다.
  데이터 타입을 꼭 지정한다
  컬럼이름과 데이터 타입을 설계한다 = 테이블을 설계한다
  설계한 것을 코드로 바꿀 수 있어야한다



★★★ 테이블을 만드는 sql
  create table tablename
    (
      column_name data_type,
      column_name data_type,
      username varchar(15)
    );



★★★ 리모트 접속해서 디비 다루기 (현업ver)
테이블 만들고 데이터 집어넣고 문자열 다루는 것 등을 퍼티의 MariaDB에서(원격접속해서) 실습
MariaDB remote access 자료(리모트 셋팅하는 방법) 깃헙 14번에 올려놓으셨음.

=============핵중요 시험에 나옴==============
22포트 ssh를 위한 포트 ★ssh포트는 22다!!!★
ssh에 접속할 때의 포트
푸티를 위한 포트(살려놔야 원격으로 윈에서 리눅스에 접속할 수 있음)

★센트오에스아이피 10.0.2.15★ ★3306은 마이에스큐엘마리아디비가 사용하는 포트★
게스트아이피 : 센트오에스 아이피

11111 호스트피시는 윈도우. 호스트 아이피 ★3306는 마이에스큐엘에서 쓰고 있기 때문에★ 11111로 바꾼 것.
================================
위에 11111 네트워크 설정해주고 리부트해주기.

설치 관련 문제는 간단하게 내줌.



// 마리아디비 실행되고 있는지 보기(실행)
mysql -u root -p
들어가서 패스워드 치라고 하는 창 안 나오면 마리아디비에 연결 안 된 것임.
마리아디비 프로그램 켜기
  systemctl start mariadb
    root
    패스워드 입력
마리아디비 항상 켜게 하기
  systemctl enable mariadb



// 유저 권한 설정하기
  루트 접속할 건데 원격으로 접속하겠다. 원격으로 접속 가능하게('%') 바꿔주겠다. 
  ★★★ 시험 나옴 : 원격으로 접속 가능하게 해주는 핵심 명령 '%'
GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'my-new-password' WITH GRANT OPTION;
여기서 마이뉴패스워드에 에스큐엘 루트 패스워드 (전에 설정했던 거) 적으면 됨.
쿼리 오케이 뜨고 넘어가는 게 정상.

grant는 언제 어디서든 접속할 수 있도록 허가하겠다는 명령이지만 실습 때는 본인컴에서 만든 서버에 본인 컴에서 접속하는 것이므로 불가.

마리아디비에서 나오기 (exit 명령어)



// 그리고 방화벽 설정(루트로 해야됨).
  루트로 들어가야 한다는 거(정확히는 su 명령어) 시험 문제에 나옴.
firewall-cmd --add-port=3306/tcp
포트 : 외부에서 접속할 수 있게 하는 거
석세스 나오면 성공

cmd : 커맨드라는 뜻

firewall-cmd --permanent --add-port=3306/tcp
퍼머넌트 : 영원히
영원히 열어놔라.



// 위 아래 명령을 따로따로하는 이유
위에것만 하고 서버 끄고 가면 서버 다시 켰을 때 위에 명령 다시 해야 함
  "지금" 열어라
밑에것만 하면 지금 접속하려고 하면 접속안됨
  서버 재부팅할 때 자동으로 열어라라는 명령어
    이걸 쳐야 나중에 서버컴을 껐다 켜도 위의 명령을 계속 쓸 필요가 없어짐



// 워크벤치에 CentOS의 MariaDB 연결하기
워크벤치 감
새로운 커넥션 만듬(플러스버튼)
CentosMySQL
포트에 11111 적음
루트 비번 설정
테스트 커넥션에서 워닝 뜨고 그러면 그냥 컨티뉴 애니웨이 누르기

여기서 만든 건(CentosMySQL) 부산에 있는 서버다라고 생각하면 됨.
퍼티로 CentOS에 접속해서 MySQL에 들어갔던 걸(mysql -u root -p) 워크벤치에서 한방에 들어가는 것.
	= ★★★워크벤치를 사용해 CentOS에 있는 DBMS에 원격 접속한 것임.



========= 본격실습 ============

CentosMySQL 에 들어가기

실습용 데이터베이스 만들기
mydb 데이터베이스 생성
create database mydb;
  작업폴더 만들듯이 데이터베이스 생성하는 것임.
그리고 해당 DB로 이동
use mydb;

// 빵"테이블 만들기"(예시)
테이블 이름 : pastries
컬럼 : 2개
name 컬럼 : 문자 50개까지만 저장
quantity 컬럼 : 정수
---
create table pastries
(
name varchar(50),
quantity int
);

★ show tables;
  소속된 데이터베이스 안에 있는 테이블들 보기.
  이 디비 안에 테이블 몇 개 있는지 보고싶을 때

★ desc Tn;
  테이블의 컬럼 "정보(속성)" 확인하기
  테이블 안의 데이터를 조회하는 것이 아니라 말 그대로 해당 테이블 안 컬럼들의 정보만 조회함.

---
이걸 푸티에서 확인하기
푸티 ssh로 접속한 상태
★ show databases;
use 디비이름;
show tables;
desc Tn;
---

테이블 삭제하기
drop table 테이블이름;


=============================(이하 실습)
---(1) 실습 예제
// 고양이 정보 저장 "테이블 생성"
테이블명 : cats
컬럼 : 2개
  name 컬럼은 varchar(50)
  age 컬럼은 int
---(1) 실습
create table cats
(
    name varchar(50),
    age int
);



// 데이터 추가하기
이름 : Blue (대소문자 가리기)
나이 : 1살
insert into cats (name, age) values ("Blue",1);
잘 들어갔나 확인하기
select * from cats;
입력할 컬럼 순서는 바꿔도 됨. 단 뒤에 넣는 밸류스도 거기에 맞춰서 바꿔서 넣어주면 된다.
insert into cats(age, name) values (11, "Draco");



// 데이터 여러 행으로 한번에 저장하기
insert into cats (name, age)
  values ('Charlie',10),
           ('Sadie', 3),
           ('Lazy Bear', 1);



---(2) 실습 예제
people 테이블 생성
first_name 컬럼 : 문자 20개까지
last_name 컬럼 : 문자 20개까지
age 컬럼 : 정수
이 테이블에 데이터 추가하기
F : Tina / L : Belcher / A : 13
F : Bob / L : Belcher / A : 42
---(2) 실습
create table people
(
	first_name varchar(20),
	last_name varchar(20),
	age int
);
insert into people (first_name, last_name, age)
	values ('Tina', 'Belcher', 13),
	         ('Bob', 'Belcher', 42);
---분석
★ into 옆에 테이블 이름 적는 거 잊지 말 것
콤마 제대로 찍어주기
★ 따옴표는 앞뒤를 맞춰줘야 에러가 안 난다.



insert into people (first_name, last_name, age)
	values ('Linda', 'Belcher', 45),
			('Phillip', 'Frond', 38),
            ('Calvin', 'Fischoeder', 70);



show databases; 디비조회
show tables; 테이블 조회
desc 테이블이름; 테이블 컬럼 정보 조회



---(3) 역슬래시 사용법을 알려주기 위한 예시
피플 테이블에 텍스트를 저장하기 "I'm your father."
first_name에 "I'm your father." 저장
last_name에 "hello" 저장
age는 30을 저장
---(4) 역슬래시 사용법을 알려주기 위한 예시
first_name에 'He said "Hi".' 저장
last_name에 "hello" 저장
age는 30을 저장
---(4) 실습
insert into people (first_name, last_name, age)
	values ("He said \"Hi\".", "hello", 30);
★ 문자열 안에 작은 따옴표나 큰 따옴표가 들어갈 경우 \(역슬래시)
    문자열 안의 따옴표 앞에 \를 붙이면 됨. 예) \' \"



---(5) varchar(n) 한도를 넘어갈 때 예시
cats 테이블에 데이터 인서트
name : This cat is named Charlie which is also a human name. In fact I know a couple of Charlies. Fun Fact
age : 10
---(5) 실습 : varchar(n) 한도를 넘어갈 때
insert into cats (name, age)
	values ("This cat is named Charlie which is also a human name. 
		In fact I know a couple of Charlies. Fun Fact", 10);
실행하면 에러메세지 뜸
Error Code: 1406. Data too long for column 'name' at row 1
★ 데이터 설계시 글자 한도 제한을 잘 생각해서 둬야 함. 글자 넘어가면 디비가 못 받아줌.
---



★ null에 대해서
null = default value(DB에서)
null : 값이 없다. 값이 들어있지 않다
null != 0
  null은 0이 아니다.
null != " "
  null은 공백과도 다르다.
0과 공백은 다 값이 있다.
--(6) null 예제
insert into cats (name)
values ("Alabama");
--(6) 결과
Lazy Bear	 1
Alabama	 
================



---(7) null 예제2
insert into cats ()
values ();
---(7) 결과
모든 컬럼에 null값이 들어간 데이터가 입력된다.
(당연하지만) 컨트롤 엔터 칠 때마다 같은 데이터가 계속 들어간다.



---실습을 위해서 테이블 하나 더 만듦---
컬럼을 정의할 때, ★NOT NULL 키워드를 사용하여 테이블을 생성★하는 경우를 실습
테이블명 : cats2
컬럼 name : 문자열 100개 그리고 Not Null
컬럼 age : 정수 그리고 Not Null



---(8) 낫널 테이블만들기 예시 : 테이블 생성시 컬럼 맨 뒤에 not null 추가하면 됨
create table cats2
(
name varchar(100) not null,
age int not null
);
---desc해보기
desc cats2;
해보면 null 항목 밑에 no라고 표시됨
널이 yes로 되어있으면 (7)처럼 해당 컬럼에 값이 없어도 추가가 될 수 있음.
낫널상태에서는 널을 허용하지 않는다.
---낫널 테이블에 데이터 인서트하기
insert into cats2 (name, age)
values ("Mit", 3);
잘 들어감
insert into cats2 (name)
values ("Yong");
이건 에러뜸
Error Code: 1364. Field 'age' doesn't have a default value
낫널은 인서트할 때 데이터가 꼭 있어야 한다는 얘기
---

테이블 cats3하나 더 만듦
create table cats3
(
name varchar(100) not null,
age int
);
insert into cats3 (name, age) values ("Hi", 3);
잘 등록됨
insert into cats3 (age) values (5);
이건 에러남 네임이 낫널이라



=======★ default에 대해서==========
필수값과 필수값이 아닌 것.
필수값이 아닌 것을 입력받지 않았을 때 널로 처리하지 않고
입력되는 값이 없으면 0으로 만들고 싶다
"인서트값이 없을 때 ~로 초기값을 설정하겠다."
desc로 테이블을 봤을 때, 디폴트 탭 아래에 "null 박스"가 표시되어 있으면 해당 컬럼이 insert가 없을 때 "null 박스"로 표시하겠다는 뜻임.
	String 타입 "null"과는 다른 얘기임.
---(9) 예시 : 데이터 생성하면서 default값 붙이기
--이름이 없으면 null이 아니라 unnamed로 채우고 age가 없으면 99세로 설정하시오.
create table cats4 설계
(
name varchar(100) default "unnamed",
age int default 99
);
---(9)에 데이터 값 넣고 실험해보기
insert into cats4 (name, age) values ("Momo", 3);
select * from cats4;
insert into cats4 (name) values ("Kitty");
insert into cats4 (age) values (10);
insert into cats4 () values ();
---



==========테이블 변경하기 워크벤치에서=========
테이블 우클릭해서 알터테이블 들어가기
NN 체크박스 체크하면 이 컬럼 속성은 Not null이 됨.
하고 어플라이 쭉 하면 적용됨.
★ 낫널 체크했으면 디폴트 지워야됨. 안 지우면 낫널 상관없이 그냥 디폴트 들어감.
그 다음에 다시 
insert into cats4 (age) values (10);
이거 쓰면 에러메세지 뜸.

★★낫널 안하고 그냥 만들었들을 때 알터테이블에서 확인할 수 있는 널 디폴트 값은 NULL이다.



=========동일한 데이터를 구분하는 방법==========

// 동일한 데이터들을 구분하고 싶을 때 사용.

★★★ KEY!!! : 동일한 데이터들을 유니크하게 구분(처리)해줄 수 있는 것
보통 ~_id의 형태로 표시된 컬럼이 키 컬럼.

키를 왜 두냐. 중복값을 구분하기 위해서.
primary key : 데이터 중복없이 유니크하게 처리하자는 개념에서 나옴.

테이블 설계시 키값을 넣을지도 염두에 둔다.
데이터타입은 보통 정수로 만든다.
★ 얘는 널이 되면 안된다. 낫널이어야 한다. 유니크에 위반되기 때문.
프라이머리 키를 설정한다고 얘기한다.

파란색 글씨는 "키워드"라고 부른다.



---(10) key 실습
-- 새 테이블 만들기
create table unique_cats (
cat_id int not null,
name varchar(100),
age int,
primary key (cat_id)
);
---
desc unique_cats;를 보면
cat_id 옆 key에 PRI(프라이머리 키)라는 표시가 있다.
이 테이블의 알터테이블에 들어가보자
cat_id 옆에 PK(프라이머리 키)에 체크표시가 되어있다.



---(11) 캣 아이디에 기존에 등록된 숫자로 새로운 데이터를 저장하는 경우의 예시
insert into unique_cats (cat_id, name, age)
values (1, "Fred", 4);

insert into unique_cats (cat_id, name, age)
values (2, "Louise", 3);

insert into unique_cats (cat_id, name, age)
values (1, "James", 5);
---
마지막 인서트는 이렇게 에러메세지가 뜸
Error Code: 1062. Duplicate entry '1' for key 'PRIMARY'
그리고 값은 등록되지 않음.
★ 결론 : 중복은 ㄴㄴㄴㄴㄴㄴ 프라이머리 키는 유니크해야 하니까.



---
★★★ 키값을 데이터베이스가 자동으로 알아서 계산해서 생성시켜주도록 하기(오토 인크리먼트 ★auto increment★) 현업에서는 보통 이걸 씀.

---(12) 오토 인크리먼트 예제(테이블 만들기)

create table unique_cats2 (
cat_id int not null auto_increment,
name varchar(100),
age int,
primary key (cat_id)
);
---(12) desc unique_cats2; 했을 때
캣 아이디의 맨 오른쪽 Extra 창에 오토 인크리먼트 표시가 생김.
---(12) 이 테이블의 알터테이블로 갔을 때
캣 아이디의 오른쪽 AI에 체크표시가 되어있다.
  AI = 오토 인크리먼트
  
---(12) 인크리먼트 예제(데이터 인서트)
insert into unique_cats2 (name, age)
values ("Skippy", 4);
---
위 예제를 두세번 실행시 프라이머리 키는 1,2,3 순서대로 들어감.
---
캣아이디는 테이블 생성시 오토 인크리먼트를 써서
데이터베이스가 자동으로 순서대로 아이디값을 써넣어주기 때문에
인서트할 때 캣아이디가 낫널이어도 적지 않는다.
안 적어줘도 알아서 아이디 숫자 순서대로 등록해준다.
★ 프라이머리 키 숫자는 1부터 시작함.
---(12)
insert into unique_cats2 (name,age)
values ("Jiff", 3);



---(13) 요구사항에 맞는 "테이블 설계" 예제
테이블 : employees
id컬럼 : 숫자(자동증가), 필수, 프라이머리 키
last_name컬럼 : 문자(30개), 필수
first_name컬럼 : 문자(30개), 필수
middle_name컬럼 : 문자(30개), 필수 아님
age컬럼 : 숫자, 필수
current_status컬럼 : 문자(20자), 필수 아님, 디폴트값으로 "employed"
---(13) 예제풀기
create table employees
(
id int not null auto_increment,
last_name varchar(30) not null,
first_name varchar(30) not null,
middle_name varchar(30),
age int not null,
current_status varchar(20) default "employed",
primary key (id)
);
---(13)
"오토 인크리먼트" 쓰고서 맨 밑에 "프라이머리 키"를 안 적으면 이렇게 에러가 남.
안 적었었음..ㅎㅎ
Error Code: 1075. Incorrect table definition; there can be only one auto column and it must be defined as a key
번역기 : 잘못된 테이블 정의; 하나의 자동 열만있을 수 있으며 ★키로 정의되어야합니다.★

맨 밑에 프라이머리 키 지정해주지 않고
id int not null auto_increment primary key, 이렇게 써도 된다.
---



★★★ 크리에이트 인서트 업데이트 딜리트 드랍 ~
★★★ 문자열 데이터 조작하기



---(14) cat 테이블 삭제하고 새로 만들기
drop table cats;
create table cats (
cat_id int not null auto_increment primary key,
name varchar(100),
breed varchar(100),
age int
);
---(14) 데이터를 한번에 insert
insert into cats (name, breed, age)
values ("Ringo", "Tabby", 4),
("Cindy", "Maine Coon", 11),
("Dumbleddore", "Maine Coon", 11),
("Egg", "Persian", 4),
("Misty", "Tabby", 13),
("George Michael", "Ragdoll", 9),
("Jackson", "Sphynx", 7);
---
★ 인서트에 두 번 엔터치면 똑같은 데이터 또 들어가니까 주의하기.



---(15) 캣츠 테이블에서 품종이 Tabby인 것들의 품종을 Shorthair로 변경하기
★ 업데이트 : 저장되어 있는 값을 다른 값으로 바꾸는 것
update cats
set breed = "Shorthair"
where breed = "Tabby";
--- 이거 왜 세이프모드 뜨냐.
★★★똑같은 컬럼에 있는 내용을 가져와서 그거 값을 바꾸려고 하는거는 위험한 업데이트기 때문이다. 똑같은 컬럼이라 위험하다는 뜻.
--해결책--
세이프모드를 끄던가 아니면(왠만하면 끄지 말기)
safe mode 피하기  ::  ★ where ~ and 키컬럼이름 > 0 ; ★
참고로 퍼티나 리눅스 터미널 거기는 세이프모드도 없이 그냥 바꿔버림.
---(15) 해결해봄
update cats
set breed = "Shorthair"
where breed = "Tabby" and cat_id > 0;



--(16) 이름이 Misty인 고양이의 나이를 14로 변경하세요
update cats
set age = 14
where name = "Misty" and cat_id > 0;
---
★ SQL문 쓸 때 한쿡인은 where부터 쓰는 게 편하다.
CPU도 where 조건 먼저 가져온다.



---(17) 이름(name)이 Jackson인(where) 고양이 이름(name)을 Jack으로 바꾸세요(update set)
update cats
set name = "Jack"
where name = "Jackson";



---(18) 이름(name)이 Jackson인(where) 고양이는 몇마리인지(count(*)) 조회(select)하세요
select count(*)
from cats
where name = "Jackson";



---(19) 이름(name)이 Jack인(where) 고양이는 몇마리인지(count(*)) 조회(select)하세요
select count(*)
from cats
where name = "Jack";
---gooood good good



---(20) 이름(name)이 Ringo인 고양이(where)의 품종(breed)을 British Shorthair로 바꾸세요(update set)
update cats
set breed = "British Shorthair"
where name = "Ringo";



---(21) 품종(breed)에 hair가 들어있는(where like) 데이터를 조회(select)하세요
select *
from cats
where breed like "%hair%";
---595959595959595959



---(22) 품종(breed)이 Maine Coon인(where) 고양이의 나이(age)를 12로 변경(update)하세요
update cats
set age = 12
where breed = "Maine Coon";



---(23) 고양이의 나이(age)가 8살보다 큰(where) 고양이만 조회(select)하세요
select *
from cats
where age > 8;
--- goodgood
큰 >, 이상인 >=
작은 <, 이하인 <=



---(24) 나이가 8보다 큰 고양이의 이름과 품종을 "Kitty", "Ragdoll"로 변경
★★★ 여러 항목 한번에 업데이트하기
update cats
set name = "Kitty", breed = "Ragdoll"
where age > 8;



---(25) 나이가 4인 고양이의 데이터를 삭제하시오.
// ★ delete 사용하기
delete
from cats
where age = 4;



---(26) 고양이 나이가 12인 고양이의 나이를 5로 변경하세요
update cats
set age = 5
where age = 12;
// 이후에 5를 다시 3으로 바꿔줌.



---(27) 고양이 아이디와 나이가 같은 데이터를 삭제하세요
delete
from cats
where cat_id = age;
---gooooooood



★★★ 설계해라 = 틀을 만들어라.
내용(데이터) 입력하는 얘기가 아님.



---sql파일 하나 새로 만듦
---(28) 디비만들기/테이블 설계하기 실습 예제
데이터베이스 이름 : shirts_db
테이블 이름 : shirts
-컬럼-
shirt_id : int, not null, primary key
article : varchar(30)
color : varchar(30)
shirt_size : varchar(1)
last_wom : int
---(28) 실습(혼자함ㅇㅇ)
create database shirts_db;

use shirts_db;

create table shirts (
shirt_id int not null auto_increment primary key,
article varchar(30),
color varchar(30),
shirt_size varchar(1), <<-5로 바꿈
last_wom int
);
---
★★★★★★★★★★ 테이블 만들기 전에!!!!! "★★★★★★★★★★use 디비이름★★★★★★★★★★" 써서 테이블 만들 디비로 자리 좀 옮겨주세여!!!!!!!!!!!!!



---(28) 디비 인서트(복붙)
insert into shirts (article, color, shirt_size,last_worn)
values ('t-shirt', 'white', 'S', 10),
		('t-shirt', 'green', 'S', 200),
        ('polo shirt', 'black' , 'M', 0),
        ('tank top', 'blue', 'S', 50),
        ('t-shirt', 'pink', 'S', 0),
        ('polo shirt', 'red', 'M', 5),
        ('tank top', 'white', 'S', 200),
        ('tank top', 'blue', 'M', 15);
select * from shirts;



---(29) 아티클과 컬러만 조회하시오.
select article, color from shirts;



---(30) 셔츠 사이즈가 M인 데이터에서 셔츠 아이디만 제외하고 화면에 조회
select article, color, shirt_size, last_worn
from shirts
where shirt_size = "M";



---(31) 아티클이 polo shirt로 되어있는 셔츠의 사이즈를 L로 바꾸세요.
update shirts
set shirt_size = "L"
where article = "polo shirt";
---잘 됐는지 확인하기
select *
from shirts
where article = "polo shirt";



---(32) last_worn이 15인 데이터를 전부 10으로 바꿔주세요
update shirts
set last_worn = 10
where last_worn = 15;



---(33) 컬러가 white인 셔츠의 컬러를 off white로 바꾸고 셔츠 사이즈도 XS로 변경하세요
update shirts
set color = "off white", shirt_size = "XS"
where color = "white";
---excellent



★★★varchar 늘리는 건 문제가 안 되지만 줄이는 건 문제가 된다.



---(34) last_worn이 200인 데이터를 삭제하세요.
delete from shirts
where last_worn = 200;
---good



---(35) 아티클이 tank top인 데이터를 삭제하세요.
delete from shirts
where article = "tank top";



---(36) shirts 테이블 자체를 삭제하세요
drop table shirts;



---(37) shirts_db에 있는 테이블의 리스트를 조회하세요.
use shirts_db;
show tables;

중복 방지는 KEY~~~~~
테이블 만들 땐 "프라이머리 키 (컬럼이름)"을 적어줘야 중복 알아서 경고해주고 그럼.



=======문자열 데이터 다루기==========
---테이블 제작
use mydb;

create table books (
book_id int not null auto_increment,
title varchar(100),
author_fname varchar(100),
author_lname varchar(100),
released_year int,
stock_quantity int,
pages int,
primary key (book_id)
);



---데이터 저장(깃헙 15번에 있음)
INSERT INTO books (title, author_fname, author_lname, released_year, stock_quantity, pages)
VALUES
('The Namesake', 'Jhumpa', 'Lahiri', 2003, 32, 291),
('Norse Mythology', 'Neil', 'Gaiman',2016, 43, 304),
('American Gods', 'Neil', 'Gaiman', 2001, 12, 465),
('Interpreter of Maladies', 'Jhumpa', 'Lahiri', 1996, 97, 198),
('A Hologram for the King: A Novel', 'Dave', 'Eggers', 2012, 154, 352),
('The Circle', 'Dave', 'Eggers', 2013, 26, 504),
('The Amazing Adventures of Kavalier & Clay', 'Michael', 'Chabon', 2000, 68, 634),
('Just Kids', 'Patti', 'Smith', 2010, 55, 304),
('A Heartbreaking Work of Staggering Genius', 'Dave', 'Eggers', 2001, 104, 437),
('Coraline', 'Neil', 'Gaiman', 2003, 100, 208),
('What We Talk About When We Talk About Love: Stories', 'Raymond', 'Carver', 1981, 23, 176),
("Where I'm Calling From: Selected Stories", 'Raymond', 'Carver', 1989, 12, 526),
('White Noise', 'Don', 'DeLillo', 1985, 49, 320),
('Cannery Row', 'John', 'Steinbeck', 1945, 95, 181),
('Oblivion: Stories', 'David', 'Foster Wallace', 2004, 172, 329),
('Consider the Lobster', 'David', 'Foster Wallace', 2005, 92, 343);
---



라스트 네임 성



★★★ concat() 함수 : 문자열 합치기
나눠진 컬럼들을 하나로 합쳐서 보고싶을 때
concat(컬럼이름, 컬럼이름, 컬럼이름, ...)
컬럼 이름 말고도 문자열 붙이기도 가능.



---(38) concat()함수 예시
concat("Hello","World");
이렇게 쓰면 실행안됨
select concat("Hello","World","Bye");
이렇게 써야됨. 물론 이런 식으로 문자열 나열을 쓸 일은 없음.



---(39) concat으로 컬럼 붙이기
select author_fname, author_lname from books;
// 이거 두 개를 붙여서 보고싶으면 아래와 같이 쓴다
select concat(author_fname," ",author_lname) as "author" from books;



---(40) "책 제목 - 작가 이름f - 작가의 성l"으로 나오도록 조회하고 컬럼명은 title_author으로 나오도록 하세요
select concat(title, " - ", author_fname, " - ", author_lname) as title_author from books;
★ select concat_ws(" - ", title, author_fname, author_lname) as title_author from books;
---
위 두개의 조회 결과는 같음.
★ concat_ws("사이사이에 추가할 문자", 컬럼명, 컬럼명, ...)
  컬럼명과 컬럼명 사이에 알아서 맨 앞에 쓴 문자를 추가해주는 함수.



★★★ substring() 함수 : 문자열의 일부분을 가져오는 함수
시작 위치, 몇 개 표시할 건지의 개수를 표시해서 일부 문자만 가져옴.
★ substring(문자컬럼 ,시작위치, 시작위치부터몇개가져올지)
  ★ 인덱스를 하나만 쓰든 두 개를 쓰든 시작 위치인 것은 똑같음 주의
시작 위치에서는 -(음수)를 쓸 수 있음.



---(41) 예시
select substring("Hello World", 3);
---
3은 인덱스 숫자.
★ SQL은 인덱스 숫자를 1부터 셈.
---결과물
substring("Hello World", 3)
llo World



---(42) 예시
select substring("Hello World", 1, 4);
---
첫 번째 숫자는 시작 인덱스 위치, 두번째 쓰는 숫자는 n개 가져와라.
---결과물
substring("Hello World", 1, 4)
Hell



---(43) 예시
select substring("Hello World", -3);
---
-3 하면 맨 끝 문자(-1)에서 -3자리 뒤로 감. 거기서부터 끝까지를 출력함.
---결과물
substring("Hello World", -3)
rld



--- 책 제목 조회
select title from books;
---(44) 책 제목을 조회하되, 제목이 처음부터 10글자까지만 나오도록 조회
select substring(title,1,10) from books;
---(45) 조회 결과가 아래처럼 나오도록 하시오
-- The Namesa...
-- Norse Myth...
select concat(substring(title,1,10), "...") as title from books;
---깨끗한 쿼리, 깨끗한 조회 화면



★★★ replace() 함수 : 문자열에서 원하는 문자열을 바꾼다.
---(46) 예시
select replace("Hello World", "Hell", "Heaven");
Hello World 문자열에서 Hell이 있는 부분을 Heaven으로 바꿔줘라

select replace("Hello World", "l","7");
l이 들어있는 부분을 전부 7로 바꿔라

select replace("cheese bread coffee milk", " ", " and ");
공백이 들어있는 부분을 전부 " and "로 바꿔라.



---(47) 예제 : 타이틀에서 e가 들어있으면, e를 3으로 변경하여서 조회하시오.
select replace(title, "e", "3") as title from books;
---
★★★ 리플레이스 안에 입력한 컬럼만 조회됨. 전부 출력 안됨 주의.
--- 결과물 중 하나
Th3 Nam3sak3



★★★ reverse() 함수 : 문자열의 순서를 역순으로 바꿔준다.
---(48) 예시
select reverse("Hello World");
---(48) 결과
reverse("Hello World")
dlroW olleH



---(49) 예제 : 작가의 이름과 성을 조회하되, 성 부분을 역순으로 바꿔서 조회하시오.
select author_fname, reverse(author_lname) from books;
---





★★★ char_length() 함수 : 문자열의 수를 세주는 함수

---(50) 예시
select char_length("Hello World");
---(50) 결과값
char_length("Hello World")
11



---(51) 작가의 성, 작가 성 이름의 갯수 이렇게 2개를 조회하시오
---단, 작가 성 이름의 갯수는 컬럼명을 length로 바꿔서 표시하세요
select author_lname, char_length(author_lname) as length from books;
---결과물 중 하나
author_lname  length
Lahiri  6



---(52) 위 조회에서 쓴 두 개의 컬럼을 합치되 Lahiri is 6의 형태로 표시되게 조회하세요
select concat(author_lname, " is ", char_length(author_lname)) as author_len from books;
---잘했:D




=================================



워크벤치에서 재접속하기
  DBMS 들어간 상태에서 그냥 파일 끄듯이 x버튼 누르면 꺼짐. 다시 들어가면 됨.

데이터타입 종류를 다 알 필요는 없다
숫자 / 문자열 / 날짜
크게 세가지만 알면 된다.
이 데이터 타입들에서 많이 쓰는 것
숫자 : "인트" - 42억 9천까지 처리함 / 플롯 / 더블 - 42억 9천이상의 숫자를 저장
문자열 : char / "vatchar" - 따옴표로 둘러싸여진 것
  varchar(15) <-문자열 15개를 저장할 수 있게 하겠다
날짜 : 다섯가지 다 많이 씀.

테이블 : 실제 데이터를 저장하는 애
테이블은 보통 네모 박스로 도식화한다.

erp(erp 아님 원래 뭐인지 따로 어디 수업 메모에 메모해놓음) : 데이터베이스를 도식화한 그림
조인할 수 있는 테이블들끼리 연결한다.
도식화할 때 테이블간의 관계는 선으로 묶는다.
  선으로 묶여있다는 것은 테이블끼리 조인할 수 있다는 것(연결된 컬럼이 있다는 것).

테이블을 모아놓은 집합 데이터베이스
데이터베이스는 많은 테이블들로 이루어져 있다.

보통 프로젝트명을 데이터베이스 이름으로 한다
  그리고 메인 폴더 이름도 프로젝트명으로 함.

행 : 데이터

CRUD연산

문자열 데이터 다루는 방법(실무버전)

낫널 많이사용함 현업에서

// 오늘 배울 거
show 테이블이름or디비이름
show columns from tablename;
desc tablename;200526 화요일 수업 메모 키워드

Cn = 컬럼 이름
Tn = 테이블 이름
Dn = 데이터베이스 이름
Jo = 조건문
Ha() = 함수
St = 문자열
Int = 정수
Dt = 데이터 타입
Ind = 인덱스 넘버
inna_ipk = int not null auto_increment primary key

---

==============================

리눅스OS명령어(in terminal)

==============================

MariaDB 켜기
	systemctl start mariadb
		root 입력 > passwd 입력

MariaDB 항상 켜기
	systemctl enable mariadb

mysql(MariaDB) 로그인하기
	mysql -u root -p

방화벽에 MySQL 포트 추가 설정하기
	1. ★루트 계정 접속★
	2. firewall-cmd --add-port=3306/tcp
		cmd : command(명령)
	3. firewall-cmd --permanent --add-port=3306/tcp
		permanent : 영원히 열어놔라.
	// 2, 3번 둘 다 순서대로 해야한다.

==============================

MySQL 명령어 in putty

==============================

exit

MySQL"에서" 유저 원격접속 권한 설정하기
	GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'insert_new_passwd' WITH GRANT OPTION;
		★★★ '%'  >>  @ 앞에 적힌 유저에게 원격 접속 권한을 주는 핵심 키워드.
			- 여기서는 SQL 'root' 유저에게 접속 및 접근 권한을 줌.

==============================

MySQL 명령어 & 문법 in workbench

==============================

create database Dn;
	- Dn이라는 이름의 DB를 생성.
	- use Dn;을 선행하지 않아도 Dn DB를 생성할 수 있음.

show databases;
	★use Dn;을 선행하지 않아도 조회 가능
	- 저장되어있는 DB의 목록들을(이름만) 쭉 표시함.
	- 몇 개의 DB가 있는지는 하단 Messege에서 확인 가능

use Dn;
	- Dn DB를 사용해(use) 작업하겠다.

create table Tn ( Cn Dt );
	★선행 : use Dn;
	- Dn DB 안에 새로운 Tn을 만듦.
	- Tn 테이블에는 Dt 속성을 가진 Cn 컬럼이 만들어짐.

★show tables;
	★선행 : use Dn;
	- Dn DB 안의 모든 테이블들 목록이(이름만) 뜸.
	- 몇 개의 테이블이 있는지는 하단 Messege에서 확인 가능

★desc Tn;
	- Tn 테이블의 세부 "컬럼 정보"를 조회.
	- 컬럼에 속한 데이터들을 조회(select)하는 것이 아님.
	- desc 뒤에는 테이블 이름만 올 수 있음.

★drop
	drop Tn;
		- Tn 테이블과 테이블의 내용을 전부 삭제
	drop Dn;
		- Dn DB와 DB 안의 모든 테이블을 전부 삭제

" \' ", " \" "

char()/varchar()
	- char()/varchar()의 글자 수 제한을 넘으면 디비에서 받아주지 않는다.

null
	null : default value in DB
	null != 0;
	null != " ";
	- "데이터 저장시 값 입력이 필수가 아님"  =>  null

not null
	- "데이터 저장시 필수로 값이 입력되어야 한다"  =>  not null

insert into Tn () values ();의 각 경우별 동작
	1) Tn 테이블에서 (inna_ipk를 제외한) 모든 컬럼에 not null 속성이 없는 경우
		- 실행할 때마다 (inna_ipk를 제외한) 모든 컬럼값이 null인 데이터가 생성됨
	2) Tn 테이블에서 (inna_ipk를 제외한) 하나 이상의 컬럼에 not null 속성이 있는 경우
		- 에러 코드가 뜨고 데이터는 insert되지 않음.
	3) Tn 테이블에서 (inna_ipk를 제외한) 컬럼 중에 default값이 따로 지정되어있는 컬럼이 있는 경우
		- default값이 지정된 컬럼은 지정된 default값이 저장된다.

★default "null값 지정"
	create table Tn (Cn Dt DEFAULT a, ...);
		a  =>  "St", Int, Dt, etc...
		- Cn에 아무 값도 입력되지 않으면 a를 초기값(null값)으로 저장한다.
		- null일 경우의 값을 지정하는 쿼리이므로 not null과 상충한다.
			- 컬럼 설정을 not null + default로 하면 not null이 무시되고 default값이 저장됨.

★primary key "중복 방지"
	- 저장되는 데이터들에 유니크한 값을 붙여, 각 값들이 "중복 없이 처리되도록 하기 위해 만들어짐."
	- 일반적인 데이터 타입은 Int
		★★★ primary key는 1부터 시작한다.
	- 각 값이 서로 달라야 하기 때문에(Unique) not null이어야 함.
	'프라이머리 키를 설정한다'고 표현한다.
	- 같은 키값은 이전 키를 삭제하기 전까지는 중복해서 등록할 수 없다.
	<< 두가지 사용 예시 >>
	1) create table Tn (
			Cn1 int not null auto_increment,
			Cn2 varchar(n),
			PRIMARY KEY (Cn1)
		);
	2) create table Tn (
			Cn1 int not null auto_increment PRIMARY KEY,
			Cn2 varchar(n)
		);

★auto_increment "자동 증가"
	- 프로그램이 키값을 알아서 순서대로 계산해주는 기능.
	- int, not null, primary key 세 개와 함께 쓰인다.
		★ primary key를 입력(지정)하지 않고 auto_increment만 쓰고서 insert into하려고 하면 에러 코드 뜸.
	- insert into할 때 알아서 key값을 계산해 저장해주기 때문에, 해당 컬럼과 데이터를 입력할 필요가 없다.

safe mode 피하기
	★선행 : 해당 테이블에 Key Column이 있어야 함.
	where ~ and keyCn > 0;
		- 키 컬럼은 무조건 1부터 시작되므로 keyCn > 0;은 테이블에 있는 모든 데이터를 의미한다.
	- 리눅스 터미널이나 푸티 창에서는 세이프모드 없이 그냥 명령어대로 수행하므로 주의.

설계해라 = "틀"을 만들어라

concat() "컬럼 내용 및 문자열 합치기"
	concat(A, B, C, ...)
	- A, B, C  =>  all of Dt, Cn, Ha()
	- 컬럼 혹은 문자열을 붙인다.

concat_ws() "문자열 자동 반복 추가"
	concat_ws(A, B, C, ...)
	- A, B, C  =>  all of Dt, Cn, Ha()
	- ,와 , 사이에 맨 앞에 적힌 A를 자동으로 추가한다.
		- 두 컬럼만 붙일 때보다는, 여러 컬럼들을 붙일 때 그 사이에 들어가는 문자가 일정한 경우 유용하다.

★★★substing() "문자열 일부만 가져오기"
	substing(Cn, Ind1)
		- Cn 컬럼의 Ind1번 위치부터 문자열을 불러옴.
	substing(Cn, Ind1, Ind2)
		- Cn 컬럼의 Ind1번 위치부터 Ind2번 위치까지의 문자열을 불러옴.
	★★★인덱스 번호는 1부터 시작한다.
		- 시작 위치를 0으로 적을 시 아무 문자도 출력하지 않는다. (null값은 아님)
	- Ind1에는 마이너스(-)값을 쓸 수 있다.
		- "-1"의 위치는 맨 뒷 문자이다.
		- 마이너스 값 입력시 Ind2가 Ind1보다 절대값이 크면 Ind2의 숫자와 상관없이 Ind1의 숫자만큼만 조회된다.
		ex) substring(description, -5, 10)
			- 뒤에서 다섯 글자까지만 가져옴

★★★replace() "문자열 바꾸기"
	replace(A, B, C)
		- A, B, C  =>  all of Dt, Cn, Ha()
		- A에 B가 있으면 B를 C로 대체해라.

★★★reverse() "문자열 역순으로 뒤집기"
	reverse(A)
		A  =>  all of Dt, Cn, Ha()

★★★char_length() "문자열의 길이"
	char_length(A)
		A  =>  all of Dt, Cn, Ha()
	ex) 이 작가 이름의 문자 개수를 조회하시오.

==============================

기타 정보

==============================

★★★ssh port : 22

★★★mysql(DB) port : 3306

행 : 데이터200527 수요일 수업 메모 키워드

Cn = 컬럼 이름
Tn = 테이블 이름
Dn = 데이터베이스 이름
Jo = 조건문
Ha() = 함수
St = 문자열
Int = 정수
Dt = 데이터 타입
Ind = 인덱스 넘버
inna_ipk = int not null auto_increment primary key
tdn()ouc_t = 
		timestamp default now() on update current_timestamp

---

==============================

MySQL 명령어 & 문법 in workbench

==============================

select문에서 유의사항
	조회에 필요한 컬럼(테이블)을 먼저 찾아서 가져오고,
	그 다음에 "조회 조건(select 옆)"을 붙인다.

!= "not equal"
	(79) (80) (81) 

> "greater than"
	(85)
	>= "greater than or equal to"

< "less than"
	<= "less than or equal to"

count()
	(34★) (35★) (36) (37★) (38★) (39★) (45★) (50)

min()
	(40) (43) (44★)
		(44★) 설명
			group by하고 최소값을 조회해야 할 때는 min()을 쓰자
			select 옆에 min()을 붙이면 굳이 정렬(order by)할 필요도 없다.

max()
	(41) (42) 

sum()
	(46) (47) (51) 

avg()
	(48) (49) 

upper() / lower()
	(1) (2)

replace
	(3)

reverse()
	(4)

upper()
	(5) (33)

concat()
	(5) (6) (8) (10) (28) (33) (47) (D3)

char_length()
	(7)

substring()
	(8)

distinct
	(9) (10) (D1) (34★) (35★) (37★)
		(34★) 설명
			distinct(중복제거)하고 개수 세기(count())
		(37★) 설명
			두 컬럼을 "세트"로 묶어 중복제거하고 개수 세기
			두 컬럼을 합치고 나서 그 값이 중복되는 것들을 없앤 것이다. 각각의 컬럼을 중복제거한 값이 더해져서 나오는 것이 아니다.

group by
	(D2) (38★) (39★) (44★) (45★) (47) (48) (49) (50) (52)
		(38★) 설명
			lname에서 묶어진 값들이 각각 몇개인지 조회.
			
order by
	(11) (12) (13) (14★) (27) (28) (30) (31★) (33) (42) (43) (44★) (47) (49) (50) (52) (78★) (83) (84) 
		(31★) 설명
			elect 바로 우측에 나열되는 컬럼들은 순서대로 1, 2, 3, ... 으로 대체해서 쓸 수 있다.
		(78★) 설명
			실무에서 활용하는 예시 : timestamp 타입을 최신순으로 정렬

★where like
	(21) (22) (23) (26) (29) (36) 

★where not-like
	(80) (83) 

★★★where not-like  vs  where !=
	(82) (83) (84)
	where Cn != "A"
		Cn에서 정확하게 A가 아닌 값만 찾을 수 있음.
	where Cn not like "A"
		Cn에서 정확하게 A가 아닌 값만 찾을 수 있음.
	where Cn not like "%A%"
		Cn에서 A가 포함되지 않은 모든 값을 찾음.

★★★where like "_"  ==>  "1자릿수의 조건을 가진"
	(24) (25) 
	"_"  =>  자릿수 표시. _ 한 개는 한 자릿수.
		_가 적힌 갯수만큼 자릿수가 늘어남.
		자릿수 중간에 문자열이 포함되어 있으면 그 문자열을 그대로 같이 써준다.
		ex) "(02)234-5678"  =>  "(__)___-____"
	문제 예시 : 
		ex1) 3글자 짜리 이름 중에서 xx를 조회하시오
		ex2) xx에서 3자릿수 숫자를 찾아서 yy를 조회

★limit "데이터의 일정 부분만 떼어서 가져오기"
	(15) (16) (17) (18) (19★) (20★) (27) (28) (30) (42) (43) 
	limit Int;
	limit Ind, Int;
		데이터를 일정 부분만 골라서 조회하고 싶을 때 사용
		limit의 자리는 select문의 맨 마지막 부분이다.
		조회하는 데이터의 개수를 제한하는 문제에서 사용.
		★★★ limit의 Ind는 0부터 시작한다.
		★★★ Ind의 명칭은 "offset"이다.
			테이블 조회시 시작 위치가 따로 필요할 때 적는다.
		Int의 명칭은 그냥 "개수"다.
			이 Int의 숫자만큼 데이터를 가져온다.
	ex1) limit 3, 2;
			조회할 데이터의 4번째부터 2개(4번째, 5번째)를 가져옴
	ex2) limit 4;
			0번째부터 4개의 데이터를 가져옴

★sub query(서브쿼리) "쿼리 안의 쿼리"
	(42) (43) 

create-table
	(54)

insert-into values
	(55) (82) 

=====  Date Format  =====

[Dt] date "날짜 저장용 Dt"
	(D4) (54)
	insert시 "YYYY-MM-DD"의 형식으로 저장하는 것이 기본

[Dt] time "시간 저장용 Dt"
	(D5) (54)
	insert시 "HH:MM:SS"의 형식으로 저장

[Dt] datetime "날짜 & 시간 저장용 Dt"
	(D6) (54)
	insert시 "YYYY-MM-DD HH:MM:SS"와 같은 형식으로 저장
	
[Dt] timestamp "현재 날짜/시간을 저장해주는 Dt"
	(75) (76) (77) 
	Cn timestamp default now()
		insert-into시 컬럼값을 입력하지 않아도 현재 시간을 저장해준다.
	Cn timestamp default now() on update current_timestamp
		insert-into시 컬럼값을 입력하지 않아도 현재 시간을 저장해주고, update set을 할 때도 알아서 update set을 할 때의 시간으로 갱신해 저장해준다.
	default now()
		insert-into할 때 아무 값도 입력하지 않으면(null이면) now()를 입력
	on update current_timestamp
		연결된 데이터가 바뀔 때마다(update set) 자동으로 update set을 할 때의 시간으로 저장해준다

[Dt] year

curdate() "현재 연월일 가져오기"
	(56) (57) 
	현재 연월일을 YYYY-MM-DD의 형식으로 가져오는 함수

curtime() "현재 시분초 가져오기"
	(56) (57) 
	현재 시분초를 HH:MM:SS의 형식으로 가져오는 함수
		HH  =>  24시 표기

now() "현재 날짜/시간 전부 가져오기"
	(56) (57) 
	현재 연월일, 시분초를 모두 아래와 같은 형식으로 가져오는 함수
	YYYY-MM-DD HH:MM:SS

day() "日만 가져오기"
	(58) 
	day(A)
		A  =>  날짜 관련 Cn, St
	특정 날짜 데이터의 '일'만 가져오는 함수
	day of month와 같은 의미.

dayname() "요일만 영문자로 가져오기"
	(59)
	dayname(A)
		A  =>  날짜 관련 Cn, St
	특정 날짜 데이터가 해당되는 '요일'만 '영문자'로 가져오는 함수

★dayofweek() "요일만 숫자로 바꿔 가져오기"
	(60)
	dayofweek(A)
		A  =>  날짜 관련 Cn, St
	특정 날짜 데이터가 해당되는 '요일'만 '숫자'로 바꿔 가져오는 함수
	★★★1부터 7까지 순서대로 일~월요일을 나타냄.

★dayofyear() "해당 1년 기준 이 날은 며칠째?"
	(61) 
	dayofyear(A)
		A  =>  날짜 관련 Cn, St
	특정 날짜 데이터가 해당 년도의 1년을 기준으로 며칠째가 되었는지를 '숫자'로 구해주는 함수

month() "月만 숫자로 가져오기"
	(62) (63★) 
	month(A)
		A  =>  날짜 관련 Cn, St
	특정 날짜 데이터의 '월'을 '숫자'로 가져오는 함수
		(63★) 설명
			숫자형 날짜를 가져오는 함수 활용의 좋은 예

monthname() "月만 영문자로 가져오기"
	(64) 
	monthname(A)
		A  =>  날짜 관련 Cn, St
	특정 날짜 데이터의 '월'을 '영문자'로 가져오는 함수

hour() "時만 가져오기"
	(65) 
	hour(A)
		A  =>  시간 관련 Cn, St
	특정 시간 데이터의 '시'만 가져오는 함수
	24시의 형태로 가져옴.

minute() "分만 가져오기"
	(66) 
	minute(A)
		A  =>  시간 관련 Cn, St
	특정 시간 데이터의 '분'만 가져오는 함수

second() "秒만 가져오기"
	(67)
	second(A)
		A  =>  시간 관련 Cn, St
	특정 시간 데이터의 '초'만 가져오는 함수

year() "년도만 가져오기"
	(68) 
	year(A)
		A  =>  날짜 관련 Cn, St
	특정 날짜 데이터의 '년도'만 가져오는 함수
	YYYY의 형태로 가져옴.

date_format() "원하는대로 날짜 포맷 변형"
	(69) 
	date_format(A, "B")
		A  =>  날짜/시간 관련 Cn, Ha()
		B  =>  " " 안에는 연월일시분초 표기법들이 각각 들어갈 수 있음. (이하 표기법)
			%W  =>  요일 표시
			%Y  =>  년도 네자리 표시
			%y  =>  년도 두자리 표시
			%m  =>  월 표시
			%M  =>  월을 영문으로 표시
			%d  =>  일 표시
			%h  =>  시간 표시
			%i  =>  분 표시 ...(기타등등)

datediff() "두 날짜의 차이를 일 수로 가져오기"
	(D7) 
	datediff(A, B)
		A, B  =>  날짜 관련 Cn, St, Ha()
	두 날짜의 차이를 '일 수'로 구해주는 함수
	자매품 timediff()

date_add() "날짜/시간 더하기/빼기1"
	(70) (71) (72) (73) 
	date_add(A, interval ± Int B)
		A  =>  날짜 관련 Cn, St, Ha()
		interval ±  =>  A에다가 Int B만큼을 더하거나 뺀다
		B  =>  second, minute, hour, day, month, year
	YYYY-MM-DD HH:MM:SS의 형태로 가져옴.

± interval "날짜/시간 더하기/빼기2"
	(74★) 
	A ± interval Int B
		A  =>  날짜 관련 Cn, St, Ha()
		± interval  =>  A에다가 Int B만큼을 더하거나 뺀다
		B  =>  second, minute, hour, day, month, year
		(74★) 설명
			± interval Int B를 필요한 만큼 얼마든지 추가할 수 있다.
		가져오는 형태는 A와 B의 유형에 따라서 달라진다.
			only 날짜 ± day, month, year면 날짜만 가져옴
			only 날짜 ± second, minute, hour면 날짜+시간을 가져옴
				only 날짜에 1440분(1일)을 더해도 00:00:00이 붙어서 뜸.

==============================

기타 정보

==============================

mysql 관련 검색은 구글에서 "mysql + 궁금한 거"

어떻게 저장하고 어떻게 불러올 것인가.

레퍼런스 페이지 : 사용법을 알려주는 페이지
	"레퍼런스에서 찾아보다"
	공식 홈페이지의 레퍼런스에서 사용법을 찾아보는 것이 제일 좋음.

잘 조합해야 하고, 효율적인 흐름을 만들어야 한다.

200527 수요일 수업 메모





★★★ upper(), lower() : 대문자로 변경, 소문자로 변경
upper(), lower() 안에는 값(컬럼)이 하나씩밖에 들어가지 못한다.

---(1) 예시 (books 테이블)
// 타이틀에 저장된 문자열을 대문자로 바꿔서 조회.
select upper(title) from books;

---(2)
// 책제목을 소문자로 가져와서  My favorite book is 책 제목(소문자)의 형태로 조회
select concat("My favorite book is ", lower(title)) as favorite_book
from books;





---이상 실무에서 써먹는 스트링 함수들(어제거까지)
---이하 깃헙에 올려진 16. DB String 문제들(books 테이블 활용)





---(3) 예제 : 타이틀의 공백을 ->로 바꿔서 나오도록 조회.
select replace(title, " ", "->") as "title"
from books;

---(4) 예제 : 다음 컬럼처럼 나오게 조회하시오
select author_lname as forwards, reverse(author_lname) as backwards
from books;

---(5) 예제 : 다음처럼 이름을 합치되 대문자로 합쳐서 조회하시오.
select upper(concat(author_fname, " ", author_lname)) as "full name in caps"
from books;

---(6) 예제 : 다음처럼 타이틀 컬럼과 년도 컬럼을 합치되, was released in이 들어가도록 합쳐서 조회하시오.
select concat(title, " was released in ", released_year) as blurb
from books;

---(7) 예제 : 다음처럼 타이틀과, 타이틀에 적힌 글자의 갯수가 나오도록 조회하시오.
select title, char_length(title) as "character count"
from books;

---(8) 예제 : 다음처럼 조회하시오. 단, 숏타이틀은 앞에서 10글자까지만 나오고, 뒤에 ...이 나오도록 만들고, author는 이름 두 개 컬럼을 합치고, quantity는 원래 숫자에 in stock이 붙도록 조회하시오.
select concat(substring(title, 1, 10), "...") as "short title",
concat(author_lname, ",",author_fname) as author,
concat(stock_quantity, " in stock") as quantity
from books;

---다 잘 푸로따

---이하 조언
★★★ 뼈대 먼저 만들고(들어갈 컬럼들 먼저 찾아서 가져오고) 거기에 "조회 조건"을 붙인다





---이상 문제 풀기 끝





★ distinct (단순 중복 제거)
// select 옆, 컬럼이름 앞에서 쓰임. 조회할 컬럼의 중복값들을 제거함.

---(9) 디스팅트(distinct) 예시(books 테이블)
// 작가 이름에 중복된 이름 제거하고 유니크하게 만들어서 조회
select distinct author_lname from books;
---(9) 결과
조회하되 중복값은 제거하고 조회함.

---(10) 예시
// 풀네임을 중복 제거해서 조회하기
// 즉 합친 컬럼값에서 중복을 제거함
select distinct concat(author_fname, " ", author_lname) from books;





★★★ 정렬, 순서(books 테이블)

"순서가 있다 >>> order by"

---(11) order by 예시
// 작가의 라스트 이름으로 정렬해서 라스트 이름 조회
select author_lname
from books
order by author_lname;
---
문법의 정렬 순서 유의

---(12) order by 예시
// 책의 이름을 조회하되, 알파벳 반대 순으로 조회하기
select title
from books
order by title desc;

---(13) order by 예시
// 출판년도의 오름차순으로 책 제목과 출판 년도를 조회
select title, released_year
from books
order by released_year asc;

---(14) order by 예시(여러개의 정렬 조건)
select title, author_fname, author_lname
from books
order by author_lname asc, author_fname asc;
---(14) 설명
조건이 여러개인 경우 앞에 적힌 order by를 먼저 정렬한 다음, 정렬한 것 안에서 뒤에 적힌 조건으로 또 정렬함





★★★ limit, offset

두개 다 상당히 많이 쓰는 기능들.
// 메모 못한 거 오전 10:48 2020-05-27
★ limit : 나눠서 데이터를 처리하고 싶을 때 쓴다.
  나눠서 조회하는 기능.
  ★ limit은 문장의 맨 뒤에 적는다.
  ★조회하는 데이터 개수를 제한하는 문제★에서 사용.
  ★★★ 리미트의 숫자는 0부터 시작함.
  숫자를 하나만 적으면 시작부터의 "개수"
  숫자를 두 개를 적으면 앞에 숫자는 "인덱스 번호", 뒤의 숫자는 "개수"
    ★★★ 여기서 앞에 적힌 숫자의 명칭이 "★offset★"이다.
    뒤의 숫자는 따로 명칭 없고 그냥 개수.

---(15) limit 예시
// 제목을 3개만 조회하시오. 
select title
from books
limit 3;
---(15) 설명
가장 앞에 저장되어있는 데이터부터 "3개"를 가져온다.

---(16) limit 예시(★원하는 위치에서부터 n개를 가져오기)
// "3번째" 데이터부터 "4개"의 데이터를 가져와서, 책 제목만 조회하시오.
select title
from books
limit 2, 4;
---(16) 설명
시작할 위치(2)부터 4개를 가져온다.
실무에서 페이징할 때 사용한다.

---(17) limit 예시
select title from books limit 6;
select title from books limit 0,6;
---(16) 설명
위 두개는 같은 결과가 나옴.

---(18) 정렬해서 가져오기(order by, limit)
// 책 발행년도가 최신인 책 5권의 책 제목과 발행년도로 조회하시오.
// 책 5권(limit), 최신(order by)
select title, released_year
from books
order by released_year desc
limit 5;

---(19)
// 발행된지 가장 오래된 책을 찾아서 제목과 발행년도, 작가 lname을 조회
select title, released_year, author_lname
from books
order by released_year asc
limit 1;
---(19) 설명
가장 ~한 것은 1개만 찾으라는 뜻으로 이해하기.

---(20) limit 예시★★★
// 책 제목을 가져오되, 5번째 책부터 전부 가져오시오.
1) 방법1
select title
from books
limit 4, 9999999999;
2) 방법2
select count(*) from books;
// 결과 16개
select title
from books
limit 4, 16;





★★★ like (where - like "")

// search, 검색용
  // 실무에서는 전화번호 중간자리, 끝자리, 이메일 주소(@naver.com) 등등의 데이터들을 콕 집어서 찾을 때 사용.

---(21) like 예시
// da로 시작하는 작가의 이름(fname)을 찾아서 책 제목과 작가명(fname)을 조회하시오.
select title, author_fname
from books
where author_fname like "da%";

---(22) like 예시
// da가 들어있는 작가의 이름을 찾아서, 책 제목과 작가명을 조회.
select title, author_fname
from books
where author_fname like "%da%";

---(23) like 예시
// 제목에 the로 시작하는 것과, the가 들어있는 것, the로 끝나는 데이터들의 제목을 조회
select title
from books
where title like "the%";
----------------
select title
from books
where title like "%the%";
----------------
select title
from books
where title like "%the";

★★★★★★★★★★★ like "_" ★★★★★★★★★★★

// ★ _ : 자릿수 표시. ★"_"의 갯수만큼 "자리수"★를 뜻합니다.
ex) 1자리수는 _, 2자리수는 __, 3자리수는 ___
  // 문자열의 경우 중간에 추가되는 문자가 있으면 같이 쓰면 됨.
  ex) "(02)234-5678" >> "(__)___-____"
  // ★★★ 자릿수 문제 나오면 where like "_"
  ex1) 3글자 짜리 이름 중에서 xx를 조회하시오
  ex2) xx에서 3자릿수 숫자를 찾아서 yy를 조회

---(24) like _ 예시 
// stock_quantity의 자릿수가 3자리수인 데이터의 책 이름과 quantity를 조회
select title, stock_quantity
from books
where stock_quantity like "___";
---(24) 결과 일부
title    stock_quantity
A Hologram for the King: A Novel    154

---(25) like _ 예시
// 제목이 8자리로 되어있는 것 찾기
select title
from books
where title like "___ ______";
---(24) 결과값
title
The Circle





---이하 깃헙에 올려진 17. DB 실습문제 2(books 테이블 활용)





---(26) 예제1 : 제목에 stories가 포함된 데이터를, 제목만 조회하시오.
select title
from books
where title like "%stories%";
---
★like 뒤에 "" 안에 내용은 대소문자 안가림.

---(27) 예제2 : 내용이 가장 긴 책을 찾아서, 제목과 페이지 수를 조회하시오.
select title, pages
from books
order by pages desc
limit 1;

---(28) 예제3 : 가장 최근에 발간된 책 3권을 찾아서, 책의 제목과 발간 년도를 조회하되, 다음처럼 하이픈(-)을 붙여서 조회하시오. (컬럼명은 summary)
select concat(title, " - ", released_year) as summary
from books
order by released_year desc
limit 3;

---(29) 예제4 : author_lname에 공백(" ")이 들어있는 사람의 책 제목과 author_lname을 조회
select title, author_lname
from books
where author_lname like "% %";

---(30) 예제5 : stock_quantity가 가장 적은 책 3권의 title, year, stock_quantity를 조회하시오
select title, released_year, stock_quantity
from books
order by stock_quantity asc, released_year desc
limit 3;

---(31) 예제6 : author_lname과 title로 정렬한 후, title과 author_lname을 조회하시오
select title, author_lname
from books
order by author_lname asc, title asc;
---다른 답(새로운 정보)
select title, author_lname
from books
order by 2 asc, 1 asc;
---(31) 설명 ★★★
select 옆에 적혀있는 순서대로 숫자 1, 2, ... 등으로 바꿔 쓸 수 있다.
  여기서 1은 title, 2는 author_lname이 된다.
  
(32) null ㅋㅋ 숫자 잘못 적음

--(33) 예제7 : author_lname으로 정렬하되, "My favorite author is "를 붙여서 조회하시오.
select upper(concat("My favorite author is ", author_fname, " ", author_lname, "!"))
as yell
from books
order by author_lname;

--- 다 잘풀었으 :3





★★★ count() : 갯수 세기 + group by : 묶은 다음 연산 ★★★

// distinct와 group by의 차이

// (D1) distinct
  // select 옆에 붙어서 단순하게 중복 제거 용도로만 사용됨. 조회(select)용
  
// (D2) group by
  // from 안에 있는 컬럼(들)을 "먼저 묶어준 다음" select에서 "연산"해 조회하는 용도로 사용
  // select에서 아무 연산이 없으면 그냥 묶은 데이터에서 제일 첫 순서의 데이터를 가져옴.
    // 의미가 없음.
	
★ 이해를 돕기 위한 CPU의 처리 과정
  group by 처리 과정  ::  from > group by > select
  distinct 처리 과정  ::  from > select-distinct

---(34)
// 작가는 모두 몇명입니까(fname은 전부 몇개인가)
// 1)중복제거 후 중복제거한 데이터들의 2)개수 세기
select count(distinct author_fname) from books;

---(35)
// lname은 전부 몇개입니까
select count(distinct author_lname) from books;

---(36) ★★★
// 책 제목에 the라고 들어있는 책은 몇권인가??
// ★★★ 개수 세기는 모다 count다.
select count(*)
from books
where title like "%the%";
---(36) 설명
★조건을 만족하는★ ★전체★ 데이터의 개수를 셀 때는 count(*)
?? 이거 count(distinct title)이어야 하는 거 아닐까..?

---(37) ★★★
// 작가의 lname과 fname 둘 다 중복 제거한 갯수를 구하시오.
// 중복 제거 2개하기
select count(distinct author_lname, author_fname)
from books;

---(38) group by ★★★
// 각각의 lname의 갯수
select author_lname, count(*)
from books
group by author_lname;
---

---(39)
// 년도별 발간된 책은 몇권인가?
select released_year, count(*)
from books
group by released_year;

---(40)
// 책 발간년도가 가장 최소인 책 연도를 구하시오
select min(released_year)
from books;
---
group by는 같은 값들끼리 묶어놓은 다음 "묶인 값들의 ★각각의★ 평균, 합, 최소, 최대 등의 연산과 같이 쓴다.

order by로 min()이나 max()처럼 조회하려는 경우, 하나로 전부 묶이는 게 아니면 맨 뒤에 limit 1;이 붙어야 한다.
-- 최소나 최대값을 구하는 경우 같은 결과가 도출되더라도 min(), max()가 order by ~ limit보다 훨씬 효율적이다.
---(40) 결과
min(released_year)
1945

---(41)
// 페이지 수가 가장 긴 책은 몇 페이지짜리 책인가?
select max(pages)
from books;
--- 결과
max(pages)
634

---(42) ★★★★★★★★★★★★★
// 페이지 수가 가장 많은 책의 책 제목과 페이지 수를 조회하라
1) ★서브쿼리★ 쓰기
select title, pages from books
where pages = (select max(pages) from books);
---(42) 설명
(select max(pages) from books) => 서브쿼리 쓰는 방식
---
2) 정렬 방법 쓰기
select title, pages from books
order by pages desc
limit 1;
---(42) 설명
위의 두 값은 같음.
두가지 중 편한 방법으로 쓴다.

---(43) order by 예제
// 페이지 수가 가장 작은 책의 제목과 페이지 수를 조회하시오
1) 내가 쓴 거
select title, pages
from books
order by pages asc
limit 1;
---
2) 다른 방법
select title, pages
from books
where pages = (select min(pages) from books);

---(44) group by 예시
// 작가별로 각 작가의 최초 책 발간 년도를 조회하시오.
// 조회시, 작가의 이름도 나오도록 조회하시오.
// author_fname, author_lname
1) 내가 쓴 거
select concat(author_fname, " ", author_lname) as "name", released_year
from books
group by author_fname, author_lname
order by released_year asc;
---
2) ★★★★★강사님 방법 (이렇게 해 주는 게 맞음)
select concat(author_fname, " ", author_lname) as "name", min(released_year)
from books
group by author_fname, author_lname;
---
위에 두개가 결과는 같은데 2)로 써주는 게 확실하다고 함.

---(45) group by 예제
// 각 작가별로, 자신이 쓴 책의 페이지 수가 가장 많은 책의 페이지 수를 조회하시오.
// 작가 이름도 같이 나오도록 조회.
select concat(author_fname, " ", author_lname) as "name", max(pages)
from books
group by author_fname, author_lname;
---
!! 분석 필요 내가 풀은 거 아님. >> 직접 풀어보고 이해함.

---(46) 
// 북 테이블에 있는 모든 책의 페이지 수를 다 더하면 몇 페이지입니까?
select sum(pages) from books;

---(47) group by 예제
// 각 작가별로 자신이 지금까지 쓴 책의 총 페이지 수는 얼마인지 조회하시오
// 작가 이름도 같이 나오도록 조회.
select concat(author_fname, " ", author_lname) as "name", sum(pages) as total
from books
group by author_fname, author_lname
order by total;
---(45) 설명
★★★ ~별  >>  group by
sum(pages) as total을 해서 order by 옆에 total을 넣음.

---(48) avg() 예제
// 책 출간 년도의 평균을 알고 싶습니다.
select avg(released_year) from books;
---(48) 설명
별도의 이야기가 없으면 "전체"라고 알면 됨.
여기서는 전체 평균.

---(49) avg() + group by 예제
// 출간 년도가 같은 책들의 stock_quantity 평균은 얼마인지 조회하시오.
// 출간 년도도 같이 조회되도록 하시오.
select released_year, avg(stock_quantity)
from books
group by released_year
order by released_year desc;
---
★★★ ~가 같은  >>  group by

---(50) group by 예제
// 각 발간 년도마다 몇 권의 책이 발간되었는지 조회하세요.
// 년도도 같이 나오도록 조회하세요.
select released_year, count(title)
from books
group by released_year
order by released_year;
---
2) 강사님 작성
select released_year, count(*)
from books
group by released_year
order by released_year;
---
★★★ 각 ~ 마다 >> group by
title에 중복이 없으면 title을 써도 된다. !!!
  !! 는 말이 뭔말인지 이해가 안간다. 이해 갈 거 같음.
★★★ 그냥 묶은 것들의 전체 카운트를 세주는 *이 정확하다고 함.

---(51) 
// 이 테이블에 있는 stock_quantity는 전부 몇입니까?
select sum(stock_quantity)
from books;

---(52) group by 예제
// 각 발간 년도별로, 책의 갯수와 평균 페이지 수를 조회하세요.
// 년도도 같이 조회되도록 하세요.
select released_year, count(*), avg(pages)
from books
group by released_year
order by released_year;
---good
★★★ 갯수 : count(*)
★★★ 각 ~ 별로  >>  group by



// (D3) concat 안에 숫자값의 컬럼을 넣을 때 팁
concat() 안에 숫자값이 돌아오는 함수(count() 등등)를 넣었을 때 오류가 난다면,
숫자 함수(*)를 " "(공백)+||+숫자함수(*)의 형식으로 넣어주면 잘 돌아간다고 한다.
---(53) 예시
select concat(a, b, count(*)) 가 안되면
    select concat(a,b," "||count(*)) 이렇게 적어주면 됨



★★★ 날짜 입력하기 (날짜 포맷)

// 시간 순으로 오더바이하는 작업이 많으므로 실무에서는 날짜 입력하는 컬럼은 항상 저장한다.

(D4) date : "YYYY-MM-DD" 의 형식으로 저장
  ex) "2020-05-26"

(D5) time : "HH:MM:SS" 의 형식으로 저장
  ex) "23:11:23"

(D6) datetime : "YYYY-MM-DD HH:MM:SS"의 형식으로 저장

---(54) 실습을 위해서 테이블 새로 하나 만듦
create table people2
(
name varchar(100),
birthdate date,
birthtime time,
birthdt datetime
);
---
★★★ 테이블 작성시 데이터 타입 입력에 유의
date : 날짜 저장 데이터 타입
time : 시간 저장 데이터 타입
datetime : 날짜 & 시간 저장 데이터 타입

---(55) 데이터 입력
insert into people2 (name, birthdate, birthtime, birthdt)
values ("Padma", "1989-11-11", "20:07:35", "1989-11-11 20:07:35");

insert into people2 (name, birthdate, birthtime, birthdt)
values ("Larry", "1992-10-21", "13:17:30", "1992-10-21 13:17:30");
-------------------


curdate() 함수 : 현재 연월일을 가져옴
curtime() 함수 : 현재 시간(시분초)를 가져옴
now() 함수 : 현재 날짜 + 시간을 가져옴

---(56) 예시
// 현재 날짜를 가져오는 함수
select curdate();
// 현재 시간을 가져오는 함수
select curtime();
// 현재 날짜/시간을 모두 가져오는 함수
select now();

---(57) 예시
insert into people2 (name, birthdate, birthtime, birthdt)
values ("Mike", curdate(), curtime(), now());
★★★ 등록되는 현재 시간 기준은 위 인서트가 등록되는 시간 기준임.





필요한 날짜의 '일'만 가져오는 함수 : day()
---(58) 예시
select name, day(birthdate) from people2;



해당 날짜의 요일만 불러오는 함수 : dayname()
---(59) 예시
select name, dayname(birthdate) from people2;



요일을 숫자로 불러오는 함수 : dayofweek()
---(60) 예시
// 1:일요일 2:월요일 ... 7:토요일
select name, dayofweek(birthdate) from people2;



특정 날짜가 년 일수를 기준으로 며칠째가 되었는지를 구해주는 함수 : dayofyear()
---(61) 예시
select name, dayofyear(birthdate) from people2;



특정 날짜 데이터의 월을 숫자로 가져오는 함수 : month()
---(62) 예시
select name, month(birthdt) from people2;
ex) 10월이 생일인 사람을 조회하시오



---(63) 위 예시를 쿼리문으로 만들면 아래와 같음
select name
from people2
where month(birthdt) = 10;



해당 월을 영문으로 조회하는 함수 : monthname()
---(64) 예시
select name, monthname(birthdt) from people2;



"시간"을 조회하는 함수 : hour()
---(65) 예시
select name, hour(birthdt) from people2;
ex) 11시에 발생한 데이터만 가져오시오. (통계 페이지 작성시 활용)



"분"을 조회하는 함수 : minute()
---(66) 예시
select name, minute(birthdt) from people2;



"초"를 조회하는 함수 : second()
---(67) 예시
select name, second(birthdt) from people2;



"년도"를 조회하는 함수 : year()
---(68) 예시
select name, year(birthdt) from people2;





★ 날짜/시간 포맷팅하기

---(69) 예시(문장 3개)
select date_format(birthdt, "Was born on a %W") from people2;

select date_format(birthdt, "%Y/%m/%d") from people2;

select date_format(birthdt, "%Y/%m/%d at %h:%i") from people2;
---(69) " " 안에 들어가는 요일, 날짜, 시간 작성법(전부는 아님)
%W : 요일 표시
%Y : 년도 네자리 표시
%y : 년도 두자리 표시
%m : 월 표시
%M : 월을 영문으로 표시
%d : 일 표시
%h : 시간 표시
%i : 분 표시
// 자세한 표시 방법은 레퍼런스 페이지 참고하기
// 외울 건 아니고 필요할 때 찾아보면 됨.

검색시 mysql + 궁금한 거(함수이름 등)





★★★ 날짜 연산하기
---(D7) 두 날짜의 차이를 "일수"로 구해달라. : datediff()
select datediff(now(), birthdate) from people2;

// date_add()
---(70) interval 1 month >> 한달 후
select birthdt, date_add(birthdt, interval 1 month) from people2;

---(71) interval 10 second
select birthdt, date_add(birthdt, interval 10 second) from people2;

---(72) interval -15 day
select birthdt, date_add(birthdt, interval -15 day) from people2;
---(73) interval -3 year
select birthdt, date_add(birthdt, interval -3 year) from people2;

// date_add()의 다른 표현방식
---(74)
select birthdt, birthdt + interval 1 month from people2;
select birthdt, birthdt - interval 5 month from people2;
select birthdt, birthdt + interval 15 month + interval 10 hour from people2;
  // 더하기빼기 무한 추가 가능.





★★★ 타임스탬프timestamp로 처리하기(좀 더 실무적)

timestamp : 데이터 타입임. 계속 현재 시간으로 데이터를 저장해주는 속성이 있음.

-----테이블 생성
---(75)
// 자동으로 메세지를 입력한 당시의 시간이 저장되도록 만들기
// 메세지 작성시 시간은 아무것도 입력 안 할테니까 자동으로 현재시간 저장하라. 즉 null값을 현재시간으로 저장해라.(default)
	// 실무에서는 컬럼을 만들 땐 보통 아래와 같이 작성한다.
create table comments (
content varchar(100),
created_at timestamp default now(),
---(76) ★★★
// 업데이트시(update-set) 시간을 자동으로 저장해주는 컬럼 생성
changed_at timestamp default now() on update current_timestamp
);

---(77) 데이터 인서트
insert into comments (content)
values ("Hello");

insert into comments (content)
values ("Goodbye");

insert into comments (content)
values ("I found");
----------

★★on-update : 
"업데이트"를 실행하면(update-set) 이게 실행됨
위 예시(76)에서는 업데이트한 시간을 기록함(current_timestamp)

----------

update comments set content = "hi"
where content = "hello";

---(78)
// 실무에서 타임스탬프 타입의 컬럼을 활용하는 방식(정렬)

select * from comments
order by created_at desc;

select * from comments
order by changed_at desc;

----------





★★★ not equal : !=
---(79) 예시
// 2013년이 아닌 데이터만 조회하시오
select title from books
where released_year != 2013;

---(80)
// 책 제목에 대문자W가 들어있지 않은 책들만 제목으로 조회하시오.
1) 내가 푼 거 (!=)
select title
from books
where title != "%W%";
-- 틀렸음. W 나옴.
2) 다시 풀었음 (not like)
select title
from books
where title not like "%W%";
--- 때려맞췄는데 맞았음. 2)가 맞음.

---(81)
// fname이 Neil이 아닌 사람들의 책 제목만 조회하시오.
select title
from books
where author_fname != "Neil";

---(82)
// ★★★ 상단 예시 두개 중 아래 것이 != 이어야 하는 이유
  // ★★★ not like과 !=의 차이
// 예시를 위해 데이터를 만듦
insert into books (title, author_fname, author_lname, released_year,
stock_quantity, pages)
values ("Hell", "Neil Mike", "Gaiman", 2020, 100, 742);

---(83)
// (not like) 아래 문장은 Mike를 "포함한" 데이터를 조건에서 제외하므로 Neil Mike를 제외함
select title
from books
where author_fname not like "%Neil%"
order by book_id desc;

---(84)
// ( != )아래는 "정확하게" Neiil이 아닌 사람만 조회. Neil Mike는 조회함.
select title
from books
where author_fname != "Neil"
order by book_id desc;

---(85)
// greater than : ~보다 크다
// 연도가 2000년 이후로 발간된 책의 제목과 년도를 조회하되, 발간 년도를 최신순으로 조회하시오.
select title, released_year
from books
where released_year >= 2000
order by released_year desc;
---푸로따 맞았다
구글링해보니까 실제 greater than의 정확한 정의는 >=가 아니라 >임.






=======================================

OS DB SQL 자료 깃헙에 있음.

오늘은 새로 배우는 거에 더해서 복습도 포함되어 있음.

팀별 프로젝트 없음. 개인 프로젝트만 있음.
팀 하고싶으면 하고 아니면 말고.

6/1~6/3 휴강 6/4 목요일 시험.
학원 종강일 10/27까지 늘어남.

저장한 데이터를 불러오는 것이 더 중요함.
"어떻게 불러올 것인가"에 대해서.

★ 레퍼런스 활용
사용법을 알려주는 페이지 : 레퍼런스 페이지
공식 페이지에서 사용법을 보는 것이 제일 좋다.

우리가 하는 거는 조합해서 흐름을 만드는 것.

200528 목요일 수업 메모





★ and : 여러 조건이 '그리고'라는 의미로 해석 될 때 사용.

(1) 작가의 lname이 Eggers이고 발간 년도가 2010년 이상인 책들의 책 제목과 작가 lname을 조회하라.
select title, author_lname
from books
where author_lname = "Eggers" and released_year >= 2010;
-- 비교 조건 좀 잘 확인하자. ~이상 ~이하 등등

(2) 작가 이름이 Eggers이고 발간 년도가 2010년 이상이고 책제목에 novel이 포함된 책들의 모든 컬럼을 전부 조회하시오
select *
from books
where author_lname = "Eggers" and released_year >= 2010 and title like "%novel%";
-- good
-- 색인시 대소문자 가리지 않음 주의.





★ or : 또는, ~거나 이렇게 해석될 때 사용

(3) 작가 이름이 Eggers 또는 발간 년도가 2010년 이상인 책들만 책 제목과 작가 이름, 발간 년도로 조회하시오.
select title, author_lname, released_year
from books
where author_lname = "Eggers" or released_year >= 2010;

(4) 작가 이름이 Eggers이거나 발간 년도가 2010년 이상이거나 stock_quantity가 100 이상인 책들만, 모든 컬럼을 조회하시오.
select *
from books
where author_lname = "Eggers" or released_year >= 2010 or stock_quantity >= 100;





★ between : a와 b 사이의 값으로 조회해달라. a부터 b까지
-- between은 and 연산자와 서로 대체해도 됨.

(5) 발간 년도가 2004년 이상이고 2015년 이하인 책 제목만 조회하시오.
select title
from books
where released_year >= 2004 and released_year <= 2015;

(6) 발간 년도가 2004년부터 2015년 사이(between)에 나온 책 제목만 조회하시오. (5)와 같은 말
select title
from books
where released_year between 2004 and 2015;
-- (5)와 (6)의 결과는 같음.

(7) 책 발간 년도가 2004년과 2015년 사이에 발간된 책이 아닌 것들만 책 제목을 조회하시오.
select title
from books
where released_year not between 2004 and 2015;
-- 이걸 between 없이 쓰면
select title
from books
where released_year < 2004 or released_year > 2015;

★★★(8) people2 테이블에서 birthdt가 1990년부터 2010년 사이에 태어난 사람의 이름과 birthdt를 조회하시오.
★★★ 특정 날짜 기간을 조회하는 방법
-- (   방법1  )  문자열로 직접 날짜를 지정할 때
select name, birthdt
from people2
where birthdt between "1990-01-01" and "2010-12-31";
-- (  방법2  )  year()로 년도만 뽑아오기
select name, birthdt
from people2
where year(birthdt) between "1990" and "2010";
-- (  방법3  )  캐스팅(데이터 타입 바꾸기) : 문자열을 datetime 데이터타입으로 바꿈.
select name, birthdt
from people2
where birthdt between cast("1990-01-01" as datetime)
			  and cast("2010-12-31" as datetime);
-- 그냥 따옴표와 cast한 데이터의 차이
1) select "1990-01-01";
2) select cast("1990-01-01" as datetime);
-- 1)의 데이터 타입은 스트링(varchar), 2)의 데이터 타입은 datetime. 출력시에도 차이가 있다.





=====  예제 6개 : 깃헙 DB 실습문제 3  =====

(9) 1. 작가가 Eggers 또는 Chabon이 쓴 책의 모든 컬럼을 조회하시오.
select *
from books
where author_lname = "Eggers" or author_lname = "Chabon";

(10) 2. 1980년 이전에 쓴 책 중 pages 수가 500페이지 이하인 책들의 책 제목과 페이지 수를 조회하세요.
select title, pages
from books
where released_year <= 1980 and pages <= 500;
-- released_year < 1980 (1980년도가 표함되면 안 됨)
-- a 중 b => and. a에 있는 조건에서 b를 찾음. a와 b에 둘 다 해당되는 조건 찾기는 and이므로 and를 써야함.

(11) 3. 작가가 Eggers와 Lahiri인 사람이 쓴 책의 총 페이지 수는 몇 페이지인지, 총 페이지 수를 조회하세요.
select sum(pages)
from books
where author_lname = "Eggers" or author_lname = "Lahiri";

(12) 4. stock_quantityrk 60에서 100 사이의 책들 중에서 발간년도가 가장 오래된 책은 몇년도인지 조회하세요.
-- (  1  )  min() & between 사용 (내가 쓴 거)
select min(released_year)
from books
where stock_quantity between 60 and 100;
-- (  2  )  order by & limit 사용 (강사님)
select released_year
from books
where stock_quantity between 60 and 100
order by released_year asc
limit 1;

(13) 5. 책 제목이 30글자 이상인 책들에 대해서, 책의 갯수와 stock_quantity의 총합을 조회하세요.
-- (  1  )  내가 풀은 거
select count(title), sum(stock_quantity)
from books
where char_length(title) >= 30; -- 공백 포함인지?? ㅇㅇ 자바든 어디서든 문자열의 길이는 공백 포함.
-- (  2  )  강사님이 풀은 거
select count(*), sum(stock_quantity)
from books
where char_length(title) >= 30;
-- 행(데이터)의 총 개수를 구할 때는 count(*)!!!!!!!!!!!!!

(14) 6. 각 년도별로, 해당 년도에 몇 권이 발행됐는지의 책 갯수와 책 페이지의 총합을 조회하시오.
select released_year as "year", count(*) as cnt, sum(pages) as pages
from books
group by released_year;
-- 이전에는 count(*)를 count(title)로 썼었음.
★★★ group by하고 count하면, group by한 것을 count하라는 이야기이다. sum도 마찬가지임.

==============================





★★★ in / not in : 여러개 중에 포함되어 있는 것들을 가져올 때 / 가져오지 않을 때

(15) Carver, Lahiri, Smith의 책 제목과 이름을 조회하시오.
select title, author_lname
from books
where author_lname in ("Carver", "Lahiri", "Smith");

(16) 2003, 2016, 1996년도에 출간한 책의 제목과 작가 이름을 조회하시오.
select title, author_lname
from books
where released_year in (2003, 2016, 1996);

(17) 2003, 2016, 1996년도가 아닌 책의 제목과 작가 이름을 조회하시오.
select title, author_lname
from books
where released_year not in (2003, 2016, 1996);

(18) ★ 2003, 2016, 1996년도가 아닌 책 중에서 2005년 이후에 출간된 책의 제목과 작가 이름을 조회하시오.
select title, author_lname
from books
where released_year not in (2003, 2016, 1996) and released_year >= 2005;
-- good





=====  예제 5개 : DB 실습문제 4 : JOIN  =====

(19) 1. 각 영화별로, 등장한 배우가 몇 명인지, 영화 제목과 배우 수를 조회하시오.
-- (  1  ) 내가 쓴 거
select f.title, count(a.first_name)
from film_actor as fa
join film as f
on fa.film_id = f.film_id
join actor as a
on fa.actor_id = a.actor_id
group by f.title;
-- (  2  ) 강사님 풀이 ??? 다시 보고 이해하기
select f.title, count(fa.film_id)
from film as f
join film_actor as fa
on fa.film_id = f.film_id
group by f.title;
-- 결과는 같음

(20) 2. Hunchback Impossible 이라는 제목의 영화는, inventory 테이블에 몇개가 존재하는지,
-- 영화제목과 숫자를 조회하시오.
-- (  1  )  내 풀이
select f.title, count(inv.film_id)
from inventory as inv
join film as f
on inv.film_id = f.film_id
where f.title = "HUNCHBACK IMPOSSIBLE";
-- (  2  )  강사님 풀이
select f.title, count(*) as cnt
from film as f
join inventory as inv
on inv.film_id = f.film_id
where f.title = "HUNCHBACK IMPOSSIBLE";
-- 결과는 같음. 그치만 count(*)가 더 나음.

(21) 3. 고객별로 영화를 보는데 얼마를 썼는지(amount), 각 고객의 이름과 해당 금액(amount) 을 조회하시오.
-- (amount가 없으면 0으로 계산)
-- (  1  )  내 풀이 (이프 널 설정은 알터테이블 가서 해벌임.)
select c.last_name, sum(p.amount)
from payment as p
join customer as c
on p.customer_id = c.customer_id
group by c.customer_id;
-- (  2  )  강사님 풀이
select c.first_name, c.last_name, sum(ifnull(p.amount,0) as amount
from customer as c 
join payment as p
on c.customer_id = p.customer_id
group by c.first_name, c.last_name;
-- 결과는 이름 부분 하나 더 추가된 거 말고는 같음. ★★★★★ifnull()!!!!!!!!!!!!!!!!!!!!

(22) 4. 캐나다 사람 대상으로 이메일 마케팅 하려한다. 모든 캐나다 고객의 이름과 이메일을 조회하시오. (이메일 없으면 없다고 표시)
-- 실무와 가까운 문제.
-- (  1  )  내 풀이(이메일 없으면 없다고 표시를 못했네.. 아래는 ifnull 넣어서 수정한 것임.)
select cu.last_name as "name", ifnull(cu.email, "no email") as email
from customer as cu
join address as ad
on cu.address_id = ad.address_id 
join city as ci
on ad.city_id = ci.city_id
join country as co
on ci.country_id = co.country_id
where co.country = "canada";
-- (  2  )  강사님 풀이
select c.first_name, c.last_name, ifnull(c.email, "No Email") as email
from customer as c
join address as a
on c.address_id = a.address_id
join city as ct
on a.city_id = ct.city_id
join country as co
on ct.country_id = co.country_id
where co.country = "canada";

(23) 5. 가족영화만 보고싶다. 따라서 카테고리가 “Family”인 영화의 영화 제목을 조회하시오.
-- (  1  )  내 풀이
select fi.title as title
from film_category as fc
join category as ca
on fc.category_id = ca.category_id
join film as fi
on fc.film_id = fi.film_id
where ca.category_id = 8;
-- (  2  )  강사님 풀이
select f.title
from film as f 
join film_category as fc
on f.film_id = fc.film_id
join category as ca
on fc.category_id = ca.category_id
where ca.name = "Family";
-- 판떼기(table) 붙여놓고(join) 조건(where) 달기.





-- ★★★테이블 설계 : 복수의 연결된 테이블 만들기(primary key를 포함하는 테이블)
-- 데이터 관리는 각각 하되, 필요하면 원할 때 언제든지 합칠 수 있는 테이블들을 설계.
-- 여러 테이블을 설계할 때, 연결고리가 있는 경우.
use mydb;



-- ★★★★★(24) students table, papers table 만들기
-- (24), (25) 자주 잘 뜯어보고 이해하기.

create table students (
id int not null auto_increment primary key,
first_name varchar(100)
);

create table papers (
id int not null auto_increment primary key,
title varchar(100),
grade int,
student_id int,
-- 자동으로 스튜던트 테이블의 컬럼과 연결하기 foreign key() : ()안에 적힌 컬럼은 references 뒤에 적힌 테이블(컬럼)과 연결되어 있다는 뜻이다.
foreign key (student_id) references students(id)
		on delete cascade
);
-- 만약에 students 테이블에서 데이터가 삭제(delete)될 경우, papers 테이블에 해당 id값이 있으면, 같이 삭제하도록 할 수 있는 문법은 "on delete cascade". foreign key 맨 뒤에 붙인다.
-- 폴인 키로 연결하지 않아도 조인할 수 있지 않나..? 무슨 차이가 있을까.



-- (25) 테이블 데이터 추가하기 : 깃헙 - OS_DB - 16_foreign_table_insert.sql

INSERT INTO students (first_name) VALUES 
('Caleb'), ('Samantha'), ('Raj'), ('Carlos'), ('Lisa');

INSERT INTO papers (student_id, title, grade ) VALUES
(1, 'My First Book Report', 60),
(1, 'My Second Book Report', 75),
(2, 'Russian Lit Through The Ages', 94),
(2, 'De Montaigne and The Art of The Essay', 98),
(4, 'Borges and Magical Realism', 89);
★★★ student 전에 papers 데이터 추가하려면 오류남.
		student_id가 students 테이블의 id와 연결되야 하는데 students 테이블에 아무 정보가 없으면 연결될 데이터가 없기 때문임.



-- =====  DB 실습문제 5 with students, papers  =====

-- (26) 1. print this : 이름, 제목, 등급을 조회하되, 등급을 내림차순으로 조회.
select s.first_name, p.title, p.grade
from students as s
join papers as p
on s.id = p.student_id
order by p.grade desc;
-- good~



-- (27) 2. print this : ★left join★
select s.first_name, p.title, p.grade
from students as s
left join papers as p
on s.id = p.student_id
order by s.id asc, p.grade asc;
-- gooood



-- (28) 3. print this : ifnull()
select s.first_name, ifnull(p.title, "MISSING") as title, ifnull(p.grade, 0) as grade
from students as s
left join papers as p
on s.id = p.student_id
order by s.id asc, p.grade asc;



-- (29) 4. print this : left join, group by, order by, avg(), ifnull()
select s.first_name, ifnull(avg(p.grade), 0) as average
from students as s
left join papers as p
on s.id = p.student_id
group by s.first_name
order by average desc;
-- ifnull과 avg 바뀌어도 됨. 강사님은 바꿔서 적으셨음.
-- order by 원래는 p.grade로 적었었는데 그러면 안됨. grade는 그냥 점수일 뿐이고, 정렬해야 하는 것은 select 옆에서 평균을 낸 average여야 하는 게 맞음.



-- (30) 5. print this (가르쳐주시는 거) : ★case statements★, if()

-- 홀 if()로 해결했숴
select s.first_name, ifnull(avg(p.grade), 0) as average,
if(avg(p.grade) >= 70, "PASSING", "FAILING") as passing_status
from students as s
left join papers as p
on s.id = p.student_id
group by s.first_name
order by average desc;

-- case statements로 해결하기
select s.first_name, ifnull(avg(p.grade), 0) as average,
	case
		when ifnull(avg(p.grade), 0) >= 70 then "PASSING"
        else "FAILING"
	end as passing_status
from students as s
left join papers as p
on s.id = p.student_id
group by s.first_name
order by average desc;





-- ★★★★★ case statements ★★★★★

-- case when then else end as
-- when 옆에 조건식 then 그려면 이거해라 (when은 계속 추가 가능)
-- else 아니면 이거해라 (else는 없어도 됨)

-- (31) 예시1 (books table)
select title, released_year,
	case
		when released_year >= 2000 then "Modern"
        else "20th Centry"
	end as genre
from books;
-- 테이블 안에 컬럼을 새로 만드는 것이 아니라 조회용 컬럼을 만드는 것임.

-- (32) 예시2 (books table)
select title, stock_quantity,
	case
		when stock_quantity between 0 and 50 then "*"
        when stock_quantity between 51 and 100 then "**"
        else "***"
	end as stock
from books;

-- (33) 예시3 (book table)
select title, stock_quantity,
	case
		when stock_quantity <= 50 then "*"
        when stock_quantity <= 100 then "**"
        else "***"
	end as stock
from books;
-- 예시 2와 같은 결과임.





-- 테이블 설계 - 예제 
-- 테이블 이름 : Reviewers / Series / Reviews
-- Reviewers : id(int, primary key) / first_name(varchar) / last_name(varchar)
-- Series : id(int, primary key) / title(varchar) / released_year(int) / genre(varchar)
-- Reviews : id(int, primary key) / rating(int) / series_id(int, primary key) / reviewer_id(int, primary key)



-- (34-1) 테이블 만들기

create table Reviewers (
id int not null auto_increment primary key,
first_name varchar(100) not null,
last_name varchar(100) not null
);

create table Series (
id int not null auto_increment primary key,
title varchar(100),
released_year year(4), -- 4자리수의 년도를 넣는다는 뜻.
genre varchar(100)
);

-- reviews 먼저 만들려고 했었음.. 연결되는 건 마지막에 만들어라. 연결되어야 할 테이블이랑 컬럼이 먼저 만들어져 있어야 하니까.

create table Reviews (
id int not null auto_increment primary key,
rating float not null,
-- ★★★★★ decimal(2,1) 숫자 두개, 소수점 한자리를 넣는다는 뜻. float이나 double을 써도 됨. 근데 강사님은 실무에서 float을 쓰신댔음.
series_id int,
reviewers_id int,
foreign key (series_id) references Series(id),
foreign key (reviewers_id) references Reviewers(id)
);

-- ★★★ 폴인 키 - 레퍼런스 옆에 있는 테이블.(컬럼) 쓸 때 대소문자 가림. 핵주의.★★★
-- ★★★ 폴인 키에 일부러 on delete cascade 안 넣고 만드심. 차이 비교를 위해서.
-- 테이블 만들고 나서는 알터 테이블의 폴인 키 탭으로 가서 폴인 키 설정들을 바꿀 수 있다.



-- (35) 폴인 키에 on delete cascade를 추가하고 삭제했을 경우
-- students, papers

desc students;
desc papers;

-- foreign key는 papers에 걸려있다.

select * from students;
select * from papers;

-- 1번 학생을 지워본다

delete from students where id = 1;

-- papers에도 1번 학생과 관련된 자료"들"이 전부 지워졌다.

-- ★★★ on delete cascade를 넣어야 할지 말아야 할지는 기획, 정책에 달려있다.
-- ex) 학생이 전학가면 관련 리포트 자료를 지운다. 회원이 탈퇴해도 리뷰는 남긴다.



-- (34-2) reviews 관련 테이블들 데이터 추가하기 (깃헙에 있음)
INSERT INTO Series (title, released_year, genre) VALUES
   ('Archer', 2009, 'Animation'),
   ('Arrested Development', 2003, 'Comedy'),
   ("Bob's Burgers", 2011, 'Animation'),
   ('Bojack Horseman', 2014, 'Animation'),
   ("Breaking Bad", 2008, 'Drama'),
   ('Curb Your Enthusiasm', 2000, 'Comedy'),
   ("Fargo", 2014, 'Drama'),
   ('Freaks and Geeks', 1999, 'Comedy'),
   ('General Hospital', 1963, 'Drama'),
   ('Halt and Catch Fire', 2014, 'Drama'),
   ('Malcolm In The Middle', 2000, 'Comedy'),
   ('Pushing Daisies', 2007, 'Comedy'),
   ('Seinfeld', 1989, 'Comedy'),
   ('Stranger Things', 2016, 'Drama');
  
INSERT INTO Reviewers (first_name, last_name) VALUES
   ('Thomas', 'Stoneman'),
   ('Wyatt', 'Skaggs'),
   ('Kimbra', 'Masters'),
   ('Domingo', 'Cortes'),
   ('Colt', 'Steele'),
   ('Pinkie', 'Petit'),
   ('Marlon', 'Crafford');
   
INSERT INTO Reviews(series_id, reviewer_id, rating) VALUES
   (1,1,8.0),(1,2,7.5),(1,3,8.5),(1,4,7.7),(1,5,8.9),
   (2,1,8.1),(2,4,6.0),(2,3,8.0),(2,6,8.4),(2,5,9.9),
   (3,1,7.0),(3,6,7.5),(3,4,8.0),(3,3,7.1),(3,5,8.0),
   (4,1,7.5),(4,3,7.8),(4,4,8.3),(4,2,7.6),(4,5,8.5),
   (5,1,9.5),(5,3,9.0),(5,4,9.1),(5,2,9.3),(5,5,9.9),
   (6,2,6.5),(6,3,7.8),(6,4,8.8),(6,2,8.4),(6,5,9.1),
   (7,2,9.1),(7,5,9.7),
   (8,4,8.5),(8,2,7.8),(8,6,8.8),(8,5,9.3),
   (9,2,5.5),(9,3,6.8),(9,4,5.8),(9,6,4.3),(9,5,4.5),
   (10,5,9.9),
   (13,3,8.0),(13,4,7.2),
   (14,2,8.5),(14,3,8.9),(14,4,8.9);



-- (36) 예제 : 티비 쇼 제목과 별점을 조회하시오.
select s.title, r.rating
from Reviews as r
join Series as s
on s.id = r.series_id;



-- (37) 예제 : 티비 쇼의 제목별, 별점 평균을 조회하시오.
select s.title, avg(r.rating) as average
from Reviews as r
join Series as s
on s.id = r.series_id
group by s.title;



-- (38) 예제 : 리뷰어의 이름(2가지 다)과 그 사람이 준 별점을 조회하세요.
select concat(rr.first_name, " ", rr.last_name) as name, rv.rating
from Reviewers as rr
join Reviews as rv
on rr.id = rv.reviewer_id;



-- (39) 예제 : 티비쇼 중에서 별점이 없는 것들을 제목으로 조회하시오.
select s.title
from Series as s
left join Reviews as r
on s.id = r.reviewer_id -- r.series_id??????
where r.rating is null;
-- series_id 가 맞음.. series 테이블을 가져오는데 필요없는 reviewer_id랑 연결하지 마세오..



-- (40) 예제 : 각 장르별로, 장르와 장르의 별점 평균을 조회하세요.
select s.genre, round(avg(r.rating), 2) as average
from Series as s
join Reviews as r
on s.id = r.reviewer_id
group by s.genre;
-- ★★★ round(a, b) b는 소수점 아래에 보여줄 자릿수(int)이다.





==================================





웹개발 설명
  클라이언트
    인터넷 익스플로러
    크롬
    사파리
      >> PC & 모바일 둘 다 돌아감.
  웹브라우저에서 동작하는 웹을 개발한다.
  웹 디자이너
  퍼블리셔
    안드로이드는 퍼블리싱이 필요없다. 프로그램 자체에서 퍼블리싱을 해준다.
  웹 개발자 : 프론트엔드 개발자 / 백엔드 개발자
    프론트엔드 : 화면 개발(html, css, ★javascript★)
    백엔드 : 서버 프로그래밍(java, php, python, ★node.js(javascript)★) & DB(SQL)
					인공지능, 딥러닝은 파이썬으로 개발.
  API???????????? 다른 거랑 서버랑 연결하는 거??????????
  ★ 우리는 node.js 배울 거. 요새 제일 흔하게 쓰는거.
  
★★★ select f.*  fa.* 이게 더 정확함.

슈레기 데이터.

★ ERD : Entity Relationship Diagram
말로서 되어있는 요구분석사항을 그림으로 그려내어 그 관계를 도출하는 것이다.
그니까 글을 그림으로 도식화한 것이라는 뜻.

200528 목요일 수업 키워드

Cn = 컬럼 이름
Tn = 테이블 이름
Dn = 데이터베이스 이름
Jo = 조건문
Ha() = 함수
St = 문자열
Int = 정수
Dt = 데이터 타입
Ind = 인덱스 넘버

inna_ipk = int not null auto_increment primary key
tdn()ouc_t = 
		timestamp default now() on update current_timestamp

------------------------------

----------  where  ----------

where and
	(1) (2) (5) (10★)
	where Jo1 and Jo2 and ...

★ where between and
	(6) (8★) (12) (32★) 
	where Cn between Jo1 and Jo2

★ where not-between and
	(7)
	where Cn not between Jo1 and Jo2

where or
	(3) (4) (9) (11) 
	where Jo1 or Jo2 or ...

★ where in ()
	(200521) (15) (16)
  
★ where not in ()
	(200521) (17) (18)

ex1) 조건문에 특정 날짜를 직접 지정할 때 표현 방법
	(8★)
	where Cn between "1991-01-10" and "2020-05-28";
 
------------------------------

group by
	(200521) (14) (29★) (30) (37) (40) 

order by
	(200521) (12) (26) (27) (28) (29★) (30) 
  
------------------------------

year()
	(8★)
	year(A)
		A => Cn, St, Int

★ cast()
	(8★)
	cast(A as Dt)
		A  =>  Cn, St, int

limit
	(12)
	limit Int;

★★★★★ ifnull()
	(21) (22) (28) (29★) (30) 
	ifnull(Cn, a)
		a  =>  "St", Int

★★★ from join on
	(19) (20) (21) (22) (23) (26) (36) (37) (38) (40) 
	from Tn1 Join Tn2 on Tn1.Cn1 = Tn2.Cn1

from left-join on
	(27) (28) (29★) (30) (39) 

------------------------------

desc
	(35)

count()
	(13) (14) 

sum()
	(13) (14) 

min()
	(200521) (12) 

avg()
	(29) (30) (40) 

★ [Dt] year() "Int자릿수의 년도 표시"
	(34-1★) 
	Cn year(Int)
		Cn의 Dt는 year(Int)

concat()
	(38) 

not null
	(24) (34-1★) 

create table
	(24) (34-1★) 

delete-from where
	(35)

inna_ipk
	(24) (34-1★) 

★ [Dt] decimal() "정해진 자릿수만큼까지만 저장"
	(34-1★) 
	정해진 자릿수만큼의 숫자'까지'를 저장/조회해주는 Dt
	decimal(Int1,Int2)
		Int1  =>  정수 자릿수 개수
		Int2  =>  소수점 이하 자릿수 개수

★★★ round() "소수점 이하 자릿수 설정"
	(40) 
	소수점 아래에 보여줄 자릿수 포맷을 지정해줄 때 쓰는 함수
	round(A, B)
		A  =>  숫자 관련 Cn, Ha()
		(실험7) B  =>  Int

[Dt] float
	(34-1★) 

[Dt] double
	(34-1★) 

insert-into values
	(25★) (34-2)
		(25★) 설명
			foreign-key를 가진 테이블의 데이터를 나중에 입력해야 하는 이유 : foreign-key 컬럼이 따르는 다른 테이블의 컬럼에 데이터가 먼저 있어야 연결이 된다.

★★★ foreign-key () references 
	(24) (34-1★) 
	"다른 테이블의 컬럼과 고정적으로 연결"
	★선행 : 연결할 테이블의 생성, 그 테이블에 있는 키 컬럼
	foreign key (Cn1) references Tn(Cn2) on delete cascade
		Cn1  =>  다른 테이블의 키 컬럼(Cn2)과 연결하고자 하려는 이 테이블의 컬럼(Int 타입)
		Tn  =>  연결하려는 다른 테이블의 이름
			Tn 대소문자 가림 주의.
		Cn2  =>  연결하려는 다른 테이블에 있는 키 컬럼
		on delete cascade  =>  다른 테이블에 연결된 키값이 삭제될 때 그 값과 연결된 이 테이블의 데이터도 같이 삭제되도록 한다.
			테이블 설계에 따라 on delete cascade가 필요없는 경우도 있으므로 설계시 주의하기.
		(34-1★) 설명
			create table 할 때 foreign-key 여러개 추가하는 방법
				,(콤마) 쓰고 이 뒤에 다시 foreign-key부터 시작

★ if()
	(30) 

★★★ case문 "여러 경우를 가진 조건문"
	(30) (31) (32★) (33★) 
	"case statements"
		'여러' 경우에 대해 '조회'값을 달리하고 싶을 때 쓰는 조건문
		실제로 값을 변경하는 update set이 아님.
	-----
	case 
		when Jo then A
		else B
	end as C
	-----
		A, B  =>  Cn, all of Dt, Ha()
		C  =>  "St", Int
		(32★) (33★) 설명
			case문의 재미있는 활용 예

------------------------------

테이블 설계 : 복수의 연결된 테이블 만들기
	데이터 관리는 각각 하되, 필요하면 원할 때 언제든지 합칠 수 있는 테이블들을 설계.

Dn, Tn, Cn 모두 되도록이면 생성할 때부터 소문자로 쓰자.

join on에서 컬럼 연결에 주의하기.

★★★
join on한 테이블을 조회할 땐 select Tn1.*, Tn2.* 이게 정확함
	이렇게 조회하지 않고 그냥 select *하면 Tn1에 있는 데이터 x Tn2에 있는 데이터로 조회됨.

웹개발 설명
	웹 브라우저에서 동작하는 웹을 개발한다.
	클라이언트
		IE, Chrome, Safari, ...
		PC, 모바일 둘 다 돌아감.
	웹 디자이너
	퍼블리셔
		안드로이드는 퍼블리셔가 필요없음. 안드가 알아서 해줌.
	웹 개발자
		프론트엔드 : 화면 개발
			html, css, ★javascript★
		백엔드 : 서버 프로그래밍
			java, php, python, ★node.js(javascript)★
			DBMS(SQL)

★ ERD
	Entity Relationship Diagram
	말로서 되어있는 요구분석사항을 그림으로 그려내어 그 관계를 도출하는 것이다.
		그니까 글을 그림으로 도식화한 것을 뜻함.200529 금요일 수업 메모


주요 키워드 : 시험, 시험문제


==============================

예제 (사용 테이블 : Reviewers, Reviews, Series)

==============================

-- 예제 (1), (2) > 조인하고 갯수 세기

(1) 예제 1 : 리뷰 작성을 안 한 사람도 표시하되(0으로), 사람별로 각 리뷰의 갯수, 리뷰의 최소 별점, 최대 별점, 평균 별점(rating) 조회하고, 만약 별점을 준 리뷰 갯수가 0보다 크면 "ACTIVE", 그렇지 않으면 "INACTIVE"로 표시(컬럼 명은 status)
사용하는 컬럼명 : firstname, lastname, count, min, max, avg, status

-- 키워드 : ifnull(), count(*), as, round(), min(), max(), avg(), case-when-then-else-end as, left join-on, group by, order by

(  1  )  내 풀이(계속 변경함)
select r.first_name, r.last_name, count(rv.rating) as COUNT, round(min(ifnull(rv.rating, 0), 2) as MIN,
round(max(ifnull(rv.rating, 0), 2) as MAX, round(avg(ifnull(rv.rating, 0), 2) as "AVG",
	case
		when count(rv.rating) > 0 then "ACTIVE"
        else "INACTIVE"
        end as "STATUS"
from Reviewers as r
left join Reviews as rv
on r.id = rv.reviewer_id
group by r.first_name, r.last_name
order by COUNT, MIN, MAX, AVG;
-- 결국 입맛에 맞게 고쳤당

(  D1  )  강사님 풀이
select r.first_name, r.last_name, count(rv.rating) as count,
	round(min( ifnull(rv.rating,0),2) as min, 
    round(max(ifnull(rv.rating,0),2) as max, 
    round(avg( ifnull(rv.rating,0) , 2) as avg,
    if( count(rv.rating) > 0, "ACTIVE", "INACTIVE") as status
from reviewers as r
left join reviews as rv
on r.id = rv.reviewer_id
group by r.id ;

(  D2  )  강사님 풀이 (case에 조건 추가)
select first_name, last_name, 
	count(rv.rating) as count,
	round(ifnull( min(rv.rating), 0), 2) as min,
    round(ifnull( max(rv.rating), 0), 2) as max,
    round( ifnull(avg(rv.rating), 0), 2) as avg,
    case
		when count(rv.rating) >= 10 then "POWER USER"
		when count(rv.rating) > 0 then "ACTIVE"
        else "INACTIVE"
    end as status
from reviewers as r
left join reviews as rv
on r.id = rv.reviewer_id
group by r.id

★★★ 조인 한 다음에 그룹바이.
-- 조건이 단 두개(true or false)면 if로 쓰는 게 편하고, 조건이 여러개(if, else if)면 case가 좋다.
if()도 else if처럼 조건을 추가해서 쓸 수 있지만 복잡하기 때문에 그냥 위와 같이 활용한다.



(2) 예제 2. 영화 제목으로 알파벳 오름차순 정렬해서, 영화 제목, 별점, 리뷰 작성자 이름(합쳐서)을 조회하시오.

-- 키워드 : round(), concat(), as, join-on, order by

select s.title, round(rv.rating, 1) as rating, concat(r.first_name, " ",r.last_name) as reviewer
from Reviews as rv
join Reviewers as r
on rv.reviewer_id = r.id
join Series as s
on rv.series_id = s.id
order by s.title;

==============================

AWS 가입하기 & 설치하기

==============================

★(깃헙 22번) 링크 참고



(3) 루트 계정 만들기(처음 가입할 때)

구글에서 aws 검색 > 클라우드 서비스 ~ > *1 aws 계정 새로 만들기 > (필수) 동의하고 계정 만들기
> 계정 유형 "개인" > *2주소 등등 영문으로 작성 > 비번 입력 등 쭉쭉 진행 > "무료" 가입

*1 관리자들은 root 사용자 생성, 직원들은 IAM 생성. 수업에서는 root 사용자 생성
*2 "영문 주소 검색"을 구글에 검색해서 변환



(4) 일반 사용자 추가하기

서비스 > IAM 검색 > 좌측 사용자 > 사용자 추가 > 사용자 이름 작성 > AWS Management ~ 체크 > 다음 > 그룹에 사용자 추가 > 그룹 생성 > admin(관리자) > AdministratorAccess 체크 > 그룹 생성 > 다음 > 태그는 해도 되고 안 해도 됨. > 검토 > 사용자 만들기

-- MFA : 이중인증(구글 인증 앱 설치 필요. 시간 오래걸림)
-- 사용자 추가 창 > .csv 다운로드 > 유저네임/패스워드 콘솔 로그 링크(접속 링크)를 볼 수 있음.
-- 사용자 추가 창에서 비밀번호 표시 가능
-- IAM > 사용자에서 만든 사용자 확인 가능
-- IAM 사용자 로그인 링크 : 사용자한테 이걸로 로그인하라고 보내주는 링크
-- IAM > 대시보드 > 사용자 지정 > 계정 별칭 지정 가능 > 링크 앞부분이 바뀜



(5) 일반 사용자로 로그인하기

유저 로그인 링크로 접속 > 일반 사용자 추가시 작성했던 사용자 이름 적기 > 패스워드 입력(복붙) > 로그인

-- 앞으로는 일반사용자로 로그인



(6) EC2서버(CentOS) 만들기

*1 서울 서버로 바꾸기 > 실행중인 인스턴스 > 인스턴스 시작 > *2 서버 고르는 창이 뜸 > *3 서버 선택 > *4 프리 티어 인스턴스 자동 선택됨 > *5 인스턴스 구성(건들 거 없음) > 다음 > *6 스토리지 추가 20GB > 범용ssd or 마그네틱 적용 > 다음 > 태그 작성 > 다음 > *7 보안그룹설정 > 다음 > 새 키페어 생성 > *8 키페어 다운로드 > 인스턴스 시작 > 시작 상태 > 인스턴스 상태 나옴 > 서버 하나 만든 것.

*1 미국 서버는 느림. 서울은 빠름.
*2 아마존 리눅스 ~ > 아마존이 기본으로 제공하는 서버.
*3 Amazon Linux 2 AMI (HVM), SSD Volume Type(첫번째 거) 선택
	두번째 생성시에는 Amazon Linux AMI 2018.03.0 (HVM), SSD Volume Type(두번째 거) 선택함
	★★★ 이 아마존 서버들이 CentOS 기반임.
*3 여기서 서버 선택만 하면 설치해주는 거. 여것이 클라우드 서비스.
*4 프리 티어는 12개월 무료라고 설명 있음.
*5 퍼블릭 IP 자동 할당 - 서브넷 사용 설정 : 언제 어디서든 접속을 할 수 있다.
*6 스토리지 추가 페이지 : 하드디스크 추가 할 거냐
*7 ★★★ 보안그룹설정 페이지 : 방화벽 설정 창.
	서버의 포트(22번 포트)를 열어줘서 외부에서 접속할 수 있게 해준다.
	포트를 바꾸면 원격 접속이 안 됨.
	포트가 22로 적혀있지 않으면 서버가 돌아가도 아무도 접속할 수 없다.
	0.0.0.0/0 : 모든 아이피를 의미. 모든 아이피에서 접속할 수 있음을 의미. 어떤 아이피로도 접속할 수 있게 하겠다.
	보안그룹 이름 바꿔도 됨.
*8 키페어 다운로드시 받은 .pem 파일이 없으면 서버 접속이 안 된다.
	윈도우즈의 경우 이 파일로 푸티를 통해 서버에 접속할 때 필요함.



(7) 서버 중지하기/지우기

-- 서버 지웠다 다시 만들어도 됨.

EC2 > 인스턴스 > 서버 선택 > 작업 > 인스턴스 상태 > 중지(셧다운), 종료(아예 없애는 거)



(8) EC2 > 인스턴스 > 인스턴스 > 서버 선택하면 하단에서 볼 수 있는 용어들 설명

-- 프라이빗 아이피 : 내부 아이피
	★IPv4 퍼블릭 IP★ : 3.34.46.131
		이것만 알고 있으면 이 서버에 언제든 접속할 수 있음.
-- 보안 그룹 > 인바운드 규칙 보기" 클릭하면 뜨는 창 설명
	인바운드 22번, 우측에 녹색 체크표시 = 포트가 열려있다는 뜻. => (윈도우) 푸티로 접속할 수 있음.



(9) .pem 파일

.pem
-- EC2에 접근할 수 있는 파일.
-- .pem 파일은 (푸티로) SSH 접속할 때 사용.
		서버 생성시 SSH로 설정했기 때문(인 거 같음)
-- .pem은 보안과 관련된 파일. 보안은 중요함.
-- 아마존에 EC2(CentOS)서버를 설치하고(서버를 만들고)나면 AWS가 다운받으라고 주는 파일.
-- 어느 운영체제든 .pem 파일을 통해서 EC2서버에 접속한다.
-- 윈도우의 경우 이 서버에 접속하려고 할 때 푸티(+푸티젠)가 필요함.
	-- 윈도우는 .pem 파일을 그대로 응용하지 못하기 때문에 puttygen(keygen)을 거쳐 파일 변환을 해야한다.
	-- puttygen에서 .pem 파일을 .ppk로 변환하고, 푸티에서 서버에 접속하기 전에 이 파일을 추가해야 한다.



(10) ★★★.pem을 .ppk로 변환하기 (윈도우만 이거 함)

윈도우에서 puttygen 검색/클릭 > 제너레이트 클릭 > 진행중 > 파일 > 키젠 > "로드 프라이빗 키" > 파일 유형 올파일로 바꾸고 .pem 파일 선택 > "세이브 프라이빗 키" 선택 > 경고창 뜨면 예스 > .ppk로 저장 > 끝



(11) ★★★푸티랑 연결하기 (윈도우만 이거 함)

푸티 열기 > 서버 퍼블릭 아이피(IPv4) 복붙 > 아이피 앞에 ec2-user@ 입력 > 왼쪽 메뉴에서 커넥션 밑에 SSH 클릭 > auth 선택 > 하단의 프라이빗 키 ~ 항목에 프라이빗키 .ppk 파일 만든 거 불러오기 > 세션으로 돌아와서 !!!!!!!세션 이름 적어서 세이브!!!!!!! > open(시작) > 경고창 뜨면 예 누르기 > 시작 창에 EC2 메시지가 창 잘 뜨면 성공(아마존 리눅스 서버로 접속 성공한 것)



(12) in EC2 server(예제)

-- !! 여기 안에서 시험문제 나옴. (리눅스 명령어)

(12-1) doc 디렉토리 만들기
	$ mkdir doc
	-- 홈 디렉토리에 생성함.

(12-2) doc 디렉토리로 이동
	$ cd doc
	-- 홈 디렉토리에서 doc 진입

(12-3) doc 디렉토리에서 파일명이 test인 파일 하나 만들기
	파일 내용은 echo "Hello"
	$ touch test
	-- 이 경우 $ vi test로 진입해서 내용을 수정해야 함
	-- 처음부터 $ vi test를 치고 내용 적고 저장하면 생성 + 내용 입력 빠르게 가능.
	$ vi test  -- ★수업에서는 이걸 씀.
	i (인서트 모드 진입)
	echo "Hello" 내용 입력
	Esc :wp (저장하고 에디터 종료)

(12-4) 위의 test 파일의 권한을 변경하기  -- ★시험문제 나옴.
	rwxr-xr-x로 변경
	$ chmod 755 test

(12-5) test 파일을 실행하기
	$ /home/ec2-user/doc/test
	-- $ ~/doc/test 도 가능
	-- $ ./test 도 가능
		.  =>  지금 디렉토리

(12-6) ★★★test 파일을 /home/ec2-user( 디렉토리로 복사
	$ cp test ~/test
	-- 방법2) $ cp test /home/ec2-user
	-- 방법3) $ cp test ../
	-- ★★★문제 파악 제대로 못하고 같은 디렉토리에 복사했었음. 핵주의.
	-- 현재 위치가 홈 디렉토리면 $ cp /doc/test ./ 이렇게 써서 복사 가능

(12-7) test 파일지우기
	rm test

(12-8) doc 디렉토리 지우기
	rm -r doc
		doc 안에 있는 파일이랑 폴더랑 다 지워라
		-r 리컬시브
	rm -rf doc
		현업에서는 이걸 쓴다. 사실상 -r과 같다.
	rm -f doc
		doc 안의 파일"만" 지워라

(12-9) 현재 위치 검색
	pwd

(12-10) CentOS(리눅스)에 yum으로 vsftpd 설치하기
	★ 루트(슈퍼유저)로 접속해야 함.  -- ★시험문제에 나옴.
	$ sudo yum install
		sudo : 슈퍼유저로 행동하라
		ec2-user가 슈퍼유저로 행동할 수 있게끔 AWS에서 미리 설정해두었다.

(12-11) 슈퍼유저 패스워드 만들기
	$ sudo passwd root
	까먹으면 서버 삭제하고 다시 만들어서..



RDS : AWS가 제공해주는 데이터베이스

(13) AWS에서 디비 생성하기
	RDS > 좌측 대시보드 > 데이터베이스 생성
	 > 엔진 유형 Amazon Aurora > DB클러스터 식별자 이름 입력
	 > 마스터 사용자 이름(데이터베이스에서 루트는 마스터다. DBMS의 루트 계정을 만드는 것임.)(마스터 사용자 이름은 root) 암호 적기
	 > 디비 인스턴스 크기(버스터블 클래스 - db.t2.small)
	 > 복제본 생성하지 않음 > 가용성 및 내구성 "복제본 생성하지 않음" 클릭 > 추가 연결 구성 클릭 > 퍼블릭 엑세스 가능 "예" 클릭
	 > VPC 보안 그룹 기존 항목 선택 클릭 > 추가 구성 클릭
	 > 삭제 방지 활성화 언체크 > 데이터베이스 생성

(14) 인바운드 규칙 추가하기
	Amazon RDS > 데이터베이스 > DB이름 클릭(쓰기)
	 > 보안그룹 눌러보기 > 보안그룹 아이디 눌러보기
	 > 인바운드 규칙 편집 > 규칙 추가
	 > MYSQL/Aurora 선택, 소스는 0.0.0.0/0 선택(위치 무관)
	 > 규칙 저장

(15) 서비스 > RDS(DBMS) 클릭
	> DB인스턴스에 숫자가 늘어나있음 (생성된 것임) 인스턴스 클릭하면 디비 접속 화면 나옴

(16) 디비는 워크벤치로 접속한다. 고로 워크벤치에 만든 디비를 등록한다.
	쓰기 누르고 엔드포인트 복사 > 워크벤치에 +눌러서 뉴 커넥션 생성 > 호스트 네임에 엔드포인트 붙여넣기
	 > 유저네임은 아까 만든 admin 계정 이름 씀
	 > 패스워드 생성했던 거 입력 > 테스트 커넥션 성공 뜨면 OK를 눌러 커넥션 등록 완료하기

(17) 데이터베이스 지우기
	RDS - 데이터베이스 - 리전 클릭 - 우측 상단 작업 클릭 - 삭제 클릭
	수업에서는 퍼블릭 IP 사용 설정을 안해서 다시 만들려고 전에 만든 거 삭제함.



!! ★★★깃헙 23. 스키마 설계 실습
테이블 6개
아직 직접 만드는 건 어려우니까
이렇게 설계했구나라는 연결고리를 잘 봐둬라.
요소를 이렇게 뽑아내는(분리하는)구나.
-- 분리해도 되는(해야되는) 컬럼들과 한 테이블에 있어야 하는 컬럼들을 나누는 게 중요한 거 같다.
이걸 꼭 한 번 쭉 둘러보고 공부하고 와달라.

==============================

시험에 나오는 것들

==============================

DB관련 : 데이터베이스(DBMS) / SQL
	SQL : CRUD, group by(+연관된 함수들), order by, limit, 테이블 설계(3개짜리) 단답형, join(inner join), left join, case문 단답형, char_length(), concat()

리모트 접속(원격 접속) 관련
	포트와 아이피는 뭐냐. MySQL DB포트-3306, SSH 포트 22
	포트와 아이피가 있어야 원격접속을 할 수 있다.

리눅스 명령어 : CentOS 활용
	(12) in EC2 server(예제) 나옴 (OS 활용 문제) - 깃헙에 올리셨음(나는 위에 메모해뒀음)
	yum!!!

변별력 문제 두어개

12~15문제 예정

핸드폰 검색 OK

시험은 열시 반

누구나 다 풀게 만드셨대여.

==============================

기타 메모

==============================

★aws 설치 방법 등등 잘 익히기.
	aws 설치하면 집에서도 접속할 수 있음.

취업시 "aws 자격증" 봄. 종류 많음.
	aws 설치해봤는가 등등 물어봄.
"sql 개발자" 자격증도 봄.
두가지 말고 다른 자격증들은 안 봄

윈도우는 .ppk

★★★홈 디렉토리 정의에 주의하기

★rwx
  파일 소유자 : 파일을 생성한 사람
  rwx(권한 설정)은 현업에서도 중요함.

ec2-user와 root 계정의 차이
ec2-user 계정은 관리자 계정(일반 계정 아님)
	관리자 : 일반 유저한테 sudo 권한을 준 것.
	루트 권한이 아니면 조심해서 쓰라고 sudo를 붙이게 만든다.
	AWS에서 인스턴스 만들 때 서버(AMI 선택창)에서 만들어주는 계정.
루트는 슈퍼유저. 걍 슈퍼유저.

365일 무료 기한 내년 날짜 저장해두기

깃헙 23.
기획서는 보통 화면 기획으로 온다. (화면 기획서)
	이거 받자마자 데이터베이스 설계부터 하는 게 첫번째 작업이다.
인터페이스 정하기 : API

사진은 데이터베이스에 저장되지 않는다. 따로 파일 스토리지에 저장한다. AWS S3
	데이터베이스에서는 사진의 URL만 저장한다.

200529 금요일 수업 키워드

Cn = 컬럼 이름
Tn = 테이블 이름
Dn = 데이터베이스 이름
Jo = 조건문
Ha() = 함수
St = 문자열
Int = 정수
Dt = 데이터 타입
Ind = 인덱스 넘버
inna_ipk = int not null auto_increment primary key
tdn()ouc_t = 
		timestamp default now() on update current_timestamp

---

------------  SQL  ------------

ifnull()
	(1) (D1) (D2)

count()
	(1) (D1) (D2) 

round()
	(1) (D1) (D2) 

min()
	(1) (D1) (D2) 

max()
	(1) (D1) (D2) 

avg()
	(1) (D1) (D2) 

if()
	(D1) 

case-when-then-else-end as
	(1) (D2) 

group by
	(1) (D1) (D2) 

order by
	(1) (2)

concat()
	(2)

join-on
	(2)

left join-on
	(1) (D1) (D2) 

------------------------------

------------  AWS  ------------

AWS 관련 과정 설명
	(깃헙 22번)

AWS 루트 계정으로 가입하기(첫 가입)
	(3)
	1. 구글 aws 검색
	2. cloud services ~
	3. aws 계정 새로 만들기  >>  root 선택 후 만들기
		"동의하고 계정 만들기" 체크
	4. 계정 유형 "개인"
	5. 주소 영문 작성
	6. 비번 입력 등등 진행
	7. 가입 끝

일반 사용자 추가하기
	(4)
	1. aws 홈페이지  >>  좌측 상단 "서비스" 에서 IAM 검색
	2. 좌측 "사용자"  >>  "사용자 추가" 버튼 클릭
	3. 사용자 이름 작성  >>  AWS Management ~ 체크  >>  다음
	4. 그룹에 사용자 추가  >>  그룹 생성
	5. admin  >>  AdministratorAccess 체크
	6. 그룹 생성  >>  다음  >>  태그 입력(안 해도 됨)  >>  다음
	7. 검토  >>  사용자 만들기
	MFA
		이중인증 기능. 구글 인증 앱 설치 필요
	IAM
		서비스  >>  IAM에 들어가면 사용자(유저) 확인 가능
	패스워드 콘솔 로그 링크
		접속 링크
	일반 사용자로 로그인하기
		(5)

★EC2(CentOS)"서버 만들기"
	(6)
	1. aws 홈페이지  >>  로그인
	2. 우측 상단 서버를 현지 위치(서울)로 변경
	3. 서비스  >>  EC2  >>  EC2 대시보드  >>  실행 중인 인스턴스
	4. 인스턴스 시작  >>  서버 선택(프리 티어)
	5. 프리 티어 인스턴스 자동 선택됨  >>  다음
	6. 인스턴스 구성 스킵  >>  다음
	7. 스토리지 추가(하드디스크 용량 입력)  >>  다음
	8. 태그 입력(안 해도 됨)  >>  ★보안그룹 설정★  >>  다음
	9. 새 키페어 생성  >>  키페어 다운로드  >>  인스턴스 시작
	서버
		Amazon Linux
			(6-*3)
	스토리지
		(6-*6)
	★보안 그룹 설정
		(6-7*)
		방화벽 설정
	Port
		SSH Port 22
	키페어
		.pem
			(6-*8) (9)
		분실하면 다시 받을 수 없음. 파일 보관은 확실하게.
	0.0.0.0/0
		모든 아이피를 의미.

서버 중지하기/지우기
	(7)

서버 용어 설명 in AWS
	(8)
	IP
		Public IP
			★IPv4
		Private IP
	인바운드 규칙

★★★ .pem
	EC2에 접근할 수 있는 파일.
		어느 운영체제든 이 파일을 통해 EC2 서버에 접속한다.
		윈도우의 경우 푸티젠과 푸티 프로그램이 추가로 필요.
			★ 푸티젠에서 .pem을 .ppk으로 바꾸고 이걸 푸티에서 사용
	SSH로 접속할 때 사용.
	보안과 관련된 파일.

EC2(CentOS) 서버 접속하기 in PuTTY
	puttygen
		.pem을 .ppk로 변환하기
			(10)
			1. puttygen 실행
			2. Generate 클릭  >>  generate 진행됨
			3. 파일  >>  키젠  >>  "로드 프라이빗 키"
			4. .pem 파일이 있는 경로에 들어가서 all file로 검색  >>  .pem 파일 선택
			5. "세이브 프라이빗 키" 선택  >>  경고창 뜨면 "예스" 클릭
			6. .ppk로 저장  >>  끝
	EC2 서버 접속 설정하기 & 접속하기
		(11)
		1. putty 열기
		2. EC2 서버의 퍼블릭IP(IPv4) 복붙
		3. 복붙한 IP 앞에 ec2-user@ 입력
			ec2-user : AWS가 제공하는 관리자 계정 이름
		4. 왼쪽 메뉴 하단의 커넥션 밑에 있는 SSH  >>  auth 선택
		5. 맨 아래 파일 선택 창에서 .ppk 불러오기
		6. 다시 세션(왼쪽 맨 위 항목)으로 돌아와서 세션 이름 적고 save 클릭(여태 설정한 거 저장하기)
		7. open 누르기(접속 시도)
		8. 경고창 뜨면 "예" 누르기
		9. 시작 창에 EC2 글자가 뜨면 접속 성공.

------------------------------

----------  RDS in AWS  ---------

Amazon RDS
	Amazon Relational Database Service

RDS 생성하기
	(13) 
	1. aws 홈페이지  >>  서비스  >>  RDS
	2. 좌측 대시보드  >>  "데이터베이스 생성"
	3. 표준 생성  >>  엔진 유형 "MySQL"  >>  프리 티어 선택
	4. DB 식별자 이름 & 마스터 사용자 이름 입력 및 암호 생성
		DBMS에서 master user는 terminal의 root user와 같다.
	5. DB 인스턴스 크기  >>  버스터블 클래스 선택
	6. 가용성 및 내구성  >>  복제본 생성하지 않음" 클릭
	7. 추가 연결 구성 클릭  >>  퍼블릭 엑세스 가능 "예" 클릭
	8. VPC 보안 그룹  >>  "기존 항목 선택"
	9. 추가 구성 클릭  >>  삭제 방지 활성화 언체크
	10. "데이터베이스 생성" 클릭  >>  끝

RDS 상태 확인하기
	(15)
	1. aws 홈페이지  >>  서비스  >>  RDS
	2. RDS 생성시 "DB 인스턴스"에 숫자가 늘어나있음
	3. "DB 인스턴스"를 클릭하면 생성한 RDS와 RDS 상태를 확인 가능

인바운드 규칙 추가하기
	(14)
	1. aws 홈페이지  >>  서비스  >>  RDS
	2. 데이터베이스  >>  DB이름 클릭
	3. VPC 보안 그룹 항목 아래 이름 클릭  >>  인바운드 규칙 클릭
	4. "인바운드 규칙 편집"  >>  규칙 추가
	5. MYSQL/Aurora 선택, 소스는 0.0.0.0/0 선택  >>  규칙 저장
		모든 IP(0.0.0.0/0)에서 접속할 수 있도록 규칙을 추가함.

워크벤치에서 RDS 커넥션 추가하기
	(16)
	1. aws 홈페이지  >>  서비스  >>  RDS
	2. 데이터베이스  >>  DB이름 클릭
	3. 하단의 연결 & 보안에서 "엔드포인트" 주소 복사
	4. 워크벤치에서 새 커넥션 등록 버튼(+) 클릭
	5. "호스트 네임"에 복사해둔 "엔드포인트" 주소 붙여넣기
	6. user name에 RDS 만들 때 입력한 마스터 사용자 이름 입력
	7. 바로 밑에 버튼 눌러서 마스터 사용자 비밀번호 입력
	8. 테스트 커넥션 수행
		여기서 안 되는 경우는
			1) 서버 위치를 되는 지역으로 설정해놓지 않았거나(6)
			2) RDS 생성시 "퍼블릭 엑세스 가능"에서 "예"에 체크하지 않았거나
		둘 중 하나이다.
	9. 테스트 커넥션이 성공하면 OK를 눌러 커넥션 등록 완료하기

RDS 삭제하기
	(17)
	1. aws 홈페이지  >>  서비스  >>  RDS
	2. 데이터베이스  >>  DB이름 왼쪽 선택 항목 체크
	3. 상단의 "작업"  >>  삭제 클릭
		(13)에서 "삭제 방지 활성화"를 체크해놓은 경우 삭제되지 않음.
		RDS 생성 후 "삭제 방지 활성화" 언체크하기
			1. aws 홈페이지  >>  서비스  >>  RDS
			2. 데이터베이스  >>  DB이름 왼쪽 선택 항목 체크
			3. 상단의 "수정" 버튼 클릭
			4. 스크롤 맨 아래로 내려서 "삭제 방지 활성화"에 언체크 후 "계속" 클릭
			5. "즉시 적용" 선택 후 "DB 인스턴스 수정" 클릭

------------------------------

--------  터미널 명령어 (12)  -------

★mkdir "make directory"
	(12-1)

pwd "print working directory"
	(12-9)

exit

★★★ cd "change directory"
	(12-2)
	.
	..
	~
	/

파일/프로그램 실행 방법
	(12-5)
	절대경로를 적고 그 끝에 파일(프로그램)명까지 입력하면 실행됨.
		!! 절대경로를 적는 여러가지 방법을 잘 정리해서 익혀두자.

touch "파일 생성"
	(12-3)

echo "문자열을 터미널에 출력"
	(12-3)

vi "편집기로 파일 오픈"
	(12-3)

i a o "인서트 모드로 진입"
	(12-3)

Esc :wq "저장하고 종료"
	(12-3)

chmod "파일 권한 설정하기"
	(12-4)

cp "복사하기"
	(12-6) 

rm "지우기"
	(12-7) (12-8)
	rm -r
	rm -rf
	rm -f

★ sudo "슈퍼 유저로 행동해라"
	(12-10)
	관리자 권한이 있는 계정에서 root의 권한을 임시로 쓸 수 있는 명령어. sudo 뒤에 root 권한에서만 쓸 수 있는 명령어를 입력하면 실행됨.

★ yum "업데이터/설치/제거 도구"
	(12-10)
	Yellow dog Updater, Modified의 약자로 RPM 기반의 시스템을 위한 자동 업데이터 겸 패키지 설치/제거 도구(검색 복붙)
	yum install
		패키지 설치 명령어. install 뒤에 패키지 명을 적으면 해당 패키지만 설치한다.

------------------------------

join on 한 다음에 group by!!!

★ rwx
	파일 소유자 : 파일을 생성한 사람

RDS
	AWS가 제공해주는 데이터베이스(DBMS?)

깃헙 23번 스키마 설계 실습하기.
	'화면 기획서'를 보고 '데이터베이스'를 설계해보는 실습임.

ec2-user와 root 계정의 차이
ec2-user 계정은 관리자 계정(일반 계정 아님)
	관리자 : 일반 유저한테 sudo 권한을 준 것.
	루트 권한이 아니면 조심해서 쓰라고 sudo를 붙이게 만든다.
	AWS에서 인스턴스 만들 때 서버(AMI 선택창)에서 만들어주는 관리자 계정.
루트는 슈퍼유저. 걍 슈퍼유저.

취업시 보는 자격증 두 개
	"AWS 자격증"
	"SQL 개발자""

~
	홈 디렉토리!!!!!!!!!!!!!!1

AWS S3
	사진 파일은 DBMS에 저장하지 않고 따로 파일 스토리지를 만들어 저장한다.
	AWS에서 제공해주는 파일 스토리지가 AWS S3.
		DBMS에는 사진의 URL만 저장한다.

200604 목요일 수업 키워드



UI  =  사용자 인터페이스(User Interface)



==============================
MySQL
==============================



=====  주요 주의사항

별칭(as ~)을 잘 활용하기

컬럼 앞에 테이블 이름 표시하는 습관

원하는 데이터를 조회하기 위해서는 무슨 값(데이터)을 얻어야 하는지
그 값을 얻기 위해서는 무슨 테이블(들)이 필요한지
조건 범위(where)는 어떻게 잡아야 하는지
뭘 join하고 뭘 group by해야하는지
어떻게 order by해야하는지 등등을 잘 생각해야한다.



=====  키워드 정리

order-by
	(1) (2) (4-2) 

limit
	(1) (2) (4-2)

dayname() "영문 요일명 가져오기"
	(2) 

date()
	(2) 

group-by
	(2) (4-2) 

left-join on
	(3) 

is-null
	(3) 

count(*)
	(4-2) 

join on
	(4-2) 



==============================
Android Studio
==============================



=====  안드로이드 앱의 구성

app  &  Gradle Scripts
	안드로이드 프로젝트는 app과 Gradle Scripts로 이루어져있다.

app
	manifests
		프로젝트 설정을 관리하는 패키지
	java
		xml의 구현(액션)을 담당하는 패키지
	res
		레이아웃과 이미지, 문자열 리소스등 UI를 설정하고 관리하는 패키지

Gradle Scripts
	어플리케이션을 빌드하기위해 필요한 설정 옵션, 라이브러리 정보들이 들어있는 패키지



=====  기본 설명

.xml
	앱에서 "화면", 상태, 구성요소를 담당
	우리 눈에 보이는 UI를 구현하는 파일

.java
	xml을 활용한 "액션"을 담당
	xml을 활용해 '로직을 짠다'고 표현

~Activity.java  X  activity_~.xml
	~Activity.java 파일과 activity_~.xml 파일은 언제나 한쌍이다.
	~Activity.java 파일에서 activity_~.xml 파일을 연결해준다.

폴더  =  패키지



=====  Android 탭의 패키지들 상세 설명

Android > app > manifests
	어플리케이션을 구동하는데 필요한 설정값을 관리해주는 곳

Android > app > java
	java 클래스를 관리하는 폴더
		앱이 작동하는 방식에 대해 정의하는 java 파일들이 모두 이곳에 들어있다
	이벤트/로직/코드를 짠다  =  액션을 만든다  =  java에서 편집한다

Android > app > res
	Resource(자원) 폴더
		UI, 레이아웃와 관련된 파일(.xml)들과 디자인 리소스, 문자열 리소스를 담고있음
	res > drawable 패키지
		이미지 파일을 저장해놓는 패키지
	res > layout 패키지
		디자인의 뼈대를 담당하는 layout xml파일들이 모여있음.
		한 화면에 하나씩 레이아웃 xml 파일이 쓰인다.
	res > mipmap 패키지
		앱 아이콘 이미지를 저장해놓는 패키지
		기본 아이콘 파일명은 ic_launcher.png
			왠만하면 파일 이름을 바꿔넣지 않는 게 편하다.
			이 파일명을 바꾸게 되면 AndfoidManifest.xml에서도 해당 위치의 파일명을 바꿔줘야 한다.
				android:icon="@mipmap/ic_launcher"
	res > values 패키지
		문자열, 색상값, 수치값, 스타일 저장 패키지
		colors.xml
			컬러값 저장 파일
		strings.xml
			문자열값 저장 파일
			고정된 멘트 등의 문자열들은 여기에 따로 저장해놓는다.
			자바는 여기에 저장된 문자열들을 코드로 가져다 쓴다.
				별도의 문자열 xml이 있는 이유
					1. 자바 코딩에서의 깔끔한 활용, 문자열의 쉬운 수정.
					2. 다국어 언어파일을 손쉽게 만들고 관리할 수 있음.
		styles.xml
			스타일값 저장 파일



=====  주요(기본 생성) 파일들 상세 설명

AndfoidManifest.xml
	안드로이드에서 전체 앱에 대한 요약 정보를 가지고 있음.
		아이콘, 앱 이름, 화면 테마, 첫 실행 순서 등을 설정할 수 있음
			첫 실행 순서에 대한 내용은 <activity /> 참고
		안드로이드 앱의 컨트롤타워.
	파일 경로
		Android > app > manifests > AndfoidManifest.xml
	<application />
		애플리케이션에 관한 정보를 설정
		android:label="@string/app_name"
			" " 안에서 앱 이름을 바꿀 수 있음.
	<activity />
		앱 화면(.xml)의 액션을 담당하는 첫 java 파일을 설정
		<activity android:name=".MainActivity">
			앱을 실행하면 MainActivity.java 파일을 우선적으로 실행한다.

MainActivity.java
	파일 경로
		Android > app > Java > 첫번째패키지 > MainActivity.java
	onCreate() {}
		CPU는 여기로 제일 먼저 들어옴.
		여기 안에 레이아웃 실행 코드를 추가하면 됨.
	setContentView(R.layout.activity_main);
		R - layout - activity_main.xml 파일을 View로 연결한다.

activity_main.xml
	MainActivity.java와 연결된 화면 구성 파일.
	파일 경로
		Android > app > res > layout > activity_main.xml



=====  앱 아이콘 이미지 바꾸기

Android > app > res 패키지 우클릭 > New > Image Asset
	Path 우측 폴더 버튼 > 아이콘 파일 선택 후 OK
	백그라운드 컬러 변경, 아이콘 이미지 크기 조정 등의 설정이 가능
	> Next > 아무 것도 건드리지 말고 Finish



=====  drawable에 각 해상도별로 이미지 추가하기

해상도별로 이미지를 추가해야하는 이유
	안드로이드는 이미지 하나로 모든 기종의 화면에 맞춰서 보여줄 수 없기 때문이다.
	안드 화면에 쓸 이미지 하나를 추가하려면 안드로이드가 지원하는 해상도별로 이미지를 만들어야 한다.

Final Android Resizer
	이미지 파일 하나를 안드가 필요로하는 해상도별로 각각 만들어주고, 만든 이미지들을 해당 프로젝트의 폴더에도 알아서 저장해주는 프로그램.

Java 설치하기
	Final Android Resizer를 설치하기 위해서는 컴퓨터에 Java 프로그램이 깔려있어야 함.
	1)  Java SE Development Kit 검색
	2)  Windows x64 다운로드
	3)  Oracle 로그인
	4)  설치파일 다운로드  >  설치

Final Android Resizer 다운로드하기
	1)  Final Android Resizer 검색
	2)  처음 나오는 링크(깃헙) 클릭
	3)  첫 화면에서 스크롤 내려서 If you just want to download the executable jar, click <<here>> 클릭
	4) 다운로드 후 실행

Final Android Resizer을 사용해 res폴더에 이미지 추가하기
	1)  Output directory 설정 변경
		1)  만들고 싶은 항목에 따라 mipmap이나 drawable 선택
	2)  Resources directory 변경
		1)  진행하는 프로젝트의 res 패키지 경로를 복붙 후 엔터
			1-1)  res 패키지 경로 알아내기
				안스의 res 패키지에서 우클릭 > Show in Explorer
			1-2)  이후에 추가하는 이미지들은 이 폴더 안에 저장된다.
	3)  이미지 추가하기
		1)  추가하려는 이미지를 이 프로그램에 끌어다놓으면 바로 파일 생성과 저장 작업이 실행된다.
	4)  만들어진 폴더들 옮기기
		1)  res폴더에 만들어진 res_drawable 폴더에 진입
		2)  전부 복사해서 res 폴더에 붙여넣기
		3)  안스로 돌아오면 res > drawable 폴더에 이미지가 추가되어있음.



=====  프로젝트에서 액션 바 비활성화하기

App Bar
	여러 종류의 위젯으로 구성된 액티비티의 기본 도구모음(Toolbar)

ActionBar
	앱바(App Bar)를 만들 때 사용하는 위젯 중 하나

App Bar  =  ActionBar
	통상적으로 안드로이드에서 앱 바와 액션바는 같은 의미로 사용됨

액션바 비활성화하기
	Android > app > res > values > styles.xml
		<style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
	에서 DarkActionBar를 NoActionBar로 고치면 액션바가 비활성화됨.



====[[  Layout  ]]====



===  Layout의 계층 구조

View  :  뷰
	UI 화면에 있는 각 구성 요소들을 말한다.
		ex) Button, TextBox, Image, ...
	모든 뷰는 android.view.View 클래스의 서브 클래스다.
	UI 화면은 "뷰 계층 구조"의 형태로 생성된 뷰들로 구성된다.

Layout
	요소들을 감싸는 것, view의 배치 방식을 정의하는 것이다.
		레이아웃 종류마다 소속된 뷰를 배치하는 방법이 달라지기도 한다.
	Layout 클래스는 View를 배치하는 역할을 가진 ViewGroup이라 할 수 있다.
		레이아웃은 ViewGroup을 상속받으므로 하나의 View처럼 다룰 수 있다.
	필요에 따라 다양한 종류의 레이아웃을 중첩해서 사용할 수 있다.

View Tree  :  뷰 계층 구조
	Tree  :  트리
		계층 구조
	root view
		계층 구조의 맨 위에 위치한다.
	Parent View  :  부모 뷰
		하위 뷰를 담고있는, 상대적으로 상위에 위치한 뷰.
	Child View  :  자식 뷰
		부모 뷰 밑에 소속되어있는 뷰.
		자식 뷰는 자신의 부모 뷰 위에 포개져서 화면에 나타나되, 표현 범위는 부모 뷰의 화면 영역 안으로 제한된다.



===  Layout, View의 필수 요소

요약  :  레이아웃과 뷰를 가리지 않고 꼭 필요한 것은 가로세로 길이

layout_width
	레이아웃 or 뷰의 가로 길이
	[xml]  android:layout_width=" "

layout_height
	레이아웃 or 뷰의 세로 길이
	[xml]  android:layout_height=" "

★dp
	layout, view의 길이를 표시할 때 쓰는 기본 단위
	ex)  [xml]  android:layout_height="30dp"

match_parent
	부모 뷰의 영역에 꽉 차는 길이
	ex)  [xml]  android:layout_width="match_parent"
		이 뷰의 가로 길이는 부모 뷰의 가로 영역의 시작부터 끝까지이다.

wrap_content
	뷰 자신의 디폴트 영역에 딱 맞는 길이
	ex)  [xml]  android:layout_height="wrap_content"
		이 뷰의 세로 길이는 자기 자신의 세로 길이만큼이다.



===  RelativeLayout, LinearLayout (h/v)

=  RelativeLayout

	레이아웃의 하위 항목들이 각 항목들 혹은 parent의 상대적인 위치에 있도록 하는 뷰 그룹
	
	[[  Parent 전용 정렬  ]] [Parent] 
	gravity
		자신의 레이아웃 아래에 있는 모든 자식 뷰의 중력 방향을 결정
		[xml]  android:gravity="중력방향"
	ignoreGravity
		gravity 설정 상태에서 특정 자식 뷰에 대해 gravity 설정 속성을 무시함
		[xml]  android:ignoreGravity="@id/자식뷰id"

	[[  Parent를 기준으로 Child를 정렬  ]]

	layout_alignParentLeft
		부모 영역(뷰그룹)에서 자신을 왼쪽에 배치
		[xml]  android:layout_alignParentLeft="true"
	layout_alignParentRight
		부모 영역(뷰그룹)에서 자신을 오른쪽에 배치
		[xml]  android:layout_alignParentRight="true"
	layout_alignParentTop
		부모 영역(뷰그룹)에서 자신을 상단에 배치
		[xml]  android:layout_alignParentTop="true"
	layout_alignParentBottom
		부모 영역(뷰그룹)에서 자신을 하단에 배치
		[xml]  android:layout_alignParentBottom="true"
	layout_centerHorizontal
		부모 영역(뷰그룹)에서 자신을 수평 중앙에 배치
		[xml]  android:layout_centerHorizontal="true"
	layout_centerVertical
		부모 영역(뷰그룹)에서 자신을 수직 중앙에 배치
		[xml]  android:layout_centerVertical="true"
	layout_centerInParent
		부모 영역(뷰그룹)에서 자신을 정 중앙에 배치
		[xml]  android:layout_centerInParent="true"

	[[  Child끼리 정렬  ]]
	layout_above
		기준이 되는 뷰의 상단에 배치
		[xml]  android:layout_above="@id/기준이되는뷰id"
	layout_below
		기준이 되는 뷰의 하단에 배치
		[xml]  android:layout_below="@id/기준이되는뷰id"
	layout_toLeftOf
		기준이 되는 뷰의 왼쪽에 배치
		[xml]  android:layout_toLeftOf="@id/기준이되는뷰id"
	layout_toRightOf
		기준이 되는 뷰의 오른쪽에 배치
		[xml]  android:layout_toRigntOf="@id/기준이되는뷰id"
	layout_alignTop
		기준이 되는 뷰의 상단 선을 기준으로 배치
		[xml]  android:layout_alignTop="@id/기준이되는뷰id"
	layout_alignBottom
		기준이 되는 뷰의 하단 선을 기준으로 배치
		[xml]  android:layout_alignBottom="@id/기준이되는뷰id"
	layout_allignLeft
		기준이 되는 뷰의 왼쪽 선을 기준으로 배치
		[xml]  android:layout_alignLeft="@id/기준이되는뷰id"
	layout_alignRight
		기준이 되는 뷰의 오른쪽 선을 기준으로 배치
		[xml]  android:layout_alignRight="@id/기준이되는뷰id"
	layout_alignBaseline
		기준이 되는 뷰에 텍스트가 있는 경우 배치되는 뷰의 텍스트와 기준선을 맞춰서 배치
		[xml]  android:layout_alignBaseline="@id/기준이되는뷰id"



=  LinearLayout ( horizontal / vertical )

	세로 또는 가로의 단일 방향으로 모든 하위 항목을 정렬하는 뷰 그룹
	
	한 방향으로 나열하고 싶은 View들을 하나의 LinearLayout 태그 안에 차례로 배치하면 된다.
	
	리니어 레이아웃은 "반드시 방향을 지정해야한다."
	
	[[  orientation  ]]
	뷰를 쌓는 방향을 정하는 속성(필수 설정)
	vertical
		구성요소들을 세로 방향으로 배치
		[xml] android:orientation="vertical"
	horizontal
		구성요소들을 가로 방향으로 배치
		[xml] android:orientation="horizontal"

	[[  Parent 전용  ]]
	gravity
		Child 뷰들을 정렬하는 데 사용하는 속성
		[xml] android:gravity="중력방향"
	
	[[  Child 전용  ]]
	layout_gravity
		부모 컨테이너의 (남은) 영역 안에서 자신을 정렬
		[xml] android:layout_gravity="중력방향"
	weight
		구성요소들을 비례에 맞춰 배치하고 싶을 때 사용하는 속성
		선행) 비율을 맞추고자 하는 방향에 맞춰 뷰들의 길이(layout_width or layout_height)를 0dp로 만든다.
			weight는 부모의 남는 공간을 기준으로 분할하기 때문에, 부모의 남는 공간에 대해 정확하게 분할하고 싶은 목적이라면 분할하려는 뷰와 방향에 공간이 주어지면 안 된다.
		[xml] android:layout_weight="비율수치"
			모든 뷰를 같은 비율로 맞추고 싶을 땐 이 수치를 모두 1로 맞춘다.



===  레이아웃 편집 화면의 구성

레이아웃 편집하기
	Android > app > res > layout > ~.xml에서는 3가지의 모드로 한 화면의 레이아웃을 편집할 수 있다.
	Code
		.xml 코드를 작성/편집할 수 있는 에디터만 뜨는 편집 모드
	Split
		Code화면 + Design화면 반반
	Design
		레이아웃 및 뷰의 추가, 편집, 삭제 등을 직관적으로 할 수 있는 편집 모드. 편집 결과도 미리보기 화면으로 보여준다.

Design & Split 편집 화면 구성
	Palette
		뷰와 레이아웃 항목들을 볼 수 있는 창
		뷰를 아래의 Tree로 드래그해 갖다놓으면 해당 요소를 현재 화면에 추가할 수 있다.
	Component Tree
		레이아웃과 뷰의 계층구조를 직관적으로 확인 및 편집할 수 있는 화면
	Attributes
		Tree에서 선택한 뷰 or 레이아웃의 세부 속성을 확인하고 편집할 수 있다.



===  버튼 추가하기 in Design

1)  Palette > Common > Button 클릭
	Palette 검색창에 Button 검색해서 찾아도 됨
2)  버튼 유형을 골라 추가할 레이아웃 아래에 끌어다 놓기



===  이미지 추가하기 in Design

ImageView
	선행)  이미지를 담을 레이아웃이 먼저 필요함
		수업에서는 RelativeLayout > LinearLayout (vertical) 추가함
	1)  Palette > Common > ImageView 클릭
	2)  추가할 레이아웃 아래에 끌어다 놓기
	3)  추가할 이미지 고르기 > OK



===  (예시) 부모 뷰를 기준으로 이미지 정렬하기 in xml

조건)  RelativeLayout 안에서만 사용 가능
1)  미리보기 화면에서 정렬할 이미지 클릭
2)  ImageView 태그 안에 아래의 코드를 추가
	android:layout_centerHorizontal="true"



===  배경 디자인 변경 in Design

background
	1)  배경을 바꿀 레이아웃 or 뷰 클릭
	2)  우측 Attributes의 검색창을 열고 background 검색
	3)  background 탭에서 배경화면 설정을 변경할 수 있음
		3-1)  설정 탭에서 스포이드를 누르면 배경색 변경 가능
		3-2)  설정 탭에서 우측 바를 누르면 Android 기본 제공 이미지 및 drawable에 등록한 사진으로 배경화면을 변경할 수 있음



===  텍스트 설정 in xml

text
	뷰에 텍스트 추가하기
	[xml]  android:text="추가할텍스트"

textColor
	텍스트 컬러 바꾸기
	[xml]  android:textColor="#헥스코드"

textSize
	텍스트 크기 바꾸기
	★sp
		텍스트 사이즈를 나타내는 단위
	[xml]  android:textSize="텍스트사이즈sp"



=====  기타 설명

안드로이드 공식 레퍼런스 사이트
	developer.android.com에서 Android Studio에 관한 모든 기능과 정보를 찾아볼 수 있다.
		ex)  더보기 > 문서 > 가이드 > 좌측 가이드 > 첫 앱 가이드
		ex)  참조 탭 > API 사용법

계층 구조가 어떻게 만들어져있는지 쉽게 확인하기
	에디터 왼쪽에 작은 +, -버튼을 눌러보면 누가 어디에 속해있는지 알 수 있다.
	xml과 java 파일을 가리지 않는다.

앱 만들기 : 화면설계/배치/코딩 다 하는 거

!! 업데이트된 커리큘럼 다시 저장하기.

다음주도 DB 범위가 시험 범위에 들어감.
	insert into, update set 계속 연습해야됨.
	기존 sql 조금이랑 안드 범위랑.


200604 목요일 수업 내용 메모



==============================

instar database 활용 예제 (RDS)

==============================



(1) 회원 중에서, 가입한지 가장 오래된 회원들 5명을 조회하시오.

select *
from users
order by created_at asc
limit 5;



(2) 회원 가입이 가장 많이 일어난 요일, 그 요일과 가입한 회원 수를 조회하시오.

keyword : ★dayname(), date(), group by, order by, limit
select dayname(created_at) as day, count(*) as total
from users
group by day
order by total desc
limit 1;

=====풀이

dayname(A) "날짜에서 영문 요일명로 바꿔 가져온다"
date(A) "날짜를 YYYY-MM-DD로 가져온다"
그룹해야하는 것과 정렬해야 하는 것이 무엇인지를 잘 생각해내자.
그리고 ★별명(as) 활용도 잘 하자.★



(3) 회원들 중에서, 사진이 없는(사진을 안 올림) 회원들의 이름을 조회하시오.
keyword : left join, is null

select u.username, p.image_url
from users as u
left join photos as p
on u.id = p.user_id
where P.image_url is null;

=====풀이

실무에서는 "활동을 안하는 회원"을 inactive user라고 부른다. active user는 "활동을 하는 유저"
컬럼 앞에 테이블 이름 좀 잘 붙여주셈.



(4) 가장 좋아요(인기가 많은)를 많이 받은 사진의 사진 작성자, 사진 url, 좋아요 수를 조회하시오.

==(4-1) 셀프 작성

select u.username, p.image_url, count(*) as likes
from users as u
join photos as p
on u.id = p.user_id
join likes as l
on u.id = l.user_id
group by l.user_id
order by likes desc
limit 1;

==(4-2) 강사님 작성

select u.username, p.image_url, count(*) as likes
	-- count(p.id)도 가능.
from photos as p
join likes as l
on l.photo_id = p.id
join users as u
on p.user_id = u.id
group by p.id
	-- l.photo_id도 가능.
order by likes desc
limit 1;

=====풀이★★★★★★★★★

사진에 눌러진 좋아요 갯수를 세야하므로 "사진"이 중심이 되어야 하고
그룹으로 묶는 것은 "사진"의 아이디여야 한다. 나는 연결도 유저 테이블 위주로 하고 그룹바이도 유저 아이디로 했다..
원하는 데이터를 조회하기 위해서는 무슨 값을 얻어야 하고 그 값을 얻기 위해서는 무슨 테이블(들)이 필요하고
뭘 join하고 뭘 group by해야하는지 어떻게 order by해야하는지 등등을 잘 생각해야한다. 이게 안 되는 거 같다.
좋아요 한 사람 수를 구해야 하는데 그 사람들 수를 묶어버렸다꼬.
그러면 1인당 좋아요를 누른 횟수는 몇인가를 구하는 게 되는 거다.



==============================

안드로이드 큰 흐름 보기

==============================

윈도우에서 안드 작업이 빨리 돌아가게(처리되게) 하기
	작업표시줄 우클릭 작업관리자 켜기
	안드의 부등호 기호 누르기
	밑에 있는 안드로이드 아이콘의 세부 정보 이동
	마우스 우클릭 - 우선순위 설정 - high(높음)으로 설정

새로운 프로젝트 만들고 샘플 앱 만들기
	파일 - new - new project - empty project - 앱이름작성(MyDiceApp) - 킷캣4.4 - finish

AndroidManifest.xml
	전체 앱에 대한 요약 정보를 가지고 있음.

.xml .java로 구성된 안드로이드
.xml 앱의 상태(구성요소). 앱을 구성하는 화면을 담당(화면, 구성요소 저장)
.java xml으로 만든 화면을 가지고 로직을 짬(어떻게 돌아가게 하겠다).(액션)

.mainactivity 위치 : 자바>패키지명>MainActivity
activity : 자바에서 실행한다는 뜻
앱을 실행하면 안드로이드에서 제일 먼저 실행하는 것은 메인액티비티 클래스이다. (메인함수와같다).

자바폴더 아래에는 폴더 묶음(패키지명)이 세 개 들어있다.
밑에 두 개는 자동을 만들어지는 거고 건드리면 안되고.
우리가 건드릴 거는 첫번째 패키지고
아이콘 설정, 앱 이름, 화면 테마 설정, 이 앱을 실행하면 뭐부터 실행하라고 정할 수 있다(디폴트는 메인액티비티)
앞으로 자바 코드를 쓴다고 하면 메인액티비티로 들어갈 거임.

매니페스트 폴더
자바폴더
res폴더

ic_launcher_background.xml
	벡터라고 쓰여있는 거 : 벡터이미지

activity_main.xml
	화면 담당하는 xml
		화면 속성들 핵심적인 거 몇개만 빼면 다 외울 필요 없다.
		레퍼런스를 찾아서 하면 된다.
	안드로이드 프레임워크가 xml파일을 
	화면을 담당하는 폴더는 res - 레이아웃 폴더의 액티비티_메인

화면을 만든다 > xml파일을 지지고 볶는다.
	난이도가 어렵진 않지만 노가다가 필요함.

res > mipmap 폴더 : 이미지 파일들을 저장
	jpg 확장자는 라이센스가 걸려있어서 png를 써야한다.

ic_launcher.png
	앱 아이콘(이미지 바꿔도 파일명 전부 동일)

안드개발자홈페이지에서 support differnt pixel 검색 > ~pixel densities 클릭 > 설명 뜸.
	안드는 제조사마다 해상도가 다 달라서 그거 커버하기 위해서 테스트를 많이 함. 그래서 앱 아이콘 파일이 그렇게 많은 거임.

깃헙에 실습파일 있음. 집파일 받기.

아이콘 바꾸기
values 폴더 > color.xml 컬러에 대한 요소를 정함
strings.xml 안드로이드에서 사용되는 글자들(버튼 글자 등등. ~입력하세요)
	문자열은 여기다 다 따로 빼서 넣는다(고정된 문자열). 자바 코드는 여기에 있는 문자열을 가져다가 쓴다.
		따로 문자열 xml이 있는 이유
		1. 깔끔하게 활용하고, 문자열을 쉽게 바꿀 수 있음.
		2. strings_en 등 다국어 언어파일을 만들어서 각 언어별로 관리를 쉽게 하기 위해서.
styles.xml 앱 테마에 대한 내용 - 안드로이드 메터리얼 디자인

아이콘 우리가 만든 걸로 바꾸기
res 마우스우클릭 > new > ★image asset(이미지 에셋 툴)클릭하면 아이콘 이미지 바꿀 수 있음.
path(경로) > 아이콘 파일 선택 후 오케이 > 컬러 백그라운드 컬러 이미지 크기조정 등등이 가능. > 넥스트 > 피니시

res-리소스라는뜻

자동으로 알아서 이미지 해상도를 맞춰주는 툴 - final android resizer
	선행 - 자바가 설치되어있어야 함. 자바 설치하러 ㄱ
		java 1.8 download 검색 > 첫번째 링크 java se development 머시기 클릭 > Java SE Development Kit 8u251 > Windows x64 다운받기(우측에 링크있음) > 오라클 로그인(가입 안 되어있으면 가입 후 로그인) 가입함 iamchoma@gmail.com Hwa~3 > 다운받아짐 > 자바설치파일실행 > 넥스트 > 진행중 > 다음> 또설치 > 클로즈 > 끝
	다운로드받아야함
	구글-android final resizer검색 - 이 툴을 사용하면 각 해상도별로 착착 만들어줌. - 첫 링크 클릭 - 깃헙(오픈소스)으로 넘어가기 - 쭉 내리기 >  jar, click here 클릭 > 계속 > 파일받아짐 Final Android Resizer.jar임 > 걍 실행되면 괜찮고 안 되면 jar 파일 열리는 경로를 자바 프로그램으로 바꿈 or cmd에서 java -jar "Final Android Resizer" 실행 or (이 파일이 있는 폴더에서 shift 우클릭 > 여기에 파워쉘 창 열기 클릭 > java -jar '.\Final Android Resizer.jar' 실행) > 암튼 실행됨

파이널 안드로이드 리사이저 설정바꾸기
아웃풋디렉토리 > 드로어블(res-drawable 폴더)로 바꿈 > 이미지 파일을 옮겨넣자마자 바로 지정한 폴더로 딱딱딱 바꿔서 저장시켜줌.

폴더 지정해줘야 됨.
res폴더에서 우클릭 > 쇼 인 익스플로러 > 여기서 경로 복사할 수 있음.
생성하면 res-drawable폴더 생기는데 그 안에 내용을 복사해서 res에 붙여넣으면 drawable에 연결된다. 안드 프로그램 들어가보면 drawable 폴더에 변환한 이미지 파일들이 주루룩 들어가있다.

액션 바 없이 나오게 하겠다
	res-values-styles.xml로 이동
	<style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar">로 변경 후 저장.
		실무에서 이렇게 함.

res-layout(화면처리하는 애들만 모아놓음. 화면 관련 모든것)-activity_main으로 감
	화면마다 레이아웃폴더밑에화면개수만큼 xml파일들이 생김.
		1화면당1레이아웃xml

xml 문법 <a> </a> 형식 or <a   /> <= 명칭 "★태그★"
중요한 것은 계층(계층구조, 포함관계)이 있다.
	상위계층이 있고 거기에 계속 포함되는 그런 계층. 
		포함되어있는가, 안 되어있는가.
		계층 알기 : 안드에디터창왼쪽에 있는 +_표시를 누르면 알 수 있음.

안드로이드 룰. 큰 틀이 있어야 한다. 그게 레이아웃이다.
액티비티 메인 

버튼만들기
팔레트or검색 > button 을 component tree  아래에 끌어다 놓으면 버튼이 화면에 만들어짐. 기본 배치는 가로로 배치됨.
	orientation 설정 안 되어있으면 가로로 설정되어있음. 이걸 버티컬로 바꾸면 세로로 들어가게 됨. 수평, 수직으로 바꿔줄 수 있는 것이 ★리니어 레이아웃.

리ㄹ니얼 레이아웃 배치 바꾸기
요소들을 감싸는 것 = 레이아웃
이미지 버튼 레이아웃이 수직으로 내려옴. 수직배치라고 함.
리니얼만 활성화(컴포넌트 ~ )되어있으면 화면에 아무것도 뜨지 않는다.

컴포넌트 트리-리니어레이아웃-

백그라운드 바꾸기
	검색버튼 클릭 : back~(백그라운드)  > 펜슬 모양 누르면 백그라운드 컬러 설정 가능.오른쪽에 있는 바 누르면 드로어블에 있는 사진 배경으로 추가 가능.

rgb를 16진수로 표현한 것이 #FFFFFF

이미지 추가하기
	이미지 넣기 전에 레이아웃 먼저 하나 만들고 그 안에 이미지를 넣는다.
왼쪽 검색창에 rela 뜨면 릴레이티브 뜸 그걸 리니어 레이아웃 속에 넣음
	리니어안에 릴레이티브레이아웃이 "포함"된 것임.
	여기에 이미지 뷰 넣기
	왼쪽 "커먼>이미지뷰" 이거를 릴레이티브 레이아웃 안에 끌어다 놓음.
	사진 선택하고 오케누르면 화면 안에 이미지가 삽입됨.

이미지 정렬하기(릴레이티브레이아웃 안에서만 사용가능)
	에디터 보기(xml코드) -이미지 클릭하면 이미지뷰에 커서 감 거기 안에 안드 줄 끝나는 데 바로 밑줄에 android: android:layout_centerHorizontal="true"를 추가하면 가운데 정렬됨.


레이아웃 : 담는 애
전체 크게 담는 애 :리니어레이아웃(화면전체)
    <RelativeLayout
        android:layout_width="match_parent" 
        android:layout_height="wrap_content"
        android:background="#000000">
		이렇게 바꿔보면 레이아웃이 보임.
		레이아웃 안에 이미지를 넣은 것.
  android:layout_width, 헤이스 => 레이아웃의 가로세로
	필수 요소(이미지 보이려면 가로세로 길이가 필요하니까)
		리니어레이아웃안에도 있음.
	match_parent => 디스플레이에 꽉차게 들어가라.(내 부모의 시작과 끝까지)
	wrap_content => 릴레이티브레이아웃 안에 들어있는 이미지의 길이만큼. 내가 포함하는 애(릴레이티브레이아웃)의 가로세로길이만큼.
		릴레이티브랑 이미지뷰 네개가 다 매치페어런트면 레이아웃 영역을 꽉 채워서 이미지가 들어감.
버튼이나 이미지의 위치를 어느 레이아웃에 넣느냐에 따라 조작할 수 있는 범위가 달라짐.

안드로이드:오리엔테이션="버티컬/호라이즌"
	리니어에서만 쓸 수 있음.

앱 만들기 : 화면설계/배치/코딩 다 하는 거.

버튼컬러바꾸기 
바꿀 버튼 클릭하고 xml코드 삽입
android:background="#CC0000"

버튼 안에 텍스트 넣기/바꾸기
android:text="Button" 여기 안에 넣으면 됨.

텍스트 컬러 바꾸기
 android:textColor="#FFFFFF"

글자 크기 바꾸기
  android:textSize="20sp" 글자의 단위는 sp

주사위 이미지 추가
	레이아웃 추가 배치(리니어레이아웃-호라이즌(가로로배치))
	여기에 이미지 추가

==============================

사진 이미지는 DB에서 처리(저장)하지 않는다.
	파일 시스템(S3)에서 저장한다.

파이어베이스?

다음주도 DB 범위가 시험 범위에 들어감.
	insert into, update set 계속 연습해야됨.
	기존 sql 조금이랑 안드 범위랑.

화면 설계 - 안드로이드

학원 테스트는 취업시 기술 면접 대비라고 생각하면 됨.

이론과 실무의 조화..

!! 업데이트된 커리큘럼 다시 저장하기.

DB 설계는 보통 짬있는 사람들이 한다.
그거 보고 분석할 줄 알아야 한다.

이미 만들어져 있는 거를 활용을 잘하자.

===이하 안드 관련 내용.

안드 개발할 때는 인제 여깅
안드 공식 레퍼런스 사이트. 안드 정보는 여기가 제일 정확.
developer.android.com > 더보기 > 문서 > 가이드 > 좌측 가이드 > 첫 앱 가이드 > 여기에 설명이 다 있음.

참조 탭 > API 사용법을 알 수 있음.

맨처음!! 자바카테고리의 메인액티비티부터 실행됨!!! 그리고 거기 중에서도 oncreate 함수가 제일 먼저 실행됨!!!!!!!!!!!!!

잘 처리됐는지 확인은 메인액티비티로.

rgb colors codes chart 검색 > 래피드 테이블스 사이트 > 200605 금요일 수업 키워드



태그  :  주사위, Dice, id, findViewById(), R.불러올곳.이름, @+id/, setOnClickListener, View.OnClickListener, onClick(), Button, Log.i(), Random, .nextInt(숫자범위), ImageView, setImageResource(), 



==============================
Android Studio
==============================



=====(1)  자바에서 res의 구성 요소를 불러오는 방법

id
	id나 파일명은 java에서 이들 요소를 쓸 수 있도록 해주는 "연결고리"이다.
	자바 파일에서는 res에서 쓰이는 파일 및 구성 요소들의 이름(id)를 활용해 res 안에 있는 것들을 가져다 활용할 수 있다.



=====(2)  자바에서 res 구성 요소를 저장하는 기본 방법

1)  MainActivity 클래스 아래에서 가져올 뷰의 멤버 변수를 선언
	[java]  데이터타입 변수이름;
		이 클래스의 어느 함수 안에서든 쓸 변수의 선언은 멤버 변수로 만들어야 효율적이다.

2)  setContentView(R.layout.activity_main); 밑에서 해당 변수를 초기화
	[java]  변수이름 = findViewById(R.불러올곳.이름);
		findViewById()
			xml에 등록된 View를 가져와주는 메소드.
		xml에 등록한 id와 헷갈리지 않도록, 변수 이름도 id와 똑같이 만들어주는 것이 좋다.

1-1)  "데이터 타입"에 들어올 수 있는 변수 이름
	xml에 추가한 구성요소들의 "태그 이름"을 쓰면 된다.
	ex) xml에서 이미지 뷰를 추가하고 이걸 java에서 불러와 저장할 땐, 데이터 타입을 ImageView로 적어주면 됨.

2-1)  R.불러올곳.이름
	안드는 res에 저장된 파일 및 구성요소들을 java에서 활용하도록 하기위해 각 경로별 이름(id)을 R 파일에 알아서 저장한다.
	R.id.구성요소ID
		res > layout > ~.xml에 등록된 구성요소 id를 불러온다
	R.drawable.이미지명
		res > drawable에 등록된 이미지 파일을 불러온다
	R.raw.미디어명
		res > raw에 등록된 미디어 파일을 불러온다
	R.layout.xml파일명
		res > layout에 등록된  ~.xml파일을 불러온다



=====(3)  Layout id 설정하기

주의사항
	id 이름은 직관적으로.
	한 xml에서 id 이름은 겹치면 안됨.

in Design
	1)  id를 변경할 요소를 Component Tree or 미리보기에서 클릭
	2)  Attributes 상단에 위치한 id 항목에서 id 확인 및 변경 가능

in xml
	1)  id를 변경할 요소(태그)를 찾아감.
	2)  해당 태그 맨 위에 아래의 코드를 적어 id를 만들거나 변경 가능.
		[xml]  android:id="@+id/ID이름"



=====(4)  버튼 클릭 후의 액션을 만들기

참고  :  (2)

1)  MainActivity Class 아래에 Button 멤버변수 선언하기

2)  onCreate 멤버 메소드 안, setContentView() 아래에서 아까 선언한 멤버 변수 초기화하기.

3)  이 버튼을 클릭할 때 실행될 이벤트를 담는 메소드를 작성한다.
	---[java]
	변수이름.setOnClickListener(new View.OnClickListener() {
	@Override
	public void onClick(View v) {
	
		}
	});
	---
	~ new View.OnClickListener를 적고서 경고창에 뜨는 Implement method를 누르면 알아서 오버라이드한 함수를 불러와준다.
	위 메소드를 Listener 함수라고 한다.
	
4)  onClick() { } 안에 클릭 이후 실행될 코드를 입력해주면 된다.



=====(5)  로그창에 로그(Log) 띄우기

로그를 적는 이유
	코딩 결과가 원하는대로 나오지 않았을 때 어디서 틀렸는지를 파악하기 위해 각 실행 코드마다 아래에 로그 메세지를 띄우는 함수를 쓴다.

로그 띄우는 함수
	Log.i()
		Log 메시지를 임의로 적어 띄운다.
		[java]  Log.i("앱이름", "띄울 메세지");
			""+띄울메세지
				Log.i()는 전부 문자열만 받으므로, 띄울 메세지에 숫자 등을 쓰고싶은 경우엔 앞에 ""+를 붙여 적으면 뒤에 붙은 메세지는 문자열이 된다.


=====(6)  Random 클래스를 활용해 랜덤 숫자 가져오기

Random 클래스
	랜덤과 관련된 기능을 사용할 수 있는 클래스

1)  Random 타입 변수 선언/초기화
	Random 변수이름1 = new Random();

2)  일정 범위 안에서 랜덤값을 돌려주는 정수 타입의 '변수이름2' 정의하기
	Int 변수이름2 = 변수이름1.nextInt(숫자범위);
		숫자 범위에 6을 쓰면 0부터 5까지를 불러온다.



=====(7)  불러온 이미지들과 랜덤 숫자를 연결하기

1)  버튼 누를 때마다 바꾸게 하려는 기본 이미지들 불러오기
	ImageView 변수이름3;
    ImageView 변수이름4;
	...
	변수이름3 = findViewById(R.id.아이디이름1);
	변수이름4 = findViewById(R.id.아이디이름2);

2)  drawable에서 바꿀 이미지들을 불러오되 배열로 멤버 변수 선언 및 초기화하기
	---
    int[] 변수이름5 = {R.drawable.이미지1, R.drawable.이미지2, R.drawable.이미지3, ..., R.drawable.이미지6);
	---
	안드로이드는 drawable에 저장한 이미지를 불러올 때(R.~.~) 정수로 바꿔서 관리하기 때문에 이미지를 불러오는 배열의 데이터 타입은 int[]여야 한다.
	랜덤 타입 변수가 얻는 숫자에 따라 이미지 모양을 바꾸기 위해 랜덤 숫자 범위와 이미지 배열 범위를 맞춰서 만들었다.



=====(8)  기본 이미지를 숫자에 따라 다른 이미지로 바뀌도록 만들기

setImageResource()
	기존 뷰를 다른 이미지로 바꿔주는 ImageView 클래스의 함수
	ex)  변수이름3.setImageResource(R.~.이름);

★★★배열변수[랜덤변수]
	ex) 저장해놓은 이미지를 랜덤 숫자와 연결한 이미지로 바꾸기
	---
	변수이름3.setImageResource(변수이름5[변수이름2]);
	---
	변수이름5는 0부터 5까지에 각각 이미지를 불러오는 주소가 적혀있고, 변수이름2는 0부터 5까지 랜덤한 숫자를 뽑아준다.
	변수이름2가 0을 돌려받으면 '변수이름3에 저장해놨던 이미지'를 배열의 0번째에 저장한 이미지1로 바꿔준다.



=====(9)  각각 다른 랜덤 숫자 2개를 만드는 방법 2가지

방법 1)  랜덤 변수 하나를 여러번 우려먹는 방법.
	---
	ex)  Random 변수1 = new Random();
		
		int 변수2 = 변수1.nextInt(6); // 1번째 초기화
		Log.i("앱이름", ""+변수2); // 1번째 출력
		
		변수2 = 변수1.nextInt(6); // 2번째 초기화
		Log.i("앱이름", ""+변수2); // 2번째 출력
	---
	두번째 출력 값은 랜덤값을 다시 주는 것과 같아서 첫번째 출력 값과 다른 결과가 나온다.

방법 2)  두가지의 랜덤 변수를 만들어서 다른 값을 도출하는 방법
	---
	ex)  Random 변수1 = new Random();
		
		int 변수2 = 변수1.nextInt(6);
		Log.i("앱이름", ""+변수2);
		
		int 변수3 = 변수1.nextInt(6);
		Log.i("앱이름", ""+변수3);
	---



=====(10)  res에 미디어 파일 저장하기

미디어들을 담을 폴더 만들기
	1)  res 우클릭 > New > Android Resource Directory 클릭
	2)  폴더 이름 raw, 리소스 타입 raw로 설정한 후 OK 클릭

미디어 파일 옮겨놓기
	1)  추가하고자 하는 미디어 파일을 Ctrl+C
	2)  안드에서 raw 폴더를 클릭하고 Crtl+V



=====(11)  java에 미디어 불러와서 저장하고 출력하기

MediaPlayer 멤버 변수 선언
	소리를 출력시킬 xml 화면과 연결된 java파일로 가서 MediaPlayer타입의 멤버 변수를 선언한다.
	ex)  MediaPlayer 변수이름;

출력할 효과음을 지정하는 초기화
	변수이름 = MediaPlayer.create(this, 미디어경로);
		여기서 미디어 경로는 "R.raw.미디어명"임.

지정한 미디어 출력하기
	변수이름.start();



=====(12)  라이브러리에서 필요한 기능을 찾아 프로젝트에서 활용하기

GitBub
	오픈소스 자료들을 보고 사용할 수 있는 사이트

검색 방법
	Android + 쓰고싶은기능이름으로 검색

Gradle Scripts 추가하기
	오픈소스에서 긁어온 gradle 코드를 내 프로젝트에 추가하는 방법
	1)  추가하고 싶은 gradle 코드를 복사
	2)  Android > Gradle Scripts > build.gradle (Module: app) 파일 열기
	3)  하단의 dependencies { } 안에 복사한 gradle 코드를 붙여넣기
	4)  붙여넣은 코드의 앞부분이 compile로 시작하면 전부 implementation으로 바꿔주기
		기능은 같지만 compile은 예전 버전용이라 호환되지 않음.
	5)  상단에 뜨는 Sync now 클릭
		새로운 라이브러리 기능을 가져다 쓸 수 있도록 만들어준다.
		Sync 누르고 에러 안 뜨면 성공적으로 기능들이 등록된 것임.

등록한 기능들 사용하기
	등록한 기능들을 쓸 수 있는 사용/활용법 정보를 사이트에서 보면서 잘 써먹으면 된다.



=====(13)  텍스트 관련 뷰를 활용한 테스트 앱 제작

margin
	뷰와 뷰 사이에 간격 주기
	in Design
		1)  트리에서 간격을 줄 뷰를 클릭
		2)  Attributes에서 margin 검색
		3)  간격을 주고싶은 위치에 주고싶은 간격을 dp로 입력
	in xml
		1)  간격을 주고 싶은 뷰 태그를 선택
		2)  android:layout_margin~="간격dp"
			margin
				사방에 간격을 준다
			marginTop
				위쪽에만 간격을 준다
			marginBottom
				아래쪽에만 간격을 준다
			marginLeft
				왼쪽에만 간격을 준다
			marginRight
				오른쪽에만 간격을 준다
			marginStart
				시작지점(왼쪽)부터 간격을 준다
			marginEnd
				끝지점(오른쪽)부터 간격을 준다

padding
	뷰 내부에 여백 주기
	in xml
		android:padding="여백dp"
			padding
				사방에 여백을 준다
			paddingTop
				위에만 여백을 준다
			paddingBottom
				아래에만 여백을 준다
			paddingLeft
				왼쪽에만 여백을 준다
			paddingRight
				오른쪽에만 여백을 준다
			paddingStart
				시작지점(왼쪽)부터 여백을 준다
			paddingEnd
				끝지점(오른쪽)부터 여백을 준다

theme - textAppearance
	안드로이드가 만들어놓은 스타일을 적용시키고 싶을 때 쓰면 됨.

"방향1|방향2"
	동시에 두 방향으로 정렬하는 방법
	ex)  오른쪽 아래 정렬
		android:gravity="right|bottom"

textAlignment
	텍스트 정렬
	[xml] android:textAlignment="정렬방향"

hint
	EditText에서 입력창을 누르면 사라지는 텍스트를 만들어주는 기능
	[xml] android:hint="힌트내용"

text 관련 뷰를 java에서 String 타입으로 전환하기
	자바에서 선언/초기화한 뷰 변수는 화면에 출력시키고 싶을 때 알아서 String 타입으로 변환되어 출력되지 않는다.
	선행)  text관련 뷰 변수를 선언/초기화
	String 변수이름2 = 변수이름1.getText().toString();

setText();
	텍스트 내용을 변경해주는 TextView 클래스의 함수
	변수이름.setText(바꿀텍스트내용);



===(13/1)  Toast 클래스의 기본 사용

하단에 잠깐 떴다가 사라지는 화면 만들기.

Toast.makeText().show();
	토스트 메세지를 띄워주는 기본 사용법
	선행 없음.
	Toast.makeText(현재클래스명.this, 띄울내용, Toast.떠있는시간).show();
		Toast.LENGTH_LONG
			떠있는 시간을 길게 설정한다
		Toast.LENGTH_SHORT
			떠있는 시간을 짧게 설정한다



=====  기타 정보

오픈소스 라이브러리들을 잘 알고 잘 활용하는 게 실력이다.

최신 문법에 뒤쳐지지 말자.

나 편한대로 생각하기
	set : 바꾼다(설정한다)
	get : 가져온다


200605 금요일 수업 메모

앱 개발 - 자바 & xml
	자바 - 앱의 액션
	xml - 앱의 구성요소 설정 / 화면 설정

manifests - AndroidManifest.xml
<activity android:name=".MainActivity"> </activity>
	.MainActivity를 실행한다는 뜻.

java - 첫 패키지명 폴더 - MainActivity
protected void onCreate(Bundle savedInstanceState) { }
	CPU는 여기로 제일 먼저 들어옴.
	여기 안에 레이아웃 실행 코드를 추가하면 됨.

setContentView(R.layout.activity_main)
	화면(레이아웃)은 이걸로 설정한다는 뜻.
	R.layout.activity_main
		R의 layout의 activity_main.xml
	xml에서 갖다 쓸 때는 R.~.ID

레이아웃 - 리니어 레이아웃(버티컬) : 최상위 레이아웃(세로로 정렬)

중앙 정렬 "속성을 주다"

텍스트 사이즈 단위 : sp
요소들의 사이즈 단위 : dp

orientation : 정렬설정

layout_width="" / layout_height="" 안에서 쓸 수 있는 것들
이미지뷰에 맞춰라 : wrap_content
부모의 사이즈에 맞춰라 : match_parent
요소들의 사이즈 단위 : dp

layout_weight="" : 비율 설정
모든 큰 틀의 요소의 높이를 0dp으로 맞추고 weight을 1로 맞추면 1 : 1 : 1 : 1 : ...의 비율로 정렬됨.
★이 중에서 한 요소의 높이를 다시 정하고 weight를 없애면,
이 요소를 제외한 영역에서 나머지 요소들이 1 : 1 : 1 : ..로 맞춰진다.

android:gravity="" 정렬 : gravity
android:gravity="center" 중앙 정렬
그냥 gravity : 레이아웃 안에 들어가는 애들(자식들)을 전부 어떻게 놓을거냐.
★"레이아웃(부모)"에서 쓴다.

android:layout_graivity=""
레이아웃(부모)로부터 이 개체는 어디에 위치할 것인가를 결정
android:layout_graivity="center_vertical" 중앙 정렬

android:layout_centerHorizontal="true"
android:layout_centerVertical="true"
android:layout_centerInParent="true"
이 정렬들은 릴레이티브레이아웃 아래에서만 쓸수 있음.
layout_centerInParent="" 부모 안(inParent)에서 중앙(center)정렬
	layout_centerHorizontal과 layout_centerVertical을 layout_centerInParent 하나로 퉁칠 수 있음.

// layout_graivity와 centerHorizontal/centerVertical/centerInParent의 차이

layout_graivity : 릴레이티브에서 센터호라이즌탈을 쓸 수 없기 때문에 레이아웃그래비티를 씀. 릴레이티브 외에서는 centerHorizontal/centerVertical/centerInParent를 못씀.
centerHorizontal/centerVertical/centerInParent : 릴레이티브 레이아웃에서만 쓸 수 있는 정렬 코드.

//레이아웃 종류에 따라서 쓸 수 있는 코드(속성)이 달라진다.

android:layout_width="wrap_content"
android:layout_height="wrap_content"
//어떤 뷰를 만들어도 위 두개는 모든 곳에 전부 필요함. 필수.

Attributes - id : 다른 곳(자바)에서 쓸 수 있도록 하는 연결고리
	아이디 이름 설정도 직관적으로 하는 것을 추천.
	한 xml에서 아이디 당연히 겹치면 안됨.
	xml에서 수정하려면 android:id="@+id/ID이름"

1. 버튼을 가져온다
	id를 찾아라
	findViewById(R.id.ID이름) 
		레이아웃에서 만든 id 이름을 파일 R 안에 안드가 자동으로 추가해줌
	
	이 id를 불러 가져와서 변수로 저장해죠라
	Button btnRoll = findViewById(R.id.btnRollDice);
		findViewById() 화면에 찍는 거 가져오기
			리스너 : 버튼 눌렀을 때 액션 정해주는 코드
	로그 출력 : 테스트할 때 잘 나오는지 파악하려고 꼭 추가함.

2. 버튼의 이벤트를 정의한다.
        변수이름.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
			
            }
        });
	// public void onClick(View v) {  }안에다 버튼을 누르면 동작시키고 싶은 코드를 작성한다.

3. 주사위 랜덤 돌리기 
	Log.i("MyDiceApp", "주사위 버튼 눌렸음!");

	Random rand = new Random();
	int diceNumber = rand.nextInt(6);

	Log.i("MyDiceApp", ""+diceNumber);
		""+숫자 : 문자열 만드는 방법(문자열이랑 숫자랑 붙이기)
		Log.i() 안에는 문자열만 들어가야하기 때문에 숫자함수는 ""+해서 문자로 만들어준다.

---메모옮겨적기(걍 코드 다긁어옴)

import androidx.appcompat.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.ImageView;

import java.util.Random;

public class MainActivity extends AppCompatActivity {

    // '레이아웃'에서 'ImageView'로 등록한 이미지 불러오기
    ImageView diceImg1;
    ImageView diceImg2;

    // 'res > drawable' 폴더에 등록된 이미지들 불러오기
    // 안드로이드는 'R.drawable.이미지명'으로 불러온 이미지들을 정수로 바꿔서 관리하기 때문에 ★이미지를 불러오는 배열의 데이터타입은 'int'여야한다.★
    int[] diceImages = {R.drawable.dice1, R.drawable.dice2, R.drawable.dice3,
            R.drawable.dice4, R.drawable.dice5, R.drawable.dice6};

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

            // diceImg1,2 변수 초기화
            diceImg1 = findViewById(R.id.imgDice1);
            diceImg2 = findViewById(R.id.imgDice2);

            // 1. 버튼 가져온다.
            Button btnRoll = findViewById(R.id.btnRollDice);

            // 2. 버튼에 이벤트를 정의한다.(리스너를 달아준다)
            btnRoll.setOnClickListener(new OnClickListener() {
        @Override
        public void onClick(View v) {

            // 3. 이 안에다 동작시키고 싶은 코드를 작성한다.

            // 3-1. 버튼이 눌렸을 때 실행 순서
            Log.i("MyDiceApp", "주사위 버튼 눌렸음!");
			
            // 3-2. 랜덤으로 한개 숫자 가져오기
            Random rand = new Random();
            int diceNumber = rand.nextInt(6);
            Log.i("MyDiceApp", ""+diceNumber);
            // firstDiceNumber 는 0~5까지 나온다.
            // 따라서 다이스 넘버에 해당하는 숫자가, 이미지 배열(diceImages)의 인덱스와 같다

            // 3-3. 가져온 숫자에 맞는 주사위 이미지를 셋팅한다.
            // 멤버변수 선언. '공용' 셋팅(변수 선언)은 멤버변수로!!

            // ImageView 타입으로 저장한 이미지를 diceImages 배열에 저장한 이미지(drawable 에서 불러온 이미지)로 바꾸기(예시)
            // diceImg1.setImageResource(diceImages[5]);
            // diceImg2.setImageResource(diceImages[4]);

            // diceImg1의 이미지 바꾸기
           diceImg1.setImageResource(diceImages[diceNumber]);

            // diceImg2도 이미지 바꿔주기
            diceNumber = rand.nextInt(6);
            diceImg2.setImageResource(diceImages[diceNumber]);

            // 이렇게도 쓸 수 있음
            // int diceNumber1 = rand.nextInt(6);
            // Log.i("MyDiceApp", ""+diceNumber1);
            // diceImg2.setImageResource(diceImages[diceNumber1]);
            
        }
        });
    }
}

---긁어오기 끝

// 버튼 누를 때 소리 추가하기
res 우클릭 - 뉴 리소스 딕셔너리 - 이름 raw 리소스 타입 raw - 오케이
	// 앱 안에서 오디오나 비디오 파일을 실행하게 만들겠다 하면 이 폴더 안에 추가하면 된다.
폴더에 파일 추가하기
	// 방법1) 파일 드래그
	// 방법2) 폴더에서 파일 직접 클릭해서 Ctrl+C 안드에서 붙여넣을 폴더 클릭하고 Ctrl+V
	
android usb driver 검색 > 공식 페이지에서 운영체제 선택해서 oem usb 드라이버 다운받기
or 꽂으면 그냥 연결되기도 함.


==============================================

5교시 ~ 8교시

==============================================

// 버튼 누를 때마다 효과음 나오게 하기
    // 효과음 나오게 하는 함수의 변수 선언
    MediaPlayer mp;
	
	// 효과음 create - this 는 '이 클래스'를 가리킴. this. 생각하면 됨.
	// '이 클래스'에서 이 음악파일을 사용할 거라고 알려주는 것.
	// 사용할 준비가 된 것. 효과음 실행은 별개.
	mp = MediaPlayer.create(this, R.raw.dice_sound);
	
	// 효과음 start
	mp.start();

// 버튼 누르고 숫자 바뀔 때마다 주사위에 애니메이션 효과 넣기
	// 다른 사람이 만든 라이브러리 가져와야됨.

~오픈소스 라이브러리 이용하는 방법~
// 오픈소스 라이브러리들을 잘 알고 잘 활용하는 게 실력.
깃허브(오픈소스)에서 android ~ 검색
여기서는 android animation 검색함
~~

Gradle Scripts
Module build.gradle - dependencies 아래에 'gradle 코드'를 긁어와서 추가한다.
--- gradle 코드

        compile 'com.android.support:support-compat:25.1.1'
        compile 'com.daimajia.easing:library:2.0@aar'
        compile 'com.daimajia.androidanimations:library:2.3@aar'

세 줄 중에 맨 위에 한 줄은 없으면 추가하고 있으면 삭제함.
그리고 버전이 바뀐 상태이므로 compile을 implementation으로 바꿔준다.
~~최신 문법에 뒤쳐지지 말기

위에 뜨는 Sync now 눌러주기 (새로운 라이브러리 가져다 쓰게 해줌)
	싱크하고 에러 안 드면 성공한 거임.

--- 두번째 코드 긁어옴
YoYo.with(Techniques.Tada)
    .duration(700)
    .repeat(5)
    .playOn(findViewById(R.id.edit_area));

--- MainActivity로 돌아와서 온클릭에 붙여넣음.
라이브러리를 추가해서 YoYo와 Techniques를 쓸 수 있게 됨.
.playOn() 안을 애니메이션을 굴릴 이미지를 넣어줌.

	YoYo.with(Techniques.RollIn)
			.duration(400) // 초(밀리세컨. 2000 = 2초)
			.repeat(1)
			.playOn(diceImg1);
	YoYo.with(Techniques.RollIn)
			.duration(700)
			.repeat(1)
			.playOn(diceImg2);

==============================
TextView : 화면에 텍스트 보이게 하기
EditText : 입력창 만들기/설정
Toast : 앱 화면에 나타났다 사라지는 거
Button : 버튼.
==============================

릴레이티브레이아웃은 상관관계(항상 상대방이 있음)
릴레이티브레이아웃 기준으로 뭐를 어디에 놓을 거냐를 정해줄 수 있다.

layout_centerHorizontal 부모로부터 가운데로 와라

액티비티 메인의 제일 큰 레이아웃창을 RelativeLayout으로 바꿔주고 작업을 시작한다.

특정 텍스트 창 위에 특정 텍스트 창 놓기.

1. 텍스트값마다 아이디 설정해주기

2. android:layout_above="@id/text1" text1 위로 와라.

복수의 텍스트 박스 사이에 간격 주기 : margin
margin을 준다.
	android:layout_margin="30dp" 4방향 모두에서 30dp만큼 간격을 둬라.

// 텍스트 옵션은 우측에 물음표에서 검색해서 바꾸면 된다.

// 주요 검색어들
textSize 텍스트 사이즈 설정
layout_margin 텍스트 박스 주변 간격 설정
padding 텍스트 박스 안의 여백 설정
theme(
	textAppearance 텍스트 스타일 정해주기
	안드가 만들어놓은 스타일대로 하겠다. 할 때 이거 쓰면 된다.

xml에서 변경하기
	android:padding="30dp" 사방(외부)에 30dp의 간격 주기
	android:gravity="center" 내부 텍스트 가운데 "정렬"
        android:gravity="right|bottom" 오른쪽 아래에 정렬 | = or

큰 레이아웃 바꾸기
릴레이티브를 리니어 레이아웃으로 바꾸기 
LinearLayout
    android:orientation="vertical" 그리고 이거 추가하기(정렬)
	xml에서 버튼 탭 수정하기
		android:layout_gravity="center_horizontal" 버튼을 가로의 중앙으로 정렬해라.
	버튼 크기 키우기
		android:layout_width="150dp"
		android:layout_height="60dp"

자바 파일로 버튼 클릭 이벤트 만들기
200605 월요일 수업 메모 정리

pixabay.com

이미지는 png

res폴더 파일명 규칙
	yes 소문자, 언더스코어(_)
	no 대문자, 기타 모든 문자

Ctrl + Space 추천 명령어 표시

scaleType
	뷰 영역 내에서 이미지 맞추기
		centercrop 가로세로 뿌시지 않고 영역에 맞게 잘라주기만 함
		centerinside 이미지 뿌시지 말고 영역 안에 다 넣어라
		fitcenter 가운데를 중심으로 영역 안에 넣어라
		fitend 아래 끝선을 중심으로 영역 안에 넣어라
		fitxy 영역 안에 꽉 차게 넣어라

ConstraintLayout
	미리보기 화면에서 직접 마우스 드래그로 끌어다 배치할 수 있는 레이아웃
	뷰마다 사방에 붙은 선을 지우거나 연결시켜서 배치한다.

변수이름.setOnClickListener(new View.OnClickListener() {});
	버튼 타입 변수인 '변수이름'을 누를 때 들어가는 행동을 지정하는 함수
		{}안에 입력한다.

자바 등등 코딩을 할 때는 작업 순서를 //로 미리 적어놓는다.

Log.i("태그", "로그내용");
	태그는 로고 검색용 태그. 보통 앱 이름으로 적는다고 한다.

문자가 포함되어있는 뷰에 적힌 문자를 java 파일에서 String 타입으로 바꾸기
	String 변수2 = 변수1.getText().toString();
		getText(), toString() 설명
			getText() 여기(뷰)에 쓴 텍스트를 가져온다
			toString() String 타입으로 가져온다

Calendar
	현재 날짜를 가져와서 활용할 수 있는 클래스
	Calendar 타입 변수 선언/초기화하기
		Calendar 변수1 = Calendar.getInstance();
			이거 하나만 만들어놓으면 여기서 현재 년도랑 월 등을 가져올 수 있다
	Calendar 클래스를 활용해서 년도 가져오기
		변수1.get(Calendar.YEAR);
		Calendar 함수의 년도를 가져와서 Calendar 타입 변수 '변수1'에 저장

텍스트의 숫자화
	Integer 변수1 = Integer.parseInt(숫자로바꿀String);
	자매품 Float, Double, ...

200605 월요일 수업 메모

픽사베이에서 이미지 긁어오기
pixabay.com

긁어와서 FAR로 이미지 수정

jpg 노노햄. png 고고

res폴더의 파일명 규칙
	소문자, 언더스코어_만 가능
	대문자, 띄어쓰기, 기타 문자 불가능

ctrl+space 추천 명령어 표시

android:scaleType="center"
centercrop 가로세로 뿌시지 않고 영역에 맞게 잘라주기만 함
centerinside 이미지 뿌시지 말고 영역 안에 다 넣어라
fitcenter 가운데를 중심으로 영역 안에 넣어라
fitend 아래 끝선을 중심으로 영역 안에 넣어라
fitxy 영역 안에 꽉 차게 넣어라

ConstraintLayout
	미리보기 화면에서 직접 마우스 드래그로 끌어다 배치할 수 있는 레이아웃
	뷰마다 사방에 붙은 선을 지우거나 연결시켜서 배치한다.
	
btnCal.setOnClickListener(new View.OnClickListener() {
외워야하는 거

자바 등등 코딩을 할 때는 작업 순서를 //로 미리 적어놓는다.

String catYear = editYear.getText().toString();
	getText() 여기에 쓴 텍스트를 가져온다
	toString() String으로 가져온다

=================================
화면에 띄워진 이미지를 버튼을 누르면 다른 이미지로 바뀌도록 만들기

해보셈. 했음.
=================================한 거
import androidx.annotation.RequiresApi;
import androidx.appcompat.app.AppCompatActivity;

import android.graphics.drawable.Drawable;
import android.os.Build;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {

    TextView txtTitle;
    EditText editName;
    EditText editPhone;
    ImageView btn_star_big_off;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        txtTitle = findViewById(R.id.txtTitle);
        editName = findViewById(R.id.editName);
        editPhone = findViewById(R.id.editPhone);
        btn_star_big_off = findViewById(R.id.btn_star_big_off);

        Button btnClick = findViewById(R.id.btnClick);
        btnClick.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Log.i("MyTest", "Click Me!");

                // 로그에 출력하기 위해서 txtTitle 을 String 타입으로 변환함
                String text = txtTitle.getText().toString();
                Log.i("MyTest", "get text : "+text);

                // txtTitle 의 내용을 editName, editPhone 에 입력한 내용으로 변환하기 위해
                // editName 과 editPhone 모두를 String 타입으로 변환한다
                String name = editName.getText().toString();
                String phone = editPhone.getText().toString();

                // xml 에서 불러온 text 내용 변경하기 setText();
                txtTitle.setText(name + "\n" + phone);

                // 버튼을 누르면 toast 화면 띄우기
                Toast.makeText(MainActivity.this, name + "\n" + phone,
                        Toast.LENGTH_LONG).show();

                // 버튼을 누르면 btn_star_big_off 이미지를 ~_on 으로 변경하기
                btn_star_big_off.setImageResource(android.R.drawable.btn_star_big_on);

            }
        });

    }
}

=================================
고양이 나이계산 코드긁어옴

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class MainActivity extends AppCompatActivity {

    EditText editYear;
    TextView txtAge;
    Button btnCal;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        editYear = findViewById(R.id.editYear);
        txtAge = findViewById(R.id.txtAge);
        btnCal = findViewById(R.id.btnCal);

        btnCal.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {

//                // 내가 만든 ver.
//                // 1. 현재 날짜 가져오기
//                Calendar cal = Calendar.getInstance();
//                int yearNow = cal.get(Calendar.YEAR);
//
//                // 2. editYear 를 int 타입으로 바꾸기
//                Integer i = Integer.parseInt( "" + editYear.getText() );
//
//                // 3. 현재날짜 - editYear 에 적힌 날짜 빼기
//                int result = yearNow - i;
//
//                // 4. calAge 에 출력하기
//                txtAge.setText(""+result);
//
//                // 5. editYear 에 입력된 내용 지우기
//                editYear.setText("");

//                // 강사님 ver.
//                // 1. editYear 에 적혀있는 글자 가져오기
//                String catYear = editYear.getText().toString();
//                Log.i("MyCat", "유저가 입력한 값은 : "+catYear);
//
//                // 2. 이번 년도에서, 가지고 온 년도를 뺀다
//                int catAge = 2020 - Integer.parseInt(catYear);
//                Log.i("MyCat", "계산한 나이는 : "+catAge);
//
//                // 3. calAge 에 표시하기
//                txtAge.setText(""+catAge);
//
//                // 4. editYear 내용 지우기
//                editYear.setText(""); // setText(null); 도 가능함.
//            }
//        });
//
//
//    }
// }

=================================
5~8교시
=================================

=== Quiz app

프로그래스 바, 프로그래스 바 (Horizontal)
	어느정도 상황이 진척되었는지 알 수 있는 뷰
	팔레트 > 위젯 에서 끌어옴.
	로딩중.. 그거..
	common attributes > max에서 max 수치를 설정해줄 수 있다.
	.incrementProgressBy(증가할숫자);
		프로그래스바의 숫자를 증가시킨다

뷰 복수선택 후 한번에 속성 주기 가능. ex) margin

텍스트뷰 내부 텍스트 정렬은 textAlign도 있지만 android:gravity를 쓰는 게 더 좋은 거 같다.

stats : 상태

Toast.makeText(MainActivity.this,
		"트루 버튼이 눌렸습니다.", Toast.LENGTH_SHORT).show();
	가장 처음 쓰는 것은 '지금 액티비티의 this'를 써야한다.

strings.xml
	앱 내에 고정으로 사용하는 문자열들을 저장하는 곳.
	<string name="q1">A honey bee can fly at 15mph.</string>

생성자
	new 키워드와 함께 쓰면 객체가 생성될 때 뿅하고 실행되는 거.

게터세터 만들기
	프라이베이트 멤버변수를 불러들이고 내보내기 위해서임.

생성자 만들어주는 메뉴
	에디터에서 우클릭 > 제너레이트 > Constructor

게터세터 만들기(메모해놨던 거 있음)
	에디터에서 우클릭 > 제너레이트 > 게터세터

안드로이드는 res 안의 구성요소들을 int로 처리한다. id도, string도.
    <string name="q1">A honey bee can fly at 15mph.</string>
    <string name="q2">A jellyfish is approximately 95% water.!</string>
	q1은 1, q2는 2로 저장하는 식.

R.string.q1
	res > values > strings.xml에서 name = "q1"불러오기

숫자 % 나눌 숫자 ★★★★★★★★★
	나머지 숫자 구하기...ㅠㅠ 이거 ㄹㅇ진짜핵중요

?? 설계가 힘두로요..

기본 문법이랑 기능들을 충실하게 알아놓는 게 중요할 거 같다.

행동은 onCreate에서만 한다는 거 잊지 말자.

아무 설정도 하지 않았을 때, 화면을 돌릴 때마다 코드가 초기화되는 문제 해결하는 방법 2가지(하나는 내일 할 거임)
	1) 폰 못 돌아가게 막기 (화면 회전 막기)
		매니패스트xml로 이동 > 
		<activity android:name=".MainActivity"> "안에 뒤에" 아래 내용 추가하기
			android:screenOrientation="portrait"
				"화면을 세로로 고정"
			가로 고정은 landscape

★★★ AlertDialog
	AlertDialog를 사용하려면 AlertDialog.Builder 타입의 변수를 만들어야 함.
		new DialogInterface.OnClickListener()
		앱 종료 후의 액션을 정한다(오버라이딩 메소드 생성됨)

	finish()
	앱을 종료시키는 코드

	quizAlert.show(); 이걸 꼭 적어줘야 알러트 화면이 나타남
	return;  이걸 해줘야 CPU가 더이상 밑으로 안 내려가고 앱은 onClick 함수에서 벗어나서 대기상태로 돌아간다.

★★★ 어디다 코드를 적어줘야 될지 위치를 잘 잡는다.

========================================
5~8교시 수업 코드 복붙
========================================
MainActivity.java
========================================

import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;

import android.app.Dialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {

    TextView txtQuestion; // 질문 출력
    ProgressBar quizPB;
    TextView txtStats; // 총 맞춘 갯수 출력
    Button btnTrue;
    Button btnFalse;

    // 문제와 정답을 저장하기 위한 배열 멤버변수 저장하기
    QuizModel[] questionArray = new QuizModel[]{
        new QuizModel(R.string.q1, true),
        new QuizModel(R.string.q2, false),
        new QuizModel(R.string.q3, true),
        new QuizModel(R.string.q4, false),
        new QuizModel(R.string.q5, true),
        new QuizModel(R.string.q6, false),
        new QuizModel(R.string.q7, true),
        new QuizModel(R.string.q8, false),
        new QuizModel(R.string.q9, true),
        new QuizModel(R.string.q10, false),
    };

    // 저장한 questionArray 를 활용하기 위한 "int 타입" "인덱스" 변수 선언
    int questionIndex;
    // 스코어를 기록하는 멤버 변수
    int score;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 온크리에이트 함수에서 아이디를 가져온다(초기화한다)
        txtQuestion = findViewById(R.id.txtQuestion);
        quizPB = findViewById(R.id.quizPB);
        txtStats = findViewById(R.id.txtStats);
        btnTrue = findViewById(R.id.btnTrue);
        btnFalse = findViewById(R.id.btnFalse);

        btnTrue.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                // btnTrue 눌렀을 때 "트루 버튼이 눌렸습니다."라고 토스트 찍기
                // Toast.makeText(MainActivity.this,
                        // "트루 버튼이 눌렸습니다.", Toast.LENGTH_SHORT).show();

                // 버튼을 누르면 true 를 evaluateUserAnswer();에 넘겨준다
                evaluateUserAnswer(true);
                // 다음 문제를 화면에 불러오기
                questionIndex = (questionIndex + 1) % 10; // 문제 무한 순환시키기
                Log.i("MyQuiz", "questionIndex number : "+questionIndex);
                    // 모듈(%)로 나머지 불러오기. % 10쓰면 10문제까지만 순환됨.
                    // 인덱스에는 10 이상은 올 수 없어야 한다.
                // 문제 다 풀면 앱 종료 창 띄우기 AlertDialog
                if(questionIndex == 0){ // why == 0??? not > 9???
                    Log.i("MyQuiz","AlertDialog");
                    AlertDialog.Builder quizAlert = new AlertDialog.Builder(MainActivity.this);
                    quizAlert.setTitle("퀴즈 앱 종료");
                    quizAlert.setMessage("당신의 점수는 "+score+"점 입니다");
                    quizAlert.setPositiveButton("앱 종료", new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            finish();
                        }
                    });
                    quizAlert.show();
                    return;
                }

                QuizModel q = questionArray[questionIndex];
                txtQuestion.setText(q.getmQuestion());

            }
        });

        btnFalse.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                // btnFalse 눌렀을 때 "펄스 버튼이 눌렸습니다."라고 토스트 찍기
                // Toast.makeText(MainActivity.this,
                        // "펄스 버튼이 눌렸습니다.", Toast.LENGTH_SHORT).show();

                // 버튼을 누르면 false 를 evaluateUserAnswer();에 넘겨준다
                evaluateUserAnswer(false);
                // 다음 문제를 화면에 불러오기
                questionIndex = (questionIndex + 1) % 10;
                Log.i("MyQuiz", "questionIndex number : "+questionIndex);

                if(questionIndex == 0){
                    Log.i("MyQuiz","AlertDialog");
                    // 알러트 다이알로그를 이용하려면 AlertDialog.Builder 로 객체를 생성해야 한다.
                    AlertDialog.Builder quizAlert = new AlertDialog.Builder(MainActivity.this);
                        // MainActivity.this  :  메인 액티비티에서 띄울 거다라는 뜻.
                    quizAlert.setTitle("퀴즈 앱 종료"); // 다이알로그의 제목(볼드체)
                    quizAlert.setMessage("당신의 점수는 "+score+"점 입니다"); // 다이알로그의 메세지
                    quizAlert.setPositiveButton("앱 종료", new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialog, int which) {
                            // 앱을 종료시키는 코드
                            finish();
                        }
                    });
                    quizAlert.setNegativeButton("취소",null); // 아직 설명 없음
                    quizAlert.setNeutralButton("중간", null); // 아직 설명 없음
                    // 버튼은 기본적으로 딱 세 개 적용.
                    quizAlert.show();
                    return;
                }

                QuizModel q = questionArray[questionIndex];
                txtQuestion.setText(q.getmQuestion());
            }
        });

        // 저장한 배열 변수가 잘 불러와지는지 확인하기
        // txtQuestion.setText(questionArray[0].getmQuestion());

        // 첫 문제 먼저 txtQuestion 에 불러오기
        QuizModel q = questionArray[questionIndex];
        txtQuestion.setText(q.getmQuestion());
        // 디폴트 스코어를 표시
        txtStats.setText("Correct Score : "+score+" / 10");

    }

    // 유저의 대답(버튼 클릭)을 체크하는 멤버 함수를 만든다 > 스독 코드?
    // 대답이 맞으면 토스트에 "정답입니다", 틀렸으면 "오답입니다"를 보여준다.
    void evaluateUserAnswer(boolean userAnswer){
        // 현재 문제의 정답을 가져오는 코드
        QuizModel q = questionArray[questionIndex];
        boolean answer = q.getAnswer();
        // 유저의 대답과, 현재 정답을 비교해 토스트하는 코드
        // 정답일 때만 스코어를 +1씩 증가시켜준다
        if(userAnswer == answer) {
            score = score + 1;
            Toast.makeText(MainActivity.this, "정답입니다", Toast.LENGTH_SHORT).show();
        }else{
            Toast.makeText(MainActivity.this, "오답입니다", Toast.LENGTH_SHORT).show();
        }

        // 위 작업이 끝난 이후 스코어를 표시
        txtStats.setText("Correct Score : "+score+" / 10");
        // 대답을 한 번 할 때마다(버튼을 누를 때마다) 문제의 진행도를 프로그래스 바로 표시
        quizPB.incrementProgressBy(1);
    }

}
==========================================
AndroidManifest.xml
===========================================
    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity android:name=".MainActivity"
            android:screenOrientation="portrait">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
=============================================
activity_main.xml
============================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity">

    <TextView
        android:id="@+id/txtQuestion"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_gravity="center_horizontal"
        android:layout_marginLeft="15dp"
        android:layout_marginTop="15dp"
        android:layout_marginRight="15dp"
        android:layout_marginBottom="10dp"
        android:layout_weight="1"
        android:gravity="center"
        android:text="TextView"
        android:textSize="24sp" />

    <ProgressBar
        android:id="@+id/quizPB"
        style="?android:attr/progressBarStyleHorizontal"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_marginLeft="15dp"
        android:layout_marginRight="15dp"
        android:layout_marginBottom="10dp"
        android:layout_weight="1"
        android:max="10" />

    <TextView
        android:id="@+id/txtStats"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_marginLeft="15dp"
        android:layout_marginRight="15dp"
        android:layout_marginBottom="10dp"
        android:layout_weight="1"
        android:gravity="center"
        android:text="TextView"
        android:textSize="24sp" />

    <Button
        android:id="@+id/btnTrue"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_marginLeft="15dp"
        android:layout_marginRight="15dp"
        android:layout_marginBottom="10dp"
        android:layout_weight="1"
        android:background="#2196F3"
        android:text="True Button"
        android:textColor="#FFFFFF" />

    <Button
        android:id="@+id/btnFalse"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_marginLeft="15dp"
        android:layout_marginRight="15dp"
        android:layout_marginBottom="15dp"
        android:layout_weight="1"
        android:background="#F44336"
        android:text="False Button"
        android:textColor="#FFFFFF" />
</LinearLayout>
========================================
QuizModel.java
========================================
// 퀴즈 처리를 위한 클래스
public class QuizModel {

    private int mQuestion;
    private boolean mAnswer;

    public QuizModel(int mQuestion, boolean mAnswer) {
        this.mQuestion = mQuestion;
        this.mAnswer = mAnswer;
    }

    public int getmQuestion() {
        return mQuestion;
    }

    public void setmQuestion(int mQuestion) {
        this.mQuestion = mQuestion;
    }

    public boolean getAnswer() {
        return mAnswer;
    }

    public void setAnswer(boolean mAnswer) {
        this.mAnswer = mAnswer;
    }
}
=========================================
strings.xml
=========================================
    <string name="q1">A honey bee can fly at 15mph.</string>
    <string name="q2">A jellyfish is approximately 95% water.!</string>
    <string name="q3">Elephants are the only mammals that can\'t jump</string>
    <string name="q4">Cats can hear ultrasound.</string>
    <string name="q5">A human brain weighs about three pounds.</string>
    <string name="q6">The tongue is the fastest healing part of the body.</string>
    <string name="q7">Americans, on average, eat 18 acres of \"pizza\" a day.</string>
    <string name="q8">A kangaroo can jump 30 feet.</string>
    <string name="q9">A pigeon\'s feathers are heavier than its bones.</string>
    <string name="q10">The tallest man was 8 ft. 11 in.</string>
==========================================

get은 돌려주는 값이 있어야 하고(not void),
set은 setting만 해주는 것(void) 잊지 말기.200609 화요일 수업 메모 정리200609 화요일 수업 메모

android:screenOrientation=""
tools:ignore="LockedOrientationActivity"

ConstraintLayout & RelativeLayout은 미리보기 화면에서 직접 드래그해서 이동시킬 수 있다.

"하드 코딩" 되어있다
	레이아웃 xml에서 고정된 문자열을 쓸 때 strings에 저장하지 않고 그냥 쓰면 삼각형 느낌표에 "하드 코딩이 되어있다"는 메세지가 뜬다.
	삼각형 경고창 > Fix 버튼을 누르면 바로 strings에 추가할 수 있는 설정창을 띄워준다.

<> 는 태그

파란글씨는 어트리뷰트(속성)

= 는 value

<>여기</> 는 텍스트영역

@string/이름
	string.xml에서 해당name의 문자열 내용을 불러온다

@+id/아이디
	에서 아이디 이름에는 대문자 들어가면 안됨.
	자바에서 클래스 외의 명명은 소문자로 시작해야 한다.

뷰 속성(ImageView, TextView, EditText 등등)은 클래스이다.
	그래서 맨 앞문자를 대문자로 쓰는 거다.

숨은 오류를 찾아 고쳐보자.
방어코드 설계.
ex) 아무 것도 입력 안 하고 계산 버튼 누르면 꺼지는 오류
	해결방안) 입력하라고 토스트 띄우고 리턴해서 대기한다.

변수.isEmpty()
	변수에 값이 없으면(비어있으면)
	변수.compareTo("") == 0
		변수.isEmpty()와 같음.

---이하 복붙---
// 값이 둘 중에 하나라도 입력되지 않았을 경우 토스트를 띄워 숫자를 입력하라고 요청하기
	// 입력하라고 요청하고 CPU 는 리턴 후 onCreate()에서 대기한다
	// 일단 뷰는 문자열값으로 만든 다음 비교가 가능하기 때문에 먼저 뷰 속성을 문자열로 바꿔줬다.
// isEmpty() 활용하기
if(editPerString.isEmpty() || editNumString.isEmpty()){
	Toast.makeText(MainActivity.this, "숫자를 입력해주세요",
			Toast.LENGTH_SHORT).show();
	return; // 이 아래로는 실행하지 말고 위로 돌아가서 대기해라
}
----------

작업방식
	함수 안에서 코드 쓰다가 길어지면 밖으로 따로 빼서 멤버 함수를 또 만드는 방법이 자연스럽다.
	
---복붙---
// 위의 다이얼로그를 화면에 띄워라.
countAlert.show();
return;
----------

----------
// 캔슬(Cancelable) 불가(false) 설정(set)
// alert 화면이 떴을 때 alert 외의 다른 곳을 눌러도 alert 가 자동으로 사라지지 않게끔 하는 설정
변수1.setCancelable(false);
----------

앞으로는 자바에서든 xml에서든 strings.xml을 잘 활용하자.

R.string.이름

★★★Android Activity Life Cycle (안드로이드 액티비티 수명 주기)
	call back(콜백), 콜백 함수
		ex) onCreate : 유저가 앱을 켜면 onCreate가 호출된다.	
			"onCreate 콜백함수"
	CPU 실행 순서대로가 아니라 유저에 행동에 의해서 어떤 액션이 있을 때 실행되는 함수 = 콜백함수
		"★유저★가 버튼을 누르면 이 안의 함수가 호출된다."
	콜백 함수들의 실행 순서를(이 콜백은 어디서/언제 실행되는지를) 외워야한다.
	화면이 여러개인 앱을 만들 때 필수로 알아야하는/써야하는 개념이다.
	onCreate()의 부모에게 있는 onStart()와 onResume()도 onCreate와 같이 실행됨.
	첫 화면 하나를 띄우기 위해서 위 콜백함수 3개가 먼저 호출된다.
	앱을 실행시켰다가 다른화면으로 갔을 때는 onPause() 상태임
		이 상태에서 다시 앱으로 돌아가면 다시 onResume()가 실행되고 그래서 다시 화면이 나타남.
	일렬 라인 여섯개가 제일 중요함.
	이 흐름을 알면 필요한 곳에 원하는 코드를 넣을 수 있다.

---예시 앱 프로젝트 작성 : LifeCycle
	MainActivity.java에서 
	제너레이트 > 오버라이드 메소드에 가면 바로 위의 부모(AppCompatActivity), 부모의 부모의 부모...(FragmentActivity, ComponentActivity, ...) 가 가지고 있는 함수들을 볼 수 있다.
----------
public class MainActivity extends AppCompatActivity {

    // 눈에는 onCreate()만 보이지만,
    // 실제로는 onCreate()실행 > onStart()실행 > onResume() 순서대로 실행을 시킨다.
    // 누가? 안드로이드가 시킨다.

    // 1. 기본으로 생성되어있는 onCreate() 함수
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Log.i("MyLife","1. onCreate() 함수 호출");
    }

    // 2. 마우스 우클릭 > Generate... > Override Methods... > onStart() 함수 오버라이딩
    @Override
    protected void onStart() {
        super.onStart();
        Log.i("MyLife","2. onStart() 함수 호출");
    }
}
----------
매니페스트 > 액티비티 태그 > .MainActivity

.MainActivity에 있는 .은 기본패키지의 경로이다.
여기에서 .메인액티비티 이름 바꿔주면 그 이름의 자바파일이 첫 화면에서 실행된다.

화면이 넘어가면 기존 화면 작업이 onPause와 onStop이 실행되는 이유
	메인액티비티가 "뒤로 빠지면서" 세컨드가 뜨기 때문에 메인액티비티 기준에서는 onPause와 onStop이 뜨는 것이다.

onPause안에 추가할 수 있는 작업 예시
	화면이 넘어갈 때 그 전에 있는 정보를 지우고 싶을 때
	다른 화면으로 넘어가기 전에 지금까지 한 거 저장해야 할 때

내용 초기화는 앱을 잠시 나갈 때보다(onPause) 돌아올 때(onResume) 해 주는 것이 좋다.

잘 사용하는 콜백함수
	onCreate 앱 실행
	onResume 앱 화면 재실행할 때
	onPause 이 화면 위에 다른 화면을 덮어쓰는 작업을 할 때 
	onDestroy 앱을 "종료"시킬 때
		기본 셋팅에서는 종료 후 다시 onCreate하면 초기화됨.

---자체 정리---

(1) onCreate() > (2) onStart() > (3) onResume()
 > (4) onPause() > (5) onStop() > (6) onDestroy()
 
순환 순서
1. 앱 버튼 눌러서 실행
	(1) > (2) > (3)
2. Back버튼을 눌러 홈 화면으로 갔을 때
	(4) > (5) > (6)
3. Back버튼을 눌렀다가 다시 앱으로 돌아왔을 때
	(1) > (2) > (3)
4. 해당 화면 기준 화면 전환시
	(4) > (5)
5. 홈버튼, 메뉴 버튼을 눌러 홈 화면으로 갔을 때
	(4) > (5)
6. 화면 전환했다가(4. & 5.) 다시 돌아왔을 때
	(2) > (3)

----------

금요일 시험은 데이터베이스 테이블 "설계" 시험
	이번 평가는 손으로 푸는 거 + 포트폴리오식 문제. spl 작성해서 파일 보내주는 방식.
	셀렉트 업데이트.

---전에 만든 Quiz 앱으로 이동
화면을 가로세로로 바꿀 때 입력 정보가 초기화되는 것 막기
	화면을 돌리면 456123 순서대로 다시 돌아간다.
		아무 셋팅도 안하면 회전했을 때 정보가 초기화되는 이유가 6을 거치기 때문임.
------★★★★★★★★★★
onCreate 점수 0점
onStart
onResume
점수 3점
화면 가로로
onPause
onStop
onDestroy
onCreate 점수 0점
// 기본 셋팅은 디스트로이 이후 크리에이트하면 MainActivity를 처음부터 다시 실행시킴.
onStart
onResume
------★★★★★★★★★★
onPause할 때 정보를 저장하고 있으면 다시 onCreate해도 onPause에서 저장했던 정보들이 다시 나온다.

★★★화면 전환했다가 다시 돌아올 때 특정 정보를 저장해주는 함수
onCreate 밑(밖)에 작성(멤버함수)

Protected void onSaveInstanceState(@NonNull Bundle outState) {
super.onSaveInstanceState(outState);

// 이 아래에 화면이 전환되었다가 돌아와도 저장하고싶은 정보를 입력
// "SCORE"라는 ★키★로, score 멤버변수에 저장된 현재 스코어를 저장.
outState.putInt("SCORE", score) // 정수를 저장하라

// 문제의 인덱스 숫자도 저장
outState.putInt("INDEX", questionIndex); }
Log.i("MyQuiz", "onSaveInstanceState 호출됨.");


=============위에거 취합한 코드
    @Override
    protected void onSaveInstanceState(@NonNull Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putInt("SCORE", score);
        outState.putInt("INDEX", questionIndex);
    }
==============================

이거까지만 하면 안되고 저장한 걸 불러오는 건 따로임.
불러오려면 onCreate의 처음 시작 부분에서 불러온다.

        if(savedInstanceState != null){
            score = savedInstanceState.getInt("SCORE");
            questionIndex = savedInstanceState.getInt("INDEX");
        }else{
            score = 0;
            questionIndex = 0;
        }
=================================

★★★★★★★★★★위에 테스트해보면서 익히기

★★★★★★★★★★
왜 위에 함수를 온파우즈에 넣지 않는가
온 크릿이 다시 호출되면(액티비티) 정보가 초기화된다.
온크릿이 다시 호출되는 경로는 앱을 제일 처음 켤 때나
아니면 디스트로이 이후이다.
즉 온파우즈와 온크리에이트는 실행순서로서는 연관이 있더라도
온크리에트가 실행되는 것은 온디스트로이(앱 종료) 이후이기 때문에
종료 이후 크리에이트하게 되면 파우즈에 뭘 저장해놔도 소용이 없다.
	그러므로 온 크리에이트 안에 저장해놓은 정보를 불러주는 함수를 메인액티비티의 멤버함수로 적어놓고 써먹어야 하는 것이다.
또 온크리에이트와 연결되어 온크리에이트에서 불러올 수 있는 정보를 저장해주는 함수가 따로 있기 때문에 이 상황(화면회전)에서는 굳이 따로 온파우즈에 정보를 저장하는 함수를 추가하지 않는다.
onPause와 간접적으로 연결된 것은 onResume이다.
★★★★★★★★★★

온디스트로이가 호출되는 경우 두가지
	finish()
	기기 회전
	
------------
InstanceState
	onSave는 "onSave"InstanceState(여기1)함수에서 쓰고, saved는 Create(여기2) 안에 있다.
		여기1 = @NonNull Bundle "out"State
		여기2 = Bundle "saved"InstanceState

큰 흐름이 중요★

===============라이프사이클 코드복붙

import androidx.appcompat.app.AppCompatActivity;

import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;

public class MainActivity extends AppCompatActivity {

    // 눈에는 onCreate()만 보이지만,
    // 실제로는 onCreate()실행 > onStart()실행 > onResume() 순서대로 실행을 시킨다.
    // 누가? 안드로이드가 시킨다.

    Button btn;

    // 1. 기본으로 생성되어있는 onCreate() 함수
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Log.i("MyLife","1. onCreate() 함수 호출");

        // 연결고리 작성(버튼 변수 초기화)
        btn = findViewById(R.id.btn);

        // 버튼은 onCreate()에서 실행~~~
        // 버튼을 눌러 second_activity.xml 로 이동하기
        btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                // 다른 액티비티로 화면 전환하는 제일 간단한 코드
                Intent i = new Intent(MainActivity.this, SecondActivity.class);
                startActivity(i);
                    // 여기까지만 쓰고 실행해서 버튼 누르면 화면 안 넘어가고 강종됨.
                    // 하단의 Run 클릭해서 오류내용을 보면서 디버깅하기.
                    // 매니페스트에 가서 액션 태그를 써서 SecondActivity 화면을 등록해준다.
            }
        });

    }

    // 2. lifecycle 을 눈으로 확인하기 위해 모든 함수를 오버라이딩하고 로그 입력하기
    // 2-1. 마우스 우클릭 > Generate... > Override Methods... > onStart() 함수 오버라이딩
    @Override
    protected void onStart() {
        super.onStart();
        Log.i("MyLife","2. onStart() 함수 호출");
    }

    // 2-2. onResume 검색해서 오버라이딩
    @Override
    protected void onResume() {
        super.onResume();
        Log.i("MyLife","3. onResume() 함수 호출");
    }

    // 2-3. ...
    @Override
    protected void onPause() {
        super.onPause();
        Log.i("MyLife","4. onPause() 함수 호출");
    }

    @Override
    protected void onStop() {
        super.onStop();
        Log.i("MyLife","5. onStop() 함수 호출");
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        Log.i("MyLife","6. onDestroy() 함수 호출");
    }
}
================================
매니패스트 복붙
    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity android:name=".SecondActivity" /> // 두번째 화면 추가하는 방법.
    </application>
	
	=================================

세컨드 자바복붙

import android.os.Bundle;

import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;

public class SecondActivity extends AppCompatActivity {

    // onCreate 입력해서 MainActivity 와 같은 onCreate() 만들어주기
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.second_activity);



    }
}

===============================

액티비티메인 xml 복붙
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <TextView
        android:id="@+id/textView2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello World!"
        android:textSize="32sp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

    <Button
        android:id="@+id/btn"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Button"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintHorizontal_bias="0.498"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/textView2"
        app:layout_constraintVertical_bias="0.064" />

</androidx.constraintlayout.widget.ConstraintLayout>

=============================

세컨드액티비티 xml 복붙

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/textView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Second"
        android:textSize="32sp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
</androidx.constraintlayout.widget.ConstraintLayout>

================================

깃헙실습앱03

================================
가사는 데이터에 없고 네트워크를 통해 가져오는 실습
+스크롤뷰

일반 텍스트뷰는 자동으로 스크롤 처리가 안 된다.

컨센트레이트 레이아웃에서 자식 레이아웃을 양쪽 다 매치페어런트로 전체화면으로 쓰고 싶다면 가로세로 길이를 0으로 맞춰놓는다.

네트워크 연결 라이브러리
android volley

api 호출하기

lyrics.ovh

가사 API 호출하기 위해 접속하기
이거 검색
lyrics.ovh api
200610 수요일 수업 내용 메모

=====================================
관련 프로젝트 : Lyrics, Parsing
=====================================

API
	Appication Programming Interface

	상대방이 어플리케이션을 만들 수 있도록 데이터를 가공해서 제공해주는 거
	
	애플리케이션 <=> API <=> 백엔드 서버
	(앱 개발자) (JSON & XML) (API 게이트웨이 서버)
 
	애플리케이션
		API를 활용해 만들어진 다양한 프로그램 결과물
		안드로이드도 API이다
	백엔드 서버 (★★★★★아래 설명 중요★★★★★)
		가져올 데이터가 저장되어있는 서버
		API는 여기에 저장된 데이터를 호출 URL로 불러낸다.
		서버는 JSON 형식으로 해당되는 데이터를 돌려주고
		API는 그걸 다시 API를 호출했던 애플리케이션으로 돌려준다
	★API 설명 페이지에 적혀있는 사용 방법대로 사용하면 됨.
	데이터를 가지고 있는 서버에서 앱을 만들 수 있도록 가운데에서 제공해주는 거
	API 주소
		API는 갖다 쓰려면 요청 URL이 있어야 한다.
		(request URL)
		 ex) GET https://api.lyrics.ovh/v1/artist/title
		인증받고 써야한다.
		사용하려면 항상 인증 키(API키)를 받아야 한다.
		아무나 쓰게 하면 서버 과부하돼서.
	open api
		실시간 정보 요청
		파일 데이터 API를 가져다 쓰는 것과 다름.
	API 호출/응답
		응답은 response
		API를 호출하려면 API URL이 있어야 한다.
		웹브라우저가 요청하는 URL과 형식이 같다.
			API URL 테스트할 때 웹브라우저에서 접속해보는 식으로 테스트할 수 있다.
		api.lyrics.ovh/v1/~/~ 입력하는 게 "API 호출"
	요청 변수 (request parameter)
		= 파라미터
		입력 파라미터(앱에서 주는 거)
			필수값, 옵션값 있음
		출력 파라미터(API에서 주는 거)

JSON
	자바스크립트의 객체 표기법
		JavaScript Object Notation
	API를 가져올 때 API의 데이터 형식
		애플리케이션과 API가 주고 받는 것 전부 JSON으로 한다
	API 파일양식
		xml도 쓸 수 있는데 xml보다 편함
	★★★★★JSON 형식★★★★★
		{ " " : [ ] , { } }
			{ } : JSON Object - '키 : 밸류'로 이루어짐
			[ ] : 제이슨 어레이 JSON Array
		백엔드 서버는 JSON 형식으로 데이터를 돌려준다.
	★★★★★★★★★★★★★★★

	네트워크 코딩은 JSON을 잘 다루면 잘 하는 거.
	
래퍼런스
	사용 정보 명시

API 이용하기
	네트워크를 이용해서 API와 데이터 자료를 주고받는 방법
	API 호출 횟수가 일정 이상 되면 돈을 받는 곳이 많다.
	오픈 API는 웹 프로토콜로 쓸 수 있다.
	안드로이드에서 웹 프로토콜(http)을 쓰려면 HTTP라이브러리를 사용한다.
		제일 많이 쓰는 안드로이드 라이브러리는 Volley
		안드로이드 앱 네트워킹통신을 가능하게 해주는 HTTP(웹 프로토콜) 라이브러리이다

btnApi
	api를 호출하는 버튼

리퀘스트 URL을 변수로 가져오기
	다른 함수에서도 사용할 수 있으니까 멤버변수로 만들기
	ex) String requestUrl = "https://api.lyrics.ovh/v1/";
		요청 URL은 안 변하고 요청 파라미터만 변함.

문자열 붙이기 겁내쉬운 방법 예시 in String
	String url = requestUrl + artist + "/" + song;

Volley를 사용해 api를 요청하는 코드 작성하기
	RequestQueue requestQueue = Volley.newRequestQueue(MainActivity.this);
	JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(Request.Method.GET,
			url, null, new Response.Listener<JSONObject>() {
		@Override
		public void onResponse(JSONObject response) {

		}
	}, new Response.ErrorListener() {
		@Override
		public void onErrorResponse(VolleyError error) {
			
		}
	});
	★★★★★ Request.Method.GET
		GET  =>  ""GET"으로 호출" 
		HTTP 메소드 방식을 말함. 호출할 API 사이트에서 GET으로 보내라고 명시되어 있었기 때문에 GET이라고 쓴 거임.
		이 . 뒤에는 추가할 주소(변수)를 입력함. 데이터 실어서 보낼 것은 없으므로 그 . 뒤에는(json request) 요청할 때 보낼 json은 없으므로 null이라고 쓴다.

http 프로토콜 방식
	http 프로토콜 메소드
		API 호출할 때 안드로이드에서 자주 쓰는 메소드
			GET
				요청해서 응답 받아올 때 사용하는 메소드
				조회만 할 때는 GET을 쓴다.
			POST
				??? 사진 가져올 때??? 설명 제대로 못들음
			DELETE, PUT을 사용하기도 함.
			
	위키피디아 검색해서 설명 참고

안드로이드 프로그래밍은
어떤 함수 안에 내가 원하는 코드를 작성할지가 중요!!

SecurityException: Permission denied (missing INTERNET permission?)
	이게 뜨면??
	해결법
		app > manifest.xml > 여기에 인터넷 권한을 준다.
		<uses-permission android:name="android.permission.INTERNET" />
		매니페스트 태그 아래에 여거 추가해주면 됨.
		여기서 호출 안 되면 보통 안드로이드 스튜디오 업데이트 문제임..
		해결함~~~~~~~~~~~~~~~~~~

파싱 parsing
	부분부분 뜯어내기. 분리하기
	json에서 콤마로 분리된 데이터들 중 필요한 데이터만 뽑아서 가져오는 행동을 말한다.
	가져오고 싶은 밸류(값)는 키값으로 찾는다.

★★★★★json에서 파싱하는 코드★★★★★
	int userId = response.getInt("userId");
	int id = response.getInt("id");
	String title = response.getString("title");
	boolean completed = response.getBoolean("completed");
	파싱할 데이터의 데이터 타입으로 변수을 선언한다.
	초기화할 땐 response.get~();의 형태로 쓴다.
★★★★★★★★★★★★★★★★★★★★

response.toString()
	백엔드 서버가 돌려주는 값을 String 타입으로 받는다

response.getString("키값")
response.getInt("키값")

error.toString()

========================================
타이머 기능
관련 앱 : FingerSpeed

color.xml
	colorPrimaryDark : 보조색
		최상단 상태 바 컬러
	colorPrimary : 주색
		액션 바 컬러
	colorAccent : 강조색

===== CountDownTimer 클래스

Public constructors : 생성자

이 클래스의 생성자
	CountDownTimer(long millisInFuture, long countDownInterval)
		millisInFuture 몇 초 타이머로 만들 거냐
			밀리세컨 단위라서 60000을 써야 60초가 됨
		countDownInterval 몇초씩 줄일 거냐
			얘도 밀리세컨 단위. 1000이 1초.

counDownTimer.start();
	카운트다운을 실행하는 함수

onTick(long millisUntilFinished)
	적힌 숫자만큼 시간이 지나면 이 함수 실행

onFinish()
	타이머가 끝나면 이 함수 실행

========================================


★ 로직 짜기 겁내 중요

인스타그램 클래스 설계하는 거에서 시험냄

지도 정보는 구글 API를 많이 쓴다.

네이버 API 설명화면 찾기200610 수요일 수업 내용 정리



API
	Appication Programming Interface
		Appication : API를 활용해 만들어진 다양한 프로그램 결과물
	앱 개발을 위해 백엔드 서버 데이터를 필요로 할 때 중간에서 데이터를 가공해 제공해주는 것
	데이터 서버를 제공하는 페이지에 적혀있는 API 사용 방법(레퍼런스)대로 사용하면 된다.



오픈 API (Open API)
	서버의 데이터(플랫폼의 기능 및 컨텐츠)를 외부에서 쓸 수 있도록 웹 프로토콜(HTTP)의 형식으로 호출할 수 있는 개방된 API
	파일 데이터을 받아서 API를 가져다 쓰는 것과 다르다.



Appication
	API를 활용해 만들어진 다양한 프로그램 결과물
		웹, 모바일 웹, 모바일 앱 등등
	안드로이드도 API이다



백엔드 서버
	개발자가 요청한 데이터, API가 가져올 데이터가 저장되어있는 서버



애플리케이션, API, 백엔드 서버의 관계
	-----------------------------
	애플리케이션 <=> API <=> 백엔드 서버
	(앱 개발자) (JSON & XML) (API 게이트웨이 서버)
	-----------------------------
	개발자가 호출 URL을 실행하면 API는 백엔드 서버에서 개발자가 요구하는 자료를 가져온다.
	백엔드 서버는 요청받은 자료를 JSON 코드로 API에게 돌려주고, API도 역시 받은 데이터를 개발자에게 보내준다.



요청 URL (Request URL)로 API를 호출한다
	오픈 "API를 호출"하기 위해서는 API의 웹 주소(URL)가 필요하다.
	인증을 받아야(인증 키를 받아야) 사용할 수 있는 오픈 API들도 있다.
	ex) api.lyrics.ovh/v1/~/~
		웹 브라우저에 이 URL로 직접 접속해서 요청 URL이 정확한지를 테스트해볼 수 있다.



변수 = 파라미터



요청 변수 (Request Parameter)
	= 입력 파라미터
	필수로 입력해야 하는 필수값, 추가해도 안해도 되는 옵션값이 있음.
	개발자가 요청하는 값



응답 변수
	= 출력 파라미터
	API에서 돌려주는 값



JSON
	자바스크립트의 객체 표기법
	JavaScript Object Notation
	요청값을 받을 때 받는 데이터의 작성 방식중 하나이다.
	
200611 목요일 수업 내용 메모

34. 실습문제 하기

// FingerSpeed 프로젝트에서 중요한 정보 뽑아내기

변수 하나로 다른 변수들도 초기화시키는 방법
	final static int TAB_COUNT = 10;
	상수 만들기(상수 변수 선언)
	보통 상수는 멤버변수의 가장 위쪽에 만든다.

TextView도 setOnClickListener를 만들 수 있다.



--- 시험 관련
02 OS DB > 맨 아래에 데이터 입출력 시험범위 파일 있음.
이거 참고하기
15~22 사이에서 나옴.
데이터는 제공.
변별력 위해서 변형 문제 있음.
2번째 시간부터 시험 봄.200611 목요일 수업 내용 정리
200612 금요일 수업 내용 메모 정리



<화면 전환/데이터 넘기기&받아오기> - Intent 클래스
관련 프로젝트 : ShowGuess / SignUp

=====  전환하기/저장하기  =====

1. 보낼(전환 전) 액티비티에서 Intent 선언하기
	Intent 변수 = new Intent(이 클래스.this, 전환할 클래스.class);
	
2. 데이터 보내기(저장하기) - putExtra
	보낼 거 없으면 필수 아님
	변수.putExtra("키", 밸류);
		키 : 아이디, 불러올 때 쓰는 거
		밸류 : 보낼 값(변수 등)

3. 화면 전환 하기
	startActivity(변수);
		변수 i의 정보를 받아서 새 액티비티의 인스턴스를 시작한다.

=====  저장한 데이터 가져오기  =====

1. 데이터 가져오기 - getExtra
	[ 선행 ] ★각각 다른 함수 안에서 쓸 거면 일단 멤버변수로 선언
	1-1. 데이터타입 변수 = getIntent().get데이터타입Extra("키", 디폴트값)
		데이터타입 : 가져올 값의 데이터 타입
		디폴트값 : 아무 값도 지정하지 않았을 때 기본 값(null값)
			* String 타입은 디폴트값이 필요없다
	1-2. 여러개의 데이터를 가져올 때 효율적인 방법
		1) Intent 변수1 = getIntent();
		2) 데이터타입 변수 = 변수1.get데이터타입Extra("키", 디폴트값)
	

* Intent로 데이터를 주고받는 것은 화면 전환하는 쌍방간에만 가능하다. 건너건너 주려면 중간에서 getExtra로 데이터를 불러온 다음 그걸 또 다음 액티비티로 넘어갈 때 putExtra로 넘겨줘야 한다.

==============================



=====  버튼 클릭시 코딩 효율적으로 하기  =====

1. public class ~~ 맨 뒤에 implements View.OnClickListener 적기
적으면 빨간줄 뜨면서 onClick() 만들 거냐고 나오는데 그거 누르면 알아서 onClick()멤버메소드 만들어줌

2. 버튼변수.setOnClickListener(this);

3. onClick(View v) {여기} 안에
	if(v == 버튼변수){
		이 버튼 누르면 할 거
	}else if(v == 버튼변수2){
		버튼변수2 누르면 할 거
	}...이런 식으로 만들어주면 됨
		v에 버튼 이름이 들어가게 됨

View v에 버튼 변수가 어떻게 들어가게 되는지 과정이 궁금..

===================================



< 카운트다운 타이머 만들기 > - CountDownTimer
관련 프로젝트 : FingerSpeed / StartEndAlarm



==============================

앞뒤 공백을 잘라주는 함수 - .trim()
	이럴 때 사용함 : 문자열 비교할 때 공백도 항상 포함되므로, 앞뒤 공백이 있으면 문자열 처리가 제대로 안 될 수 있다.

on~ 함수가 있으면 "액티비티" 자바 파일이다.

==============================



=====  기타 정보  =====

깃헙 설명
	회사에서는 깃헙 씀
	소스코드 관리 편하게 할 수 있도록 만들어진 사이트
	pull가져오고 push다시 올리고

====================200612 금요일 수업 내용 메모

StartEndAlarm 만들기200615 월요일 수업 내용 메모

★액티비티간 화면 전환, 액티비티간 데이터 교환★

1. 첫번째 액티비티에서 두번째로 데이터 전달

2. 두번째 액티비티에서 첫번째로 데이터 전달
> 일단 첫번째로부터 받은 문자열은 TextView에 표시할 것임
> 두번째 액티비티는 데이터를 보낸 후 종료된다

3, 첫번째 EditText에 두번째 액티비티에서 보낸 텍스트가 표시됨

==========설명===========

Vv 매니페스트에 두번째 액티비티가 등록되어있는지 확인하기

Vv btnSend.setOnClickListener(new View.OnClickListener()); 외우기

Vv EditText에서 String으로 문자열을 가져올 땐 trim()을 꼭 해준다.

Vv Intent i = new Intent(MainActivity.this, SecondActivity.class);
액티비티 순서 바뀌면 안됨

Vv ★★★★★★★★★★★★★★★★★★★★★★★★★
startActivity(i);
★★★★★
두번째 액티비티가 실행된다 = 두번째 액티비티가 이 화면 ★★★위로 올라온다★★★는 뜻
새로운 액티비티를 내 위에 실행하라
Vv ★★★★★

두번째가 세번째 액티비티를 부르면 두번째 위에 또 겹친다.
액티비티 하나씩 불러올 때마다 종이 한장씩을 위에 겹쳐 올리는 거라고 생각하면 될 듯.

Back버튼은 쌓인 종이를 한 장씩 빼는 거.
Back버튼의 효과 > finish();효과랑 같음 (메모리에서 없어짐)
	피니시할 때만 메모리에서 없어짐
★★★★★★★★★★★★★★★★★★★★★★★★★

화면을 전환/데이터를 주면서 동시에 나중에 받으려고 할 때 쓰는 함수
[주는 액티비티] startActivityForResult(i, 0);

[받는 액티비티]-------------------
// 일단 Intent 에서 데이터를 가져올 거라고 선언함
Intent i = getIntent();
// 키값들을 가져옴
String data = i.getStringExtra("data");
int hiddenData = i.getIntExtra("hiddenData", 0);
// 받은 데이터를 txtData 에 표시
txtData.setText(data);
보낸 액티비티에서 보낼 때 적은 키값을 그대로 써야한다.

// 버튼 누르면 다시 첫번째 액티비티로 보내기
// 데이터를 보내기  위해 에디트 텍스트에서 문자를 가져온다.
String data = editSend.getText().toString().trim();
// 앞 액티비티로 데이터를 전달하고
i = getIntent(); // 새 Intent 를 만드는 게 아니라, 이전 액티비티에서 가져온다
i.putExtra("secondData", data); // 일단 보냄
setResult(RESULT_OK, i); // resultCode 보내기 + 데이터를 보내줬던 액티비티로 화면을 다시 돌려보낸다(다시 돌아가라)
finish(); // 액티비티 종료
------------------------------

[처음에 줬던 액티비티] onActivityResult()
콜백함수 이 함수가 실행되는 때는
두번째 액티비티가 피니시되면서 setResult(RESULT_OK, i)했을 때
그걸 받아오는 기능을 하는 함수

===========================================

데이터를 저장하는 방식
	메모리와 저장소의 차이
	메모리는 휘발성
		메모리에다 저장하는 것은 앱을 끄면 사라지는 휘발성 데이터
	저장소의 파일, 쉐어드 프리퍼런스, 디비는 비휘발성
		Saving Data on Device
		저장소는 안드로이드 폰(자신의 기기) 안에 저장한 데이터들을 말함
		1) 텍스트 파일 > 안드에서는 쓸데없음. 사용안함.
		2) 쉐어드 프리퍼런스
			간단한 데이터를 저장할 때 사용
		3) 디비 는 나중에 배움

쉐어드 프리퍼런스 실습(프로젝트 이름 : SP)
---
자동 로그인 기능을 구현할 때 주로 쓰이는 기능
---
메세지를 입력하고 버튼을 누르면 메세지를 (기기에) 저장함
앱을 껐다가 다시 켜면 텍스트뷰에 저장했던 메세지를 띄움
---
★★★★★중요한 개념★★★★★
쉐어드 프리퍼런스는 "앱 영역"에 저장한다. 앱이 살아있으면 데이터가 남아있지만, 앱을 삭제하면 쉐어드 프리퍼런스도 다 삭제해버려서 남아있지 않게 된다. 업그레이드는 상관없다.
★★★★★★★★★★★★★★★
선언하기
SharedPreferences sp = getSharedPreferences("프리퍼런스", MODE_PRIVATE);
	프리퍼런스 : 프리퍼런스 이름을 정해준다. 폴더명이라고 생각하면 됨.

equals 대소문자 가림
equalsIgnores?? 대소문자 안가림

- 값 덮어쓰기 가능? 가능. 각각 저장하려면 다른 키이름으로 저장해야 한다.
- 프리퍼런스를 두개를 만드는 거는 잘 사용하지 않는다. 하나만 만들어서 거기에 각각 다른 값을 써도 되니까는.
- 쉐어드 프리퍼런스는 일단 어디선가 선언/초기화만 해 놓으면 (저장 공간을 만들어놓으면) 다른 액티비티에서도 그냥 가져다 쓸 수 있다. 다른 데서는 그냥 만들어놓은 프리퍼런스에 새 데이터를 저장하거나 불러오기만 하면 된다.

-----------------------

쉐어드 프리퍼런스를 활용한
로그인 화면 및 기능 개발 구현 실습

회원 가입이 완료되면 쉐어드프리퍼런스에 아이디와 비밀번호 값을 저장

앱을 다시 켜고 로그인 버튼을 눌러서 로그인했을 때
이 아이디와 비밀번호가 맞으면 맞다는 토스트창을 띄우면서 환영합니다 ***님이 뜨는 액티비티로 화면을 전환하고,
다르면 다르다는 토스트 띄우기

새로 만들어야 하는 액티비티 2개
로그인 화면+로그인 화면으로 연결되는 버튼 / 로그인 성공시 화면

-----------------------

===============================================
===============================================
깃헙 38. 요구사항 확인 - 이번주 금욜 테스트(종이테스트)
문제는 이 파워포인트에서 다 나옴
외우라고........

현행 시스템 파악의 정의
	현행 시스템이 어떻게 구성되어있는지 파악하는 것
현행 시스템 파악의 목적
	우리 회사는 이렇게 돌아간다. 서버 접속은 이르케 해라.
	를 알기 위해서?
현행 시스템 파악 절차 3단계
	1. 구성(현행 시스템의 구조), 기능, 인터페이스(API)
		기간업무(유저용 앱 만들기) / 지원업무(백오피스)
		백오피스 : 관리자(운영자) 페이지, 관리자 시스템
			기업에서 서비스를 제공하면서 얻는 모든 데이터들을 관리(처리)하는, 서비스를 운영하는 사람들이 보면서 관리해야하는 데 필요한 시스템
		기능은 문서로 다 작성되어있다.
		인터페이스 : 시스템과 시스템 사이의 연결고리
			연계 유형 : 버튼 클릭하면 연결...? "-"
			주기 : 얼마만에 한 번씩 자료를 받을 거냐
	2. 소프트웨어 이름들(서버에 쓰는 랭귀지, 프레임워크에 쓰는 랭귀지가 무엇인지 등) 파악
	3. 각 서버마다 IP가 무엇으로 되어있는가

===현행 시스템의 구조(유저용)===
앱/웹 > API > DB
API(어플리케이션 프로그래밍 인터페이스)의 구성
	웹서버와 프레임워크(다룰 줄 아는 서버의 언어)가 들어있음
// 물리적으로는 API 서버는 여러개(but 클라우드 서비스 이용)
DB 역시 클라우드 서비스 이용.
====================

12페이지 : 현행 시스템 아키텍처 구성도의 정의 << 시험에 나옴
	WAS 웹 어플리케이션 서비스
====================
14페이지 : 하드웨어 구성도 시험에 나옴.

은행권은 오픈소스 잘 사용 안한다. 비싼 돈주고 상용 소프트웨어 사용한다.

15페이지 : 이중화 : 똑같은 하드웨어를 하나 더 놓는 것. 하나만 놨을 때 그게 고장나면 서비스를 못 하게 되므로. 거의 모든 기업이 이렇게 쓴다.
========
16페이지 : 방화벽 : 무슨 포트의 무슨 아이피만 들어올 수 있도록 만드는 것

	L4"스위치" : 접속 트래픽 분산 / 죽은 서버 감지해서 나눠서 분산
	왠만한 기업은 다 이렇게 되어있음
	aws에서 제공해줌
		이용량이 늘어나면 자동으로 웹서버 복붙해서 증가도 시켜줌.

	디스크 어레이 : 이미지 파일 등이 들어감(DB아님, 서버아님)
========
18페이지 : 이런 거 볼 줄 알아야 함.
=======
22페이지 : 시험에 나옴
	유닉스 : 대기업에서 사용함. 비쌈. 대용량 처리는 유닉스.
========
23페이지 : JDK 안에 JVM이 있음. 운영체제별 JVM이 있음.
=====
24페이지 : 운영체제 선택시 고려해야 할 사항
	신뢰도/성능/기술지원/주변기기/구축비용
		오픈소스는 기술지원이 안됨. 안되니까 궁금한 기능이 있으면 뭔지 직접 찾아봐야 하는 것임.
========
25~26페이지 : (가)(나)(다)(라)시험 반드시 나옴
	(다) 유닉스는 문제 생기면 바로 와서 처리해줌.
	(라) 운영체제 bit 따라서 돌아갈 수 있는 램에는 한계가 있다.
	(마) CPU방식이 리스크면 유닉스 깔아야한다.
	(사) ARM칩은 스마트폰이나 태블릿에 거의 다 들어있다.
		ARM : 칩 설계 회사이름
========

시스템 구성은 어떻게 하느냐.
	1. 서비스(유저용)를 만들고 싶을 때 가장 먼저 기획서가 있어야 한다.
		서비스의 화면 기획서와 기능 설명 기획서가 필요하다.
			일반 서비스(유저용) 기획서, 백오피스 기획서가 필요하다.
				제휴시에는 백오피스 꼭 필요.
			그래야 개발할 수 있다.
	2. 내부 개발자 뽑기/외주 주기
		개발하다보면 기획 내용은 항상 바뀐다.
		개발자와 커뮤니케이션이 잘 되어야 한다.
		외주를 줄 때는 일단 기획서 내용을 전부 다 보내는 게 아니고 요약해서 보낸다. 그럼 대략적인 견적을 들을 수 있다.
			외주 계약시 기획서와 클라우드 접속 계정(관리자 계정 - 루트 계정 아님)을 준다
				aws 할 줄 아는 곳에 줘야한다.
			납품받은 다음에 루트계정 들어와서 외주 줄 때 줬던 계정을 싹 지우면 된다.
				.pem 파일 접속도 막아야 한다. 방법 2가지
					1) SSL : 이 파일이 있는 컴퓨터 중에 인증된 컴퓨터만 접속할 수 있도록 해주는 시스템이다.
					2) 22번 포트 앞의 아이피만 접속할 수 있도록 바꿔서 막을 수도 있다.
					3) 방법은 여러가지.
	3. 시스템은 클라우드에 만든다.
		외주 쪽에서 자기 서버 제공해드리고 싸게 해준다고 하는 곳과는 계약하면 안된다.

tmi 실무에서는 경력 3년차 이상부터 하는 일임.
유저용 기획 다 하면 백오피스 기획한다.
	기획서 없이 작업하면(외주 주면) 망한다.
그 다음에 서비스 오픈한다.
시스템 구성을 알아야 외주를 주더라도 계약서를 쓰고 나서 피해를 보지 않는다(아이디어를 뺏기거나 하지 않는다).200615 월요일 수업 내용 정리

백귀야행 새 책 나왔는지 검색
들어갈 때 내일 갖다먹을 컵라면 구입
MBTI검사

새 액티비티를 만들었을 때 AndriodManifest.xml에 잘 등록되어있는지 체크하고 등록 안 되어있으면 등록하기
	ex) <activity android:name=".SecondActivity"></activity>

버튼 클릭시 실행되는 함수 외우기(활용법 ㄴㄴ)
	버튼변수.setOnClickListener(new View.OnClickListener(){
		@Override
		public void onClick(View v){
		}
	});

EditText에서 String으로 문자열을 가져올 땐 trim()을 꼭 해준다.

새 Indent를 만들 때 적는 두 가지 액티비티의 순서가 바뀌면 안된다.
	ex) Intent i = new Intent(액티비티1.this, 액티비티2.class);
		액티비티1 = 현재 액티비티 이름
		액티비티2 = 데이터를 보낼/전환할 액티비티

startActivity(i);
	★★★ 연결한 액티비티가 실행된다 = 연결된 액티비티가 이 화면 위로 올라온다

200616 화요일 수업 내용 메모

체크박스 체크/언체크시 행동 만들기

실제로 아이디 비번은 DB에 저장하고,
아이디 비번이 맞는지는 서버가 체크한다.

안드로이드 내장 DB 사용법(SQLite)
	안드로이드에서 SQLite는 기본적으로 깔려있다.

SQLite
	쉐어드 프리퍼런스 외에 폰에 데이터를 저장하는 또다른 방법.
	네트워크 통신하지 않음.
---관련 프로젝트 : ContactManager
테이블을 만들어 저장해서 폰이 꺼져도 데이터가 살아있게 함

SQLite를 이용하기 위한 템플릿(셋팅방법)
+ 자바로 안드로이드의 SQLite 다루기
	// 서버는 java로 안 다룰 거니까 아래 거는 앞으로 안 씀.
		// 거의 모든 앱이 폰 안에 저장하지 않고 네트워크 DB에 저장해서 불러오기 때문 + a
		// 앞으로는 node.js 쓸 건데 이 문법이 java보다 더 쉬움.
1. java의 메인 액티비티가 있는 패키지 안에 새 패키지 4개 만들기
	 data
	 model
	 ui
	 util
2. model 안에 java class 파일(Contact) 만들기
	데이터를 저장하는 클래스
	클래스 만드는 거니께 첫문자는 대문자~
3. 3가지 멤버변수 주기
	id/name/phoneNumber
	이 작업 과정이 "모델링" 과정.
	폰넘버로 더하기빼기 할 거 아니니까 폰넘버도 String으로 선언.
4. 생성자 만들기
	그냥 생성자, 세가지 값을 한번에 전부 받는 생성자 두가지 만듦
5. 게터세터 만들기
	세 변수의 게터세터를 모두 만듦.
6. 데이터베이스에 접속해 테이블을 생성(create table)하고 데이터 insert, update, select, delete를 할 수 있는 "클래스"를 만든다.
	DatabaseHandler
		데이터베이스를 다루는 클래스라는 뜻
	6-1. 클래스 이름 옆에 extends SQLiteOpenHelper 적기
		Alt+Enter 두 번 해서
			1)전부 오버라이딩하고
			2)생성자도 불러옴(생성자는 3번째거 - 사진 찍어놓음)
	6-2. 생성자에서 context 뒤를 전부 지우고
			super(context, 테이블이름, null, 데이터베이스버전)으로 바꿔줌
				빨간줄 없으면 다음으로 넘어감
7. util 폴더에 Util 클래스 만들기
	상수 처리하는 클래스
		데이터 간편 처리, 하드코딩을 하지 않기 위한 상수 처리 클래스
		상수 이름은 전부 대문자처리를 하는 것으로 암묵적으로 정해져있다.
	7-1. 데이터베이스 이름과 데이터베이스 버전 상수를 만듦
		ex) public static final String DATABASE_NAME = "contact_db";
			public static final int DATABASE_VERSION = 1;
8. 핸들러 자바로 가서 기존 name, version을 Util에서 만든 상수로 바꿔주기
	ex) super(context, Util.DATABASE_NAME, null, Util.DATABASE_VERSION);
9. Util 가서 TABLE_NAME, 컬럼들도 상수 만들기
	ex) // 테이블 이름 상수
		public static final String TABLE_NAME = "contacts";
		// 컬럼 이름들 상수
		public static final String KEY_ID = "id";
		public static final String KEY_NAME = "name";
		public static final String KEY_PHONE_NUMBER = "phone_number";
10. 핸들러로 가서 onCreate 함수 안에서 테이블 만들기
	// 문자열로 선언 후 쿼리 실행문에 대입하는 방법으로 실행됨
	// 문자열" " 안에 쿼리문을 적는다
	//	SQLite 문법으로 써야한다. (MySQL아님)
		// int -> integer
		// auto_increment -> autoincrement
		// autoincrement primary key -> primary key autoincrement
		// varchar -> text
	// 변수 + 문자열 형식이므로 중간중간 들어가는 띄어쓰기에 유의하자
		ex) String CREATE_CONTACT_TABLE = "create table " + Util.TABLE_NAME + "(" + Util.KEY_ID
			+ " integer not null autoincrement primary key, "
			+ Util.KEY_NAME + " text,"
			+ Util.KEY_PHONE_NUMBER + " text )";
	// 위 String 은 아래에서 작성한 것과 같다
	// create table contacts
	// ( id integer not null primary key autoincrement,
	// name text,
	// phone_number text)
11. 작성한 쿼리 실행시키기 - .execSQL(실행문);
	db.execSQL(변수이름);
		// 변수이름 : 여기서는 CREATE_CONTACT_TABLE
12. onUpgrade 함수에서 테이블을 삭제하고 새로 만드는 작업 해보기
	12-1. String으로 drop table문 만들기
	ex) String DROP_TABLE = "drop table " + Util.TABLE_NAME;
	12-2. drop table문 실행시키기
	ex) db.execSQL(DROP_TABLE);
	12-3. onUpgrade 안에서 onCreate()를 써서 테이블 다시 만들기
	ex) onCreate(db);
13. 데이터베이스에 Contact 클래스를 이용해서 "데이터를 저장하는" "메소드 만들기" (아래 예시)
	// SQL에서 insert의 역할을 하는 함수
	13-1. 주소를 "저장"하기 위해 writable db를 가져온다.
		SQLiteDatabase db = this.getWritableDatabase();
	13-2. db에 저장하기 위해서는 ContentValues 를 이용한다.
		ContentValues values = new ContentValues();
		values.put(Util.KEY_NAME, contact.getName());
		values.put(Util.KEY_PHONE_NUMBER, contact.getPhoneNumber());
	13-3. db에 실제로 저장한다.
		db.insert(Util.TABLE_NAME, null, values);
		db.close(); // insert 하면 항상 close 를 해준다.
14. 주소 1개를 "가져오는" "메소드 만들기"
	// SQL의 select문을 써서 데이터를 조회한다
	// "주소 1개"라는 조건이 있으므로 조건문 select를 만드는 함수이다.
	// select한 값을 보여줘야 하므로 리턴값이 있어야 한다.
		// 리턴값은 Contact 타입으로 해준다 (왜?)
15. ... 정리 필요

---깃헙 41 앱 실습 07 실습해보기---

정보를 저장하고(Contact)/정보를 다룰 도구를 만들고(Util)/데이터베이스를 처리하는 클래스(DatabaseHandler) 가 따로 필요하다


JSON/API 기반의 네트워크 연동/처리 경험 -> Valley

=====요구사항 확인=====
28페이지 : 
	Oracle : 제일비쌈.
	SQLite : 애플 디바이스에서도 씀.
	Redis : 램카드에 저장하는 DB(서버 꺼지면 데이터 다 지워짐)
		서버 끄기 전에 파일에 저장해놨다가 다시 올려놓음.
		장점 : 파일에서 읽지 않기 때문에 속도가 빠름.
		이용처 : 유저 프로파일 이미지 등
29페이지 : 
	기술 지원 : 오픈 소스는 기술 지원이 없어서 스스로 해결해야 함.
	상호 호환성 : MSSQL을 리눅스에서 돌릴 수 없다.
	구축 비용 : 초기에는 저렴하게. 발전할 수록 더 좋은 걸로.
★32페이지 : OLTP
	시험에 나옴. 중요한 내용. IT를 한다고 하면 알고 있어야 하는 사항.
	사용자 수 : 피크타임은 중요하다.
	트랜잭션 : 호출했을 때 응답이 오는 것?(몇 번이나 호출을 했느냐)을 하나의 트랜잭션이라고 한다.
	온라인 업무 : 실시간으로 처리하는 업무
	배치 업무(배치 작업) : 모아서 처리하는 것(오늘 하루동안 발생한 매출의 통계 데이터를 낸다)
★33~34페이지 :
	시험에 나옴
★36페이지 : 
	시험에 나옴
		요구분석사항의 각 설명에 해당하지 않는 것은?
38페이지 : 
	요구사항 명세 : 요구사항 문서
	형상 관리 : 기획 문서가 수정될 때마다 바뀐 근거를 버전별로 반드시 기록을 해 놓아야 한다는 뜻이다.
★41페이지 : 
	핵심 기능을 꼭 정해라(우선순위 정하기).
	기능/비기능 분류
43페이지 : 
	실세계 문제를 해결하기 위한 모델링.
★44페이지 : 
	필수로 쓰는 모델 표기법
		★유즈케이스다이어그램 : 현업에서 많이 씀
		UML : 대부분의 모델 표기법
45페이지 : 
	ex) 외주줄 때 협상
47페이지 : 
	ex) 외주업체가 잘 이해했는지 확인해라.
		그 전에 화면 기획서를 잘 만들어라.
48페이지 : 
	(문서상으로) 여러 사람이 봐야 오류를 잘 찾아낸다.
	테스트할 고객이 1명 이상 있어야 한다.
★50페이지 : 프로토타이핑
	시험나옴(단답형!!!!!!!)
	강사님 요약 : 내가 예상한 것이 실제로 동작하는지 코드로 짜보는 것.(전체 개발에 필요한 부분 중 예상한 '기능'이 가능한지 안되는지 실험해보는 것)
		요새 기업들은 프로토타이핑 방식으로 한다.
	문제가 되는 사항을 미리 발견해서 미리 피드백을 받을 수 있다.
	단점보다 장점이 많다.
53페이지 : 
	우선순위, 유형, 내용 세가지가 제일 중요.
★54~55페이지 : 
	유즈케이스 : "액션(행동)"과 관련된 내용
	흐름 : 개발자의 개발 흐름과 비슷하다.
	예외 흐름 : 관리자 페이지(백오피스)의 필요성이 설명됨
60페이지 : 
	3번 중요.
61페이지 : 
	의존성 중요함. 서비스 유지에 대한 비용 문제임.
	ex) 폰트 라이센스200616 화요일 수업 내용 정리200617 수요일 수업 내용 메모

===============================================
*이 파일 pdf로도 올려져있음.

63페이지 :
	유즈케이스 : 액션 설명
		액터 : 관련된 사람, 관리자, 유저 등
	개념수준 분석 클래스 검증 :
		클래스 명과 속성 : 클래스 이름과 멤버변수
	분석 클래스 검증 : 
		보통 개념수준 검증과 같이 한다
★64페이지 :
	시험에 나옴 - 실무에서도 중요한 용어들임
	액터 / 유즈케이스 / 유즈케이스 명세서
	유즈케이스 명세서 :
		사전 및 사후 조건 ex) 클릭 전, 클릭 후 액션
		예외 흐름 : 예외 상황이 나왔을 때 어떻게 처리를 할 것인가
		기획자는 위 두개를 잘 검증해야 한다.
★65/67페이지 : 
	섞어서 시험에 나옴. - 분석 클래스 검증에 해당하지 않는 것은?
	67페이지 : 제어클래스 ex) DataHandler 클래스
	시험 아니더라도 중요한 내용으로 보임.
★66페이지 : 
	시험에 나옴. - 표기법
68페이지 : (67페이지와 연관)
	(분석 클래스의 스테레오 타입 예시)
	경계(바운더리) : MainActivity
		외부 액터(=유저)와의 상호작용을 담당
			유저의 액션이 있는 곳
	엔터티 : Contact
		정보를 관리하는 기능을 전담(저장, 사용, 정보 접근 권한부여)
	제어(컨트롤러/핸들러) : DatabaseHandler
	*유즈케이스당 일반적으로 1개의 제어 클래스가 존재한다
		유즈케이스는 행동을 정의하는 명세서이기 때문에, '행동'하는, 즉 제어하는 클래스가 필요하다.
69페이지 : 
	경계와 제어 클래스의 상세 검토사항
		제어 클래스의 연산에 대응하는 엔터티 클래스가 있는지 확인한다.
70페이지 : 
	★관계의 다중성 : 66페이지 참고
	클래스의 속성 및 연산 : 속성 - 멤버변수 / 연산 - 메소드
		매개변수 - 파라미터
			연산의 매개변수 - 메소드의 파라미터
	"문서"에 정의되어 있는지 확인하라는 것. 앱 검증 단계가 아님.
★71페이지 : 
	시험문제 나옴. 단답형.
		+는 퍼블릭을 의미.
		공인인증서 로그인 "화면" = 로그인 액티비티
			바운더리
		로그인 "제어" = 컨트롤러
		★칸 3개로 나뉘어있으면 첫 칸은 클래스이름
			두번째 칸은 멤버변수
			세번째 칸은 메소드를 의미함.
74페이지 : 
	개발자는 '검토 의견' 항목에 검토 의견과 필요한 사항을 적어놓고
	기획자는 이 검토 의견을 보고 보완한다.
★77페이지 : 
	시험 문제에 나옴
	(이전에 나왔던 표임)
	분석모델의 기술적 타당성 검증 절차
		이 전체 과정에 문제점이 없는지 검증하는 과정이다
	실무에서 시스템간 상호 운용성 : 
		이거는 타 업체와 서비스 연동시에는 중요하다. 해당하지 않으면 크게 중요하지 않다.
	기술적 위험 분석 - 검증되지 않은 기술 : 
		사람들이 잘 쓰지 않는 최신 언어(및 오래된 언어)는 사용 및 보수가 힘들다.
==============================================
시험 관련 내용
	객관식/단답형
==============================================

RecyclerView
	개별 목록(셀)들을 자동으로 여러개를 놓을 수 있는 뷰(바탕)
	셀 화면 하나를 구성해주면 알아서 쭉 나오게 해준다.

동그란 판때기 : 카드뷰★
	리사이클러뷰랑 같이 잘 씀
		리사이클러뷰+카드뷰 제일 일반적인 조합

계층 구조
	레이아웃 안의 레이아웃 안의 ......



★★★★★ 리스트 모양을 처리하기 위한 과정 ★★★★★



[1] 셀 구성을 위한 화면 만들기(셀 템플릿 만들기) 과정
	셀을 만들면 리사이클러뷰에 표시된다.
	셀 만든다 = 화면을 만든다 = xml파일을 만든다
	(선행) 리사이클러뷰를 원하는 xml에 깔아놓는다
	1. 레이아웃 폴더에 셀을 구성하는 새 xml 파일을 만든다
		셀의 템플릿 파일임
		비공식 네이밍 룰 ~row.xml
	2. 이 xml과 연결할 자바 파일이 필요함 - 자바파일 만들기
		새 패키지(adapter-비공식네이밍룰)를 만들어서 거기에 RecyclerAdapter.java 파일을 만듦
			이 자바 파일은 ???과 연결됨
	3. [자바] 상속받기 - extends RecyclerView.Adapter
		만들어진 함수를 오버라이드 했다 - 정해놓은 규칙이 있고 그 규칙대로 만들어야 한다는 뜻
			얘는 Activity 클래스가 아니고 Adapter 클래스이므로 액티비티 클래스에서 객체 생성을 해줘서 만들어야 한다.
			부연설명 : AddContact는 액티비티 클래스이다.
				뷰를 상속받았기 때문에 이 자바 파일도 "액티비티 클래스" 이다.
					액티비티 클래스는 화면과 연결되어있음을 잊지 말자.
	4. 이 클래스 맨 아래에(밖에 아님) 추가 + Alt+Enter
	==================  예시  ===================
		public class ViewHolder extends RecyclerView.ViewHolder{
			// 아래 함수는 Alt+Enter 하면 생김
			public ViewHolder(@NonNull View itemView) {
            super(itemView);
			}
		}
		// 새 클래스(뷰홀더 클래스)를 추가한 것임.
	==========================================
	5. 어댑터 부분의 기본 구조(와꾸^^) 완성



[2] MainActivity에서 사용하기 위해 기본 기능 셋팅하기

	1. 이 클래스의 생성자 만들기
		이 생성자는 Context 타입과 ArrayList<받을데이터타입>을 받아 이 클래스에 변수로 저장하는 get 함수이다
	==================  예시  ===================
    public RecyclerAdapter(Context context, ArrayList<Contact> contactList){
        this.context = context;
        this.contactList = contactList;
    }
	==========================================
	1-1. onCreateViewHolder(@NonNull ViewGroup parent, int viewType) 안에서 뷰를 생성한다
	==================  예시  ===================
		View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.contact_row, parent, false);
	==========================================		// 이 뷰는 parent로부터 만들어졌다.
		// 이 뷰는 contact_row.xml 레이아웃을 가져온다.
	1-2. view 변수를 담는 새로운 ViewHolder() 객체를 "리턴"한다
		return new ViewHolder(view);

	2. ViewHolder 클래스에서 contact_row.xml에서 만든 뷰들을 연결시킨다
		// 액티비티에서 뷰 연결하듯이 연결하면 된다.
	==================  예시  ===================
	public class ViewHolder extends RecyclerView.ViewHolder{

		// 2-1. 멤버변수 선언
        public TextView txtName;
			// 의미를 명확하게 하기 위해 public을 붙여줌
        public TextView txtPhone;
        public ImageView imgDelete;

        public ViewHolder(@NonNull View itemView) {
            super(itemView);

            // 2-2. 생성자 안에서 멤버변수를 연결
                // 액티비티 클래스에서 하는 연결과 다르므로 다른 연결 방식을 쓴다
            txtName = itemView.findViewById(R.id.txtName);
                // "itemView" 는 위에서 보내준 변수(view)를 받을 것(return new ViewHolder(view);)이고,
                // 이 view 는 여기서 R.layout.contact_row 를 의미하므로,
                // ★ contact_row.xml 에 있는 id룰 찾아 가져오려면 itemView.findViewById(); 라고 써야한다. ★
            txtPhone = itemView.findViewById(R.id.txtPhone);
            imgDelete = itemView.findViewById(R.id.imgDelete);

        }
    }
	==========================================

	3. db에 있는 데이터들을 화면에 있는 View들 위에 표시하는 메소드onBindViewHolder() 안의 내용을 작성한다
		// int position : 화면에 표시되는 리스트의 "인덱스" 번호
			// 안드로이드에서 자동으로 처리해주는 파라미터이다.
			// DB에서 불러와서 처리해주는 것 같다.
	==================  예시  ===================
		public void onBindViewHolder(@NonNull RecyclerAdapter.ViewHolder holder, int position) {
		
        // 3-1. 데이터가 저장된 ArrayList에서 "포지션"에 맞는 데이터를 하나씩 꺼내온다
        Contact contact = contactList.get(position);
            // contactList 에 있는 항목들의 속성은 Contact 속성이므로 Contact 타입으로 가져온다
			
        // 3-2. 가져온 데이터에서 필요한 데이터들을 추출한다
        String name = contact.getName();
        String phone = contact.getPhoneNumber();

        // 3-3. "ViewHolder"에서 연결해놓은 텍스트뷰에 추출한 데이터들을 셋팅한다
        holder.txtName.setText(name);
        holder.txtPhone.setText(phone);
    }
	==========================================

	4. 리스트에 있는 데이터의 개수를 리턴해주기 위한 함수(getItemCount())를 셋팅
	==================  예시  ===================
	@Override
    public int getItemCount() {
        return contactList.size();
		// .size() : ArrayList 안에 있는 데이터의 개수를 리턴해주는 함수
    }
	==========================================

[3] MainActivity에서 RecyclerAdapter를 이용해 리스트뷰 내용을 구현한다
	1. 지역변수로 세가지를 선언한다
		1-1. RecyclerView recyclerView; // 메인액티비티와 연결된 xml 에서 가져온 뷰
		1-2. RecyclerAdapter recyclerAdapter; // 하나의 셀을 연결시키는 어댑터
		1-3. ArrayList<Contact> contactArrayList; // 데이터베이스에서 읽어온 주소록 정보를 저장할 리스트
		// 리스트 항목 뷰를 작성할 때에는 리사이클러 뷰, 셀 연결(뷰 처리) 어댑터, 데이터베이스를 담은 ArrayList 이 세 가지가 꼭 필요하다.
	2. onCreate()에서 리사이클러뷰를 연결시켜준다
		recyclerView = findViewById(R.id.recyclerView);
	3. 리사이클러 뷰의 기본적인 셋팅을 해준다
		// !! 정리중

xml에서 카드뷰 설정 바꾸기
	cardCornerRadious 코너부분 반지름 변경
		숫자가 커질수록 더 둥글어진다
	layout_margin 변경
	카드뷰의 background 변경
	cardElevation 카드 음영(그림자) 두께 변경
	카드의 배경색은 카드뷰의 상위 레이아웃의 백그라운드 컬러를 바꿔주면 된다.

하나의 카드뷰를 클릭하면~~ 이벤트 만들기
	1. 카드뷰를 자바에서 불러오기 위해 레이아웃에서 카드뷰에 id 설정
	2. RecyclerAdapter로 가서 ViewHolder 클래스에서 버튼 클릭 이벤트를 만든다.
		2-1. 전역변수 설정
		public CardView cardView;
		2-2. 생성자 안에서 연결
		cardView = itemView.findViewById(R.id.cardView);
		2-3. 카드뷰 클릭 이벤트 만들기
		cardView.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {

			}
		});

액티비티가 아닌 곳에서 intent로 액티비티 넘어가기
	ex)i = new Intent(context, CorrectContact.class);
		context.startActivity(i);

자바 폴더 깔끔하게 정리하기 : 
	액티비티는 바깥에, 나머지 필요에 의해 만든 기능을 가진 자바 파일은 따로 폴더를 만들어서 넣어놓기.

int id = getIntent().getInExtra("id",-1)
	// 디폴트값을 -1로 지정하면 id가 -1인 경우(잘못된 경우)를 if로 지정할 수 있다.200617 수요일 수업 내용 정리

200618 목요일 수업 내용 메모

깃헙 43. 안드로이드 복습 실습 1
실습하기
MemoApp

자바는 객체로 처리한다.

단위 업무?
기간 업무?

로직은 본인이 계획하는(짜는) 거고,
개발은 copy & paste이다.
	필요한 코드 조각들을 저장해놓은 라이브러리를 차곡차곡 쌓아뒀다가 필요한 곳에 copy & paste하자.

앱을 실행하거나 다른 액티비티에서 돌아올 때 화면 리스트를 새 리스트를 갱신하고 싶으면 onResume() 메소드 안에 화면 갱신 정보를 적으면 된다.
	onCreate()는 실행시 한 번만 실행되므로 화면 갱신에 적절하지 않다.

액티비티의 라이프 사이클은 한 액티비티에만 적용되는 것이 아니라 각각의 액티비티에 적용된다.
200618 목요일 수업 내용 정리
200619 금요일 수업 내용 메모

로직
	일을 처리하는(문제를 해결하는) 순서/흐름/절차

유즈케이스
	액션/행동을 설명한 것

배열[]과 ArrayList의 차이
	배열은 만들어놓은 인덱스(공간)만큼만 데이터를 추가/변경할 수 있지만, ArrayList는 저장할 수 있는 인덱스 공간이 가변적이어서 남는 공간을 생각하지 않고 마음껏 인덱스를 생성/변경/삭제할 수 있다.

프로젝트 Edit
	EditText의 기능을 실습하는 클래스를 만듦.

텍스트 와쳐
addTextChangedListener() > editText 의 텍스트가 바뀔 때마다 감지하겠다
textWatcher() > 지켜보겠다
글자가 하나하나 바뀔 때마다 아래의 세가지 함수가 계속 돌아간다.
CharSequence s > 문자열은 아니지만 문자열로 바꿀 수 있다 > s.toString()
	사용자가 입력한 문자열을 가져오는 파라미터이다.
	ex) editText.addTextChangedListener(new TextWatcher());

xml 버튼 속성
	android:visibility=""
		visibile 보임
		invisible 자리 차지하면서 보이지는 않음
		gone 자리 차지도 안 하고 보이지도 않게 처리
		주요 사용처 : 등급별/상황별 보이는 버튼 안 보이는 버튼 처리

깃헙 앱실습10 - 네트워크 리스트 실습

=====

다음 시험은 포트폴리오 형식임
안드로이드 스튜디오로 프로젝트 만들기 시험
	깃헙 43번 안드로이드 복습 실습 1(MemoApp) 에서 냄.
	이 예제 만들 줄 알면 됨. 화면 구성 말고 주요 기능들 구현할 줄 알면 됨.
	! 요구하는 기능을 잘 만들었는가
		"버튼 누르면 화면 전환하기"
			Intent i = new Intent(현재액티비티.this, 옮길액티비티.class);
				startActivity(i);
		"'수정 완료' 누르면 Toast를 띄우고 이전 액티비티로 돌아가는 기능"
			Toast
			finish()
	! 화면 구성을 요구하는 대로 잘 지정하였는가
		"배경색 등등을 요구하는 대로 잘 지정하였는가"
			xml - background
		"EditText에서 힌트 작성"
			xml - hint200619 금요일 수업 내용 정리
200622 월요일 수업 내용 메모

엘리 코딩 유튜브 채널 추천해주셨음.

콜!!!백!!!함수!!!!!1

===깃헙45번 : 앱 실습 10-네트워크 리스트===
★★★이거 프로젝트 들어가서 정리 잘하기. 정리 잘 되어있음.★★★

JSON
	제이슨은 계층적 구조를 가지고 있다.
	{ } : 제이슨 오브젝트
		ex. { "key" : "value" }
			 { "key" : "value", "key2" : "value", ... , "key3" : "value" }
			 한 오브젝트 안에 들어가는 키는 같은 이름일 수 없다.
	[{},{},{}] : 제이슨 어레이
		오브젝트를 두개 이상 묶은 것
		ex. [{ "key" : "value" },{ "key" : "value" }, ... ,{ "key" : "value" }]
	키는 조회용 아이디.
	키값의 결과를 밸류에 셋팅한다.
	★키, 밸류는 안에 있는 값의 자료형은 boolean 타입을 제외하고 전부 " "로 둘러싸야 한다. ' '는 "안된다".
		boolean은 " "를 안 치고 그냥 적는다.
	★최상위 데이터는 중괄호{}(제이슨오브젝트)로 싸여있을 수도 있고, 대괄호[](제이슨어레이)로 싸여있을 수도 있다.

http 프로토콜을 사용했기 때문에
그래서 웹브라우저가 호출하듯이 안드로이드에서도 호출했다.

데이터 파싱
	특정 데이터만 "분리"해서 뽑아오기.
	json의 구조(위의 키:밸류, 오브젝트, 어레이)를 파악하면 파싱하기 쉽다.

파싱해온 데이터(예시)
	{"status":"success",
	"data":[
			{"id":"1","employee_name":"Tiger Nixon","employee_salary":"320800","employee_age":"61","profile_image":""},
			{"id":"2","employee_name":"Garrett Winters","employee_salary":"170750","employee_age":"63","profile_image":""},
			{"id":"3","employee_name":"Ashton Cox","employee_salary":"86000","employee_age":"66","profile_image":""}
		]
	}
		·이 제이슨의 키는 크게 status, data 2가지이다.
		data 키값의 밸류는 제이슨 어레이 형식이다.
		·★★★★★ 파싱하려면 데이터를 "직접 보면서"("인터액션 하면서") 받아와야 한다. ★★★★★

public void onResponse(JSONObject response){}
	JSONObject({ })을 response라는 이름의 파라미터로 받아온다는 의미이다. 즉 특정 URL을 통해 받은 JSON을 제대로 받아오면, 받아온 JSONObject를 이 {}안에서 response라는 이름으로 사용할 수 있다는 뜻이다.

public void onResponse(JSONArray response){}
	위 설명에서 JSONObject를 JSONArray로 바꾸면 설명 똑같음.

키값으로 JSONObject 조회(파싱)하기(예시)
	String value = response.getString("status");

키값으로 ★JSONArray★를 통째로 파싱하기(예시)
	JSONArray dataArray = response.getJSONArray("data");

불러낸 JSONArray에서 JSONObject 파싱하기(예시)
	for(int i = 0; i < dataArray.length(); i++){
		// 1-1. 어레이에서 오브젝트 가져오기(가져오기 끝)
		JSONObject object = dataArray.getJSONObject(i);
		// 1-2. 오브젝트를 "통째로" String으로 가져와보기
		String dataArrayObjects = object.toString();
	}
		·가져오려는 게 JSONObject 이므로 .get(인덱스)이 아니라 .getJSONObject(인덱스)로 가져와야 한다.
		·가져오는 { } or [ ] 범위가 어디서부터 어디까지인지를 실제로 보면서 잘 파악해야 한다.

파싱한 JSONObject에서 특정 키값의 내용들만 "전부" 파싱하기(예시)
	<<for 루프 안이라고 가정>>
	// 1-1. 어레이에서 오브젝트 가져오기 
	JSONObject object = dataArray.getJSONObject(i);
	// 1-2. ★이렇게 불러낸 JSONObject 에서 특정 키값만 "전부" "파싱"하기(가져오기 끝)
	String name = object.getString("employee_name");
		// 이름이 "employee_name"인 키값의 밸류를 String 타입으로 name에 저장한다.
		// 가져오려는 자료형에 따라 get~ 뒤에 자료형 이름을 붙여준다.
			// ex) int형으로 가져오려면 int id = object.getInt("id");

try/catch
	·JSON 데이터를 파싱하기 위해 .get~을 쓰면, 프로그램에서 빨간 밑줄이 그어지고 Alt+Enter를 치면 try/catch를 만드는 것을 추천한다. 만들면 된다.
	·다양한 키값들을 가져올 때 try와 catch를 하나만 만들어서 그 안에 써도 되고, 불러오는 키값마다 각각 try/catch를 만들어 써도 된다.
	·try
		특정 키값을 불러오기를 시도하고 성공하면 try{} 안에서 처리한다
	·catch
		특정 키값을 불러오기를 시도하고 실패하면 catch{} 안에서 처리한다

앞으로 데이터들을 저장하려면 저장하는 "클래스"를 따로 만들어 그 "클래스에 저장"한다.
	"엔터티 클래스"를 만든다.

자바는 객체 지향 프로그래밍 언어니까!!

깃헙 앱실습11 Network 직접 실습해보기
프로젝트 이름 : Todos
성공적 :3

(앱실습 10)
리사이클러뷰 상하좌우 다 연결하고 ★와이드 헤이스 0dp(매치 컨센트레이트)로 교체★
1.화면먼저만들고
2.화면에연결시킬자바만들어야 편함200622 월요일 수업 내용 정리

200623 화요일 수업 내용 메모

===화면 설계 이론===

!! 3페이지 소프트웨어 아키텍처 개념 시험 나옴
5페이지 UI의 활용 5페이지 UI
	안드로이드의 액티비티, 텍스트뷰 => UI, UI컴포넌트
6페이지 작업 수행 내역을~변화하였다
	UI 설계
		어떻게하면 더 쉽게 사용할 수 있도록 할지 설계,
		직관적으로, 보기 쉽게 사용할 수 있도록 설계하는 것
		★사용자가 얼마나 쉽게 잘 사용할 수 있게 할 거냐
		★정보 전달을 얼마나 잘(정확하게) 할 거냐
			ex) 필요에 따라 버튼을 눈에 띄게(크게) 만든다든지
7페이지 UI 설계 원칙 > 이거 나올 거 같음.
	(다) 학습성 예시 :  앱 소개 페이지의 사용법 동영상
	가장 중요한 것은 직관성. 구구절절 설명없이도 사용할 수 있는 화면.
8~9페이지 UI 설계 지침
	(가) 사용자 중심 : 사용자를 위한 것. 개발자가 아닌 실 사용자 입장에서 만드는 것.
	★★★(자) 오류 발생 해결 예시
		1번 오류가 발생했다.(명확하지 않은 오류 안내)
		어떤 오류가 났는지, 왜 오류가 났는지 정확하게 안내하기
			테스트에 이거 토스트로 추가하는지 안하는지에 따라 점수 차이가 날 것임.
10페이지
	UI를 설계해놓고, 설계한 화면을 보면서 설계하면 개발 속도가 빨라진다.
11페이지
	UI 요구사항 정의
		기획자가 기획한 것을 개발자가 검토하고
		개발자는 이 내용들(11페이지)을 바탕으로 기획자에게 피드백을 준다
		★★★ 유지보수성 : 수정이 용이한가? 실무에서 매우 중요.
			 ex) 변수 이름 개떡같이 만들어놨을 때 수정하기 힘들어짐
12~18페이지
	PM? PM이 12페이지부터 18페이지까지의 내용을 검토함.
	적어놓고 해야지 머릿속에만 넣어놓으면 처음 기획하려던 것에서 헷갈리고 바뀐다.
19페이지
	UI 요구사항 확인
		(나) 사용자의 입력에 대해 무엇을 어떻게 출력할 것인가
		(다) ex) 사용자의 무엇을 DB에 저장할 것인가
20페이지
	(가) 재사용성 - 액티비티 제작 후 재사용할 화면 포맷을 설정
	(다) 설계에는 ★반드시 일정이 있어야 한다.★
22페이지
	수행 순서
	액션 인터페이스 - 유즈케이스 명세서
		화면 배치 - 레이아웃 < 이번에 포트폴리오로 시험보는 거
	★데이터포맷 중요함.
	UI스타일 가이드 정의
		보통 디자이너들이 가이드를 정해줌. 기획자한테.
		이 정의는 앱이 아니라 웹에 대한 예제.
			웹 브라우저마다 개발 환경이 다르다. 웹 개발할 때는  이런 점을 조심해야 한다. 모든 브라우저에서 잘 돌아갈 수 있게 만드는 것은 빡세다고 한다.
		안드 개발자는 기기마다 다른 해상도 테스트를 할 때 주의하면 된다.
24페이지
	프레임 세트 적용 예
		실제로 이렇게 한다고 한다.
25페이지~32페이지
	레이아웃 정의
		구역마다 무엇을 놓을지 정의하는 것
		개발자들은 이것을 보고 개발을 한다.
27페이지
	모바일 개발도 이와 같이 준다.
28페이지
	메뉴 구성
30페이지
	화면마다 다른 해상도 맞추기
33페이지
	프로세스 모델링을 정의
		업무 기능 모델 수립
		프로세스 명세서(프로세스 다이어그램) 작성
34페이지
	데이터 모델을 정의한다.
		Data "Entity"
		엔터티 목록이 클래스와 1:1로 매핑
		기획자가 엔터티 목록을 뽑아오면
		데이터 모델 뽑는 것(여기서) 부터는 개발자가 하는 것이다.
		엔터티 목록 => 자바 클래스
		어떤 거는 DB 테이블로, 어떤 거는 클래스로 정의할지
			DB 테이블 어떻게 설계할 것인가 ERD(엔터티 릴레이션쉽 다이어그램) 어떻게 저장할 것인가
35페이지~37페이지
	그리드 설명
38페이지~41페이지
	디자이너가 정해준다.
42페이지
	★유즈케이스를 이용해서★
44페이지
	서버 컨트롤러(control) : 액션을 정의하는 애다. 전담반이다.
	예외 처리는 중요하다.
		실제로 유저한테 말해줄 때는 이보다 더 쉽고 명확하게 설명해준다. ex) ~하게 입력하십시오.
		서버에서 접속 안됐을 때 에러메세지 띄워주는 코드
			e.trycatch~에러메세지를 가져와주는 것
		Log
			log.i(인포메이션 처리)
			log.e(에러처리하겠다) < 에러라고 말해주고(표시하고) 싶을 때
				위 두개는 실제 앱에 추가해놓아야 오류 확인이 쉽다
			log.d(디버깅 처리) < 잘 안 씀. 개발자들이 많이 씀.
★★★45페이지
	http프로토콜에서 사용하는 용어
	네트웍 통신을 할 때 http프로토콜을 사용할 것이므로, http프로토콜을 사용하는 api를 활용해 개발할 것이므로 알아둬야 하는 내용들.
		Request (요청)
			ex) requestQueue = ~
				클라이언트가 요청할 때.
			ex) jsonObjectRequest
				json으로 받아올 거다.
		Response (응답)
			받아서 처리하는 것
46페이지
	조직 구성도
		커미티 - 위원장
		기획팀(서비스기획), UI팀(화면기획), 개발팀(기능개발)
		기획팀과 개발팀이 협업한다.
		TFT
			이슈(ex)신규 프로젝트/서비스)가 있을 때 잠깐동안 만들어졌다가 사라지는 구성(팀)
			똘똘한 사람덜,, 묶어서 팀으로 만들어놓은 거
			일 끝나면 다 자기 부서로 돌아감.
47페이지
	회의록 작성
		kick off시 : 프로젝트 착수시
	정기회의
		주로 주간회의를 함. 어디는 매일(스크럼 방식 : 짧게짧게 회의, 피드백, 회전. 매일매일 아웃풋 필요. 빡셈.) 하기도 함.
48페이지~49페이지
	★★★프로젝트 혼자 할 사람은 잘 봐야할 내용.★★★
	(1) ★★★사용자 트렌드 분석★★★
		분석 방법 : 구글플레이 가서 자신이 만들려는 앱의 장르를 검색해서 (주로 인기있는) 앱마다 눌러본다.
			여기서 화면 구성도 보고 기능도 보고 구런다.
	앱 개발에 웹뷰는 별로라고 한다.
	(2) 기능 및 설계를 분석
		ex)왼쪽 상단에 버튼 배치하면 누르기 빡세니까 지양한다.
		조작시 버튼 동선 배치
		ex) 알러트 다이얼로그 "예(positive 버튼)"를 왼쪽에 놨었다. 근데 그거 누르기 힘들다. 그래서 안드로이드는 그걸 반대로 바꿨다.
		(다) ex) 회원가입 어려우면 앱을 휴지통에 던져버림.
		(라) ★★★일관적★★★
51페이지
	(나) 비용은 사장님이 걱정해야됨.. 일정 확인은 개발자가 걱정해야됨.
		일정이 좀 더 필요하게 될 거 같으면 ★반드시 미리★ 상급자(팀장)에게 이야기해야한다.
	(다) ex) 날아다니는 자동차 만들자ㅎ
	★(마)★ 임원 면접시 임원이 개발에 문외한이다 싶으면 회사 들어가서 개고생한다.
		자체 서비스하는 회사가 워라밸 잘 지킨다거 한다.
		워라밸 잘 지킨다고 하는 곳에 들어가자. 좋은 회사 많다.
53~54페이지
	★★★프로젝트 혼자 할 사람은 잘 봐야할 내용.★★★
	★(나)★ 동사형으로 설명한다 : 액션 > 이게 유즈케이스가 됨.
	페르소나
		사용자(타겟 대상)가 되었다고 가정해보는 것.
		이렇게 생각해보면 기능 동선이 나온다.
		이렇게 생각해보고 기획하면 된다.
			이게 기능 구현이 될지 안될지를 생각해보자. 
		제발 개발자 입장에서 만들지 말자.
	정황 시나리오 작성
		페르소나 가정이 구체적일 수록 시나리오가 잘 나온다.
===

화면설계는 포트폴리오 시험
	마진 잘 주기
	화면넘기기
	데이터 전달 잘 하기
	10글자 이후, 2줄 이후를 ... 처리하기
	
화면설계 이론 pdf 3~4번 파일까지있음.(2번까지 받아놓음)

안드로이드는 구글이 만든 거

개발자는 기획 문서를 잘 볼 줄 알아야한다.

===

실습 앱 프로젝트 Fab

액션바 되는 프로젝트 만들기
	1) 프로젝트 생성시 "베이직 액티비티를 선택"해서 만듦.
	보통 이렇게 만든다고 함.

==java파일설명
FirstFragment / SecondFragment
	보통 태블릿용 만들 때 씀. 화면 분할에 많이 씀. 폰 개발자들은 이 파일 잘 안 씀. 그냥 액티비티에 씀.

==xml파일설명

앱바 아래 툴바 아래

인클루드(포함하다)
	다른 파일을 여기에 표시하겠다. 옆에 회색 글씨로 쓰여있는 파일을 여기에 추가하겠다.

★★★fab 버튼
	= 플로팅 액션 버튼
	이 버튼 상당히 편리함.
	초기화면에 버튼 누르면 밑에 뜨는 메세지 명칭 : 스낵바
		플로팅이랑 코딩하는 것도 비슷함. 유용하게 쓸 수 있음.

2) fragment
	이건 안 씀. 지우면 됨.

3) 자바 퍼스트/세컨드 프레그넌트 삭제 후 레이아웃에서도 관련 파일 두가지 삭제 후 프로젝트 진행

MainActivity 파일, activity_main 파일 탐색함
	MainActivity - 툴바 설정 코드, 플로팅 버튼 설정 코드가 onCreate(){} 안에 있음.
	·툴바 설정 코드
		// 툴바 설정 코드
        Toolbar toolbar = findViewById(R.id.toolbar);
        // 툴바 돌아가게 만드는 코드
        setSupportActionBar(toolbar);
	·fab 버튼 설정 코드
        // fab 버튼 설정 코드
        FloatingActionButton fab = findViewById(R.id.fab);
        fab.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Snackbar.make(view, "Replace with your own action", Snackbar.LENGTH_LONG)
                        .setAction("Action", null).show();
            }
        });

플로팅 버튼 속성
	android:layout_gravity="bottom|end"
		버튼의 위치 변경
		end > 처음부터 끝까지 가라
		위치와 위치 사이 | 에 띄어쓰기 있으면 안됨.
	app:srcCompat="@android:drawable/ic_dialog_email"
		여기서 플로팅 아이콘 이미지 변경 가능

레이아웃 > menu > menu_main.xml > 메뉴 버튼 누르면 나오는 레이아웃 파일
	액션바에 버튼을 추가하려면 <item />태그를 써서 추가하면 됨.
	app:showAsAction="always"
		버튼을 액션바에 (항상) 표시해라
		app:showAsAction="always|withText"
		밖에 항상 나와있으면서 | 텍스트를 같이 표시해준다
	app:showAsAction="never"
		버튼을 보여주지 마라.
		이걸 적용하면 맨 우측 쩜쩜쩜 버튼 안에 들어가있게 된다.
	★★★app:showAsAction="ifRoom" 설정
		아이콘 배치하다가 순서가 안 되는 애들은 쩜쩜쩜 공간 안으로 들어간다.
		★always 설정보다는 ifRoom을 많이 쓴다.
			해상도 따라서 자동으로 버튼이 숨겨졌다가 표시됐다가를 가능하게 해준다
	android:orderInCategory="숫자"
		숫자에 적힌 순서대로 버튼이 정렬된다
	모든 버튼을 never로 하고 1,2,3 하면 초기 버튼 안에 순서대로 정렬된다.
	android:title="삭제"
		버튼의 (보이는) 이름 설정
		아이콘과 이름을 같이 설정시 버튼을 꾹 누르면 이 이름이 나온다.
	android:icon="@android:drawable/ic_input_add"
		아이콘으로 버튼 이미지 대체 가능
	보통 여기에 들어가는 메뉴버튼 아이디는 menu_~로 설정한다.

★★★알러트다이얼로그 커스터마이징 (커스텀UI)
	1) 먼저 알러트에 띄울 .xml 파일을 만든다

★깃헙 앱 실습 13_커스텀다이얼로그
	프로젝트 : CustomAlert

200623 화요일 수업 내용 정리

200624 수요일 수업 내용 메모

=== 화면설계(2) 이론 설명 ===

2~5페이지
	< 프로토타입 >
	프로토타입 : 대량 생산에 앞서 미리 제작해보는 "원형"
	프로토타입의 뜻
		잘 돌아가는지 대충 확인하기 위해서 전체적인 기능을 간략한 형태로 구현한 시제품
		"새로운 컴퓨터 ~~ ~~ 구현한 시제품"
	★실제 수많은 앱들이 프로토타입의 지속적인 확장, 보강을 통해 최종 설계가 완성된다.
	UI는 프로토타입에 있어서 추후 구현될 시스템의 골격이다.
	프로토타입을 업그레이드를 쭉쭉 하다보면 결국 맨 마지막의 작업 결과물이 됨
	프로토타입을 잘 만들어놓으면 마지막 단계인 개발이 쉬워진다.
		기획 > 디자인 > 개발
	5페이지
		1. 설명에 대한 시간을 줄여준다
			걍 프로토타입 만든 거 "보여주면" 되니까.
		2. 구현이 가능한지, 불가능한지 사전 검증을 할 수 있다
		3. 프로토타입은 검증을 위한 것이므로 최대한 간단하게 만들어야 한다.
6페이지
	UI 프로토타입 : 종이, 혹은 ppt 등으로 화면을 미리 만들어보는 것

7페이지
	UI 프로토타입 "설계" 예시

8페이지
	기업들은 무조건 UI 프로토타이핑을 한다.
		이게 나와야 개발을 할 수 있다.

9페이지
	UI 프로토타이핑 툴
		파워포인트
		와이어프레임
		어도비 XD
		Oven < 카카오에서 만든 거
		발사믹 목업

21페이지
	"유스케이스(행동)" 형식으로 적는다.
	1. 개요
		사용자는 ~를 통해 ~한다.
	2. 액터
		사용자
	3. 이벤트 흐름
		(1) 기본 사항
			(가) 사용자는 ~에서 ~를 누른다
			(나) 시스템은 ~에서 ~를 출력한다
			...
		(2) 추가 사항
			(가) 사용자가 ~에서 ~를 누를 경우
			(나) 시스템은 ~을 출력한다
	4. 처리 내용
		~에 ~가 수정된다

★★★29페이지가 다음주 시험문제 부분. 이런 식으로 낸다는 뜻임.

화면설계(2) 까지가 화면 "설계"의 끝이다.

낼은 스토리보드 작성 어쩌구

=======================================

안드
주석에 todo 달아놓으면 작업을 어디까지 해놨었는지 찾기 쉽다.

fab 버튼 > 팹버튼이라고 부른다

=== 프로젝트 : Serializable ===

Intent
	액티비티간 정보를 객체(클래스 자체)에 저장해서 한꺼번에 전달하는 방법
		기존 전달은 변수 하나하나 저장해서 전달한 거였음.
	: Serializable
	1. 일단 정보를 저장하고 불러낼 클래스를 생성
	2. 클래스 셋팅
		저장할 정보들 변수를 private로 선언
		그냥 생성자
		정보를 입력받을 생성자
		모든 변수의 게터세터
	3. 정보를 전달받을 액티비티 생성
		3-1. 전달받는 액티비티 화면 셋팅
			이 프로젝트에서는 전달해주는 모든 정보를 한 텍스트뷰에 한꺼번에 표시하려고 함
	4. 각각의 액티비티에서 뷰 연결
		4-1. 라디오그룹/라디오뷰 연결하는 방법
			4-1-1. 일단 라디오그룹만 먼저 findViewById()로 가져온다
			4-1-2. 라디오 그룹 내에서 사용자가 체크한 버튼이 무엇인지 알아내는 id값을 int로 가져온다
				ex) int checkedId = radioGroup.getCheckedRadioButtonId();
			4-1-3. 버튼 아이디값을 if로 비교해서 눌러진 버튼마다 실행시킬 이벤트를 입력한다
				이벤트가 2가지일 경우 아래와 같이 세팅해주면 확실하다
				boolean isMale = false;
				ex) if(checkedId==R.id.radioM){
						isMale = true;
					}else{
						isMale = false;
					}
	5. Intent 셋팅
		5-1. Intent i = new Intent(지금액티비티,보낼액티비티);
		5-2. 

RadioGroup / RadioButton
	1. 레이아웃에 라디오 그룹 뷰 추가
	2. 그 안에 라디오 버튼 뷰 추가
	3. 라디오그룹뷰/라디오버튼뷰 둘 다 아이디 설정

기존 코드가 어떻게 짜여져있는지 분석을 잘 할 줄 알아야 한다.

ArrayList
	박스끼리 연결 된 거라고 생각하기. 박스의 속성이 <> 안에 들어가는 클래스 이름.

상업용 어플에서 폰트 가져다 쓸 때 폰트 라이센스 주의하기.
★★★안드로이드에는 폰트 글씨체 파일 이름도 대문자가 들어가면 안된다.★★★
안드 프로젝트에 폰트 복붙하기
	res > new > android resource directory > 리소스타입을 폰트로 바꾸고 생성 > xml파일을 만들면 됨. 추가한 글씨체 하나당 xml파일도 하나가 들어감.

프로젝트 Intent
	Intent를 활용해 주소록 띄우기/MMS 띄우기/웹브라우저 띄우기
	뭘 띄우든 관련된 앱을 선택하도록 되어있다.
		바로 메세지를 보내게 하는 것은 안드로이드 보안 정책상 불가능하다고 한다.200624 수요일 수업 내용 정리

EditText editName;
EditText editEmail;
RadioGroup radioGroup;
RadioButton radioM;
RadioButton radioF;
Button 

TextView txtPerson;200625 목요일 수업 내용 메모

=== UI 이론 ===
UI흐름 설계
	UI 설계서 구성에 따른 작성 방법
		UI 설계서 구성
		UI 설계서 개정 이력 필수
				책임을 누가 지느냐의 문제이기도 함
				개정 이력을 잘 적어야 하고, 새 개정 이력이 있는지 잘 체크해야 한다.
		개발자는 UI 설계서를 보고 개발한다.
			설계서가 없으면 개발할 수 없다.
		설계서 처음 작성시에는 "초안 작성"을 포함시키고
			버전은 1.0에서부터 시작한다.
UI 요구사항 정의
	사이트 맵 작성
	프로세스 정의
		프로세스 : 액션의 흐름
화면 설계
	화면별 고유 ID를 부여한다.
	UI 화면 설계의 기본 구성 요소를 정의한다.
		기본 구성 요소 : 윈도우/메뉴/아이콘/포인터
실행 차를 줄이기 위한 UI 설계 원리
	사용 의도 파악
	행위 순서 규정
		행위 순서를 잘 알아야 로직(순서)을 짤 수 있다
	행위의 순서대로 실행
		★제일 중요한 이야기 : 사용자가 의도한 행위와~ ~있도록 설계해야 한다.
평가 차를 줄이기 위한 UI 설계 원리
	사용자에게 사용자의 원래 의도가 충족되었는지 쉽게 알려줘야 한다
스토리보드 작성 기법
	스토리보드 : 디자이너와 개발자가 최종적으로 참고하는 산출 문서
		구축하는 서비스를 위한 대부분의 정보가 수록되어있는 문서이다.
	1. 메뉴 구성도 만들기
		전체적인 메뉴 구성도
	2. 스타일 확정
		레이아웃, 글자 모양, 크기, 색상, 그래픽에서의 일관성
	유용성을 적용한 UI 설계안의 적정성을 확인한다
		사용 의도를 정확히 확인한다
			UI 설계서를 통해 각 화면에서 불필요한 부가 기능이 있는지 찾아보기
			중복되는 기능이 있는지도 찾아본다.
		중요도와 난이도를 잘 생각해서 개발 순서를 정해야 한다.
UI 요구사항과 표준 및 지침에 따라, 화면과 폼의 흐름을 설계한다
	기능적 요구사항을 검토한다
	기능적 요구사항의 설명을 정리한다
	구축할 시스템에서 비기능적 요구사항이 무엇일지 정리한다
		비용 중요~
	비기능적 요구사항의 설명을 정리한다
		구축할 시스템이 운영체제에 종속적이지 않게 작동이 가능한지 분석한다.
	★★★데이터베이스관리시스템(DBMS)은 안정적인지 검토한다
		이거 중요함.
		데이터를 영구적, 영속적으로 저장되어있도록 하는 곳이므로.
		이벤트 처리 속도는 2초 이내에 응답이 와야한다.
			시간이 오래 걸리는 작업에도 피드백을 꼭(작업중이라는 메세지 등)를 보여줘야 한다.
화면의 임력 요소를 확인한다
	화면에 표현되어야 할 기능을 확인한다
		템플릿 활용!
	화면의 입력 요소를 확인
	추가적으로 필요한 화면 요소를 확인
		경우에 따라 필요한 화면은 어떻게 구성을 할 것인가 설계해야
		★사용자가 편하도록, 한 눈에 정보 파악이 가능하도록 설계해야 함
	기능을 표현하기 위해 필요한 페이지를 확인
	★★★각 화면 간 이동과 흐름을 확인한다.★★★
	앱 개발은 내가 작성하고자 하는 코드를 UI 설계를 보고서 이 흐름대로 개발하는 것이다.
		어떤 메소드를 어디에 넣어야하는지 이해하고 외워야한다.
유즈케이스를 통한 UI 요구사항을 확인한다.
	화면에 표현되어야 할 기능을 확인
	화면의 입력 요소를 확인
	추가적으로 필요한 화면 요소 확인
	기능을 표현하기 위해 필요한 페이지를 확인한다.
	각 화면간 이동과 흐름을 확인한다
		덱스(DEPS) 깊이는 3단계를 넘으면 좋지 않다.
유스케이스 설계
	유즈케이스 다이어그램
		각각의 액터가 어떤 행위를 하는지~
		요구사항을 바탕으로 액터를 세분화한다.
	유스케이스를 설계한다
		관리는 추상적인 개념이다.
			이걸 구체화해서 바꿔줘야한다.
UI 상세설계
	UI 시나리오 작성 원칙
		한눈에 쉽게 이해 가능하도록 구체적, 일관적으로 해야한다.
	★★★예외 상황에 대비한 케이스를 정의한다.
		예외 케이스의 정리가 부실하면 안 된다.
	★★★UI의 일반 규칙을 지키면서 기능별 상세 기능 시나리오를 정의한다.
		기획자가 이런 걸 모르고 설계하면 안 된다.
	일관성
		일관적 UI 스타일로 구성한다
	이해성
		구구절절 설명 안 해도 되도록 이해하기 쉽게 만들어라
	가독성
		(개발자전용) 문서를 쉽게 읽을 수 있어야 한다.
	수정 용이성
	추적 용이성
모범적인 UI 시나리오 문서의 효과
★★★★★UI는 무엇이든 사용자의 편의성을 최우선으로 고려해야 한다.
	예쁘게 꾸미는 것은 그 다음이다.
UI 설계서 표지 예시
	직접 앱을 만드려면 이렇게 설계서를 쓰면 된다.
★★★UI 시스템 구조 설계서
	여것이 사업하는 사람한테는 사업계획서가 되는 것이다.
	연습 추천받음.

==========================================

네트워크 모바일앱 서비스 기본 구조

Client <HTTP로 요청/HTTP로 응답> [Server <DB파일처리> Database]
	Client < 프론트엔드(웹개발)
	Server & Datavase < 백엔드 개발

API 서버 개발
	OS 설치
	웹서버 설치 또는 프레임워크 설치
		node.js
	Language
		Python
	API 설계(백엔드 개발)
		json
		api 파일명 정의

데이터베이스 구축
	OS 설치
	DBMS 설치
		MySQL
	DB 스키마 설계
		테이블 정의
		인덱스 정의

분산(샤드Shard) 데이터베이스 처리
샤드를 하다
NoSQL server
	mongosDB or 아마존에서 제공
	하나의 샤드에는 백업용? Replica(복제본) server가 있다
스토리지 서버
	API 서버와 연결됨
	사진 등의 자료를 저장
Cache Server
	대표적 캐시 서버 : 레디스
	메모리에 올려놓는 것과 같다
	ㅁAPI를 켜면 DB에서 정보를 불러온다
	변경이 덜 되는 DB(ex.유저 정보)를 먼저 싹다 불러와서 캐시 서버(메모리)에 올려놓는다.
		자주 변경되는 데이터는 여기에 넣으면 안 된다.
			이런 데이터는 항상 DB에 들어가야 한다
	얘도 분산 처리를 한다
메세지 큐(Message Queue)
	Receiver
	작업이 오래 걸리는 것들을 
	API와 스토리지 서버 사이에서 작업한다
Load Balancer
	부하 분산
	이용자가 많을 때 이용자(Client)와 API서버 사이에 부하를 분산시키는 Load Balancer를 놓는다.
	이용량이 많을 때 API 서버를 알아서 분산처리시켜준다.

==========================================

=== 프로젝트 : CustomAlert ===
폰트 적용 방법
	폰트 이름은 안드로 옮길 때 소문자로 저장한다
	시스템에 설치하지 않아도 된다
	같은 폰트를 적용해도 xml파일명과 ttf 파일명은 달라야 한다
	시스템 폰트를 바꾸려면 매니패스트로 가야한다
	폰트 전용 디렉토리를 만들 수 있다
		res > new > Android Resource Directory > font로 설정 후 OK

유용한 해외 영문 폰트 사이트
	https://www.1001freefonts.com/

=== 프로젝트 : Network State ===

디프리케이티드
	함수 쓸랬는데 줄 그어져 있는 거.
	대체할 것을 만들어놨으니까 새로운 걸 쓰라는 뜻임.
	돌아는 감.
	없어질 거라고 선언해준 것임.

==========================


=== 프로젝트 : ASyncTask ===
네트워크를 통해서 이미지를 받아오는 기능을 가진 프로젝트
핵심 : 쓰레드
	

운영체제 > 프로세스 > 쓰레드1
						  > 쓰레드2
						  > 쓰레드3
운영체제는 프로세스를 돌아가면서 실행시킨다.
	CPU가 빠르기 때문에 동시에 켜놓은 것 같지만 실은 그렇게 돌아간다.
	CPU가 돌린다.
프로세스 : 하드디스크에 저장된 프로그램이 실행돼서 메모리에 올라온 상태. 즉 실행중인 상태
쓰레드 : 하나의 똑같은 프로세스를 여러가지를 띄워놓은 것
	ex) 미디어 플레이어에서 1) 음악이 나오고 2) 가사가 나오고 3) 동시에 메뉴를 눌러볼 수 있다
		쓰레드로 처리하다 : 어떤 작업을 쓰레드로 처리하지 않고 그냥 프로세스를 실행시키면 그 동안 하나의 프로세스만 실행할 수 있다.
	발리 라이브러리는 스레드로 되어있다.
멀티 프로세스 : 프로세스를 쭉 번갈아가면서 실행시킬 수 있는 것.
	ex) 멀티 프로세스가 되지 않으면 프로그램 하나를 켰다가 종료시키고 다른 프로세스를 만들어서 또 작업하고 그렇게 해야했다.
멀티 쓰레드 : 한 프로세스 안에서 동시에 여러 작업을 할 수 있는 것. 이것도 동시에 일어나는 것 같지만 CPU는 돌아가면서 프로세스를 실행시킬 때마다 역시 돌아가면서 한 쓰레드씩 번갈아가면서 실행시키는 것이다.
	ex) 음악 나오게 하다가 가사 나오게 하다가 하는 것.
	동시에 실행해야하는 작업 개수만큼 쓰레드가 생긴다.
안드로이드 앱을 만들 때 이 작업 과정은 중요하다.
	여기서는 "운영체제"가 "안드로이드"가 된다.

이미지 다운로드
	이미지 처리 라이브러리
프로그래스바를 쓸 때는 릴레이티브레이아웃을 쓴다.
	릴레이티브레이아웃 : 상대적인 레이아웃
		얘는 뷰가 중복이 될 수 있다.
		뭔가를 겹치게 구성하고 싶으면 이 레이아웃을 쓴다.
		여기서는 레이아웃그래비티를 못 쓴다.
		대신에 정렬 시에는아래 코드 등등을 쓴다.
		android:layout_centerHorizontal="true"
			가로 가운데 정렬
		android:layout_below="@id/img"
			@id/img 아래에 배치
		android:layout_alignParentBottom="true"
			부모 안 바닥 자리에 배치
		android:layout_centerInParent="true"
			부모 안 가운데에 위치
	이미지 정렬 관련 태그
		android:scaleType="centerCrop"
			이미지를 원형 그대로 놓고 가운데로 정렬하고 나머지는 잘라낸다
		android:scaleType="fitXY"
			이미지의 가로세로를 지정된 가로세로 사이즈에 딱 맞춰 표시한다
	프로그래스바 설정
		android:visibility="gone"
			프로그래스바가 보이지 않도록 표시함

이미지 라이브러리
	android glide // 이거를 더 많이 쓰는 거 같음
	android picasso
	구글에서 검색함
	맨 위 깃헙 페이지 눌러서 들어감.
	이미지 로딩을 잘 해주는 라이브러리.
	발리 > 네트워크 통신으로 데이터 가져옴
		이미지 주소 url 처리를 글라이드가 함
			그래서 발리랑 글라이드를 같이 씀
			그리고 글라이드는 리사이클러뷰???로 씀
	repositories 는 첫번째 gradle 파일에 들어있음.

200626 금요일 수업 내용 메모

============== 네트워크 기본 셋팅 정리 ==============

1) AndroidManifest.xml 셋팅
	<manifest ... android:targetSandboxVersion="1">
	...
	<uses-permission android:name="android.permission.INTERNET" />
	...
	<application ... 
		android:networkSecurityConfig=
			"@xml/network_security_config"
        android:usesCleartextTraffic="true">

2) res 셋팅
	2-0) 만들어놓은 셋팅(xml 패키지) 복붙하고 주소만 수정하기
	2-1) res > xml 패키지 생성 > network_security_config.xml 만들기
	2-2) network_security_config.xml 에 아래 내용 복붙하기
=== 이하 복붙 ===
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <domain-config cleartextTrafficPermitted="true">
        <domain includeSubdomains="true">URL주소</domain>
		<!-- 도메인 추가 가능 -->
    </domain-config>
</network-security-config>
=== 복붙 끝 ===

3) Volley 셋팅
	Gradle Scripts > build.gradle (Module: app) 에 아래 복붙하기
	// Volley
	implementation 'com.android.volley:volley:1.1.1'

===============================================

===== 네트워크 설정 후 .java에서 json으로 API 사용하기 =====

1) 멤버변수 선언
	RequestQueue requestQueue;
    public static final String URL = "사용할API주소";

2) onCreate() 안에서 json으로 API 연결하기
	requestQueue = Volley.newRequestQueue(액티비티);
	Json~Request json~Request = new Json~Request(
		Request.Method.GET, URL, null,
		new Response.Listener<JSON~>(){
			@Override
			public void onResponse(JSON~ response) {
				Log.i("로그이름", "response : " + response.toString());
			}
		},
		new Response.ErrorListener(){
			@Override
			public void onErrorResponse(VolleyError error) {
				Log.i("로그이름","Error : "+error.toString());
			}
		}
	);
	requestQueue.add(json~Request);
	// 제이슨 Object인지 Array인지 확인하고 ~ 안에 채우기

3) onResponse(){} 안에서 json 데이터 가져오기
	JSON~ 변수1 = response.getJSON~(인덱스);
	자료형 변수2 = 변수1.get자료형("키값");

============ Gradle 셋팅/간략 사용 정리 ===============

1) 초기 셋팅 : Gradle Scripts > build.gradle (Module: app)에 Volley & Glide 추가하기
	// Volley
	implementation 'com.android.volley:volley:1.1.1'
	// Glide
	implementation 'com.github.bumptech.glide:glide:4.11.0'
	annotationProcessor 'com.github.bumptech.glide:compiler:4.11.0'

// Glide용 Url 셋팅
// 파일 확장자가 지정되어있지 않을 때 써야함.
	GlideUrl 변수 = new GlideUrl(URL주소, new LazyHeaders.Builder().addHeader("헤더아이디","헤더키").build());

// Glide를 사용해 가져온 미디어를 뷰에 표시하기
	Glide.with(표시할액티비티).load(URL주소)
		.optionalCenterInside().placeholder(디폴트이미지)
		.into(표시할뷰);
		// .optionalCenterInside() : 영역 내 이미지 위치 설정중 하나. 이미지 크기가 지정된 영역보다 크면, 이미지를 자르지 않고 이미지 사이즈 비율을 지키면서 영역에 맞게 줄인 다음 정 중앙에 배치함.

===============================================

=========== GoogleAPIs에서 프로젝트 만들기 ============

프로젝트 이름
Youtube

프로젝트 ID
apt-memento-281503

프로젝트 번호
864874456744

사용자 인증 정보 가져오기 : API 키
api key 이름 : youtube api key
AIzaSyDZTBpF7-q9LiD9zvVi8nscaCof8-PgbpY

API 및 서비스 > 대시보드 > API 및 서비스 사용 설정 > YouTube Data API v3 선택 > 

~1. "사용" 클릭 > 사용자 인증 정보 만들기 클릭 > 사용중인 API 선택 > 호출할 위치 Android > 어떤 사용자 정보가 필요한가요? > API 키 복붙해놓기 > 완료 > "이름"항목의 "API 키 1" 링크 누르기 > 이름 바꾸기 > API 제한사항 "키 제한" > Select APIs > ouTube Data API v3 선택 > 저장 > 이름 옆에 녹색 버튼 떴으면 이제 이 API를 사용할 수 있게 됨. 설정 끝.

~2. API 사용해 보기 > API Reference 화면 뜸 > 좌측 Search 클릭 > //이하설명//
	HTTP 요청
	GET https://www.googleapis.com/youtube/v3/search
	// 이러면 .method.GET 쓰면 됨.

================= API 호출 양식 ==================
// 파라미터(매개변수) 붙이는 양식
// ★★★GET 방식에서 요청 파라미터 생성하는 방법★★★
// API 주소에 파라미터를 붙이려면 ?를 쓴 다음 그 뒤에 파라미터들을 적어주면 된다.
// 파라미터를 붙여서 쓸 때는 사이에 &를 적어 구분한다.

=== 필수 파라미터 : part / key

part
	?part=snippet

key
	호출하는 api 주소 뒤에 아래의 양식을 붙여야 API를 호출할 수 있다
		사용 방법 ) &key=API키
		ex)  &key=AIzaSyDZTBpF7-q9LiD9zvVi8nscaCof8-PgbpY

q
	string
	q 매개변수는 검색할 검색어를 지정합니다.
		사용 방법 ) API 주소 뒤에 &q=검색하려는검색어 를 쓰면 검색한 내용을 가져옴.
		ex) &q=노래

maxResults
	unsigned integer
	maxResults 매개변수는 결과 집합에 반환해야 하는 최대 항목 수를 지정합니다. 허용값은 0 이상 50 이하입니다. 기본값은 5입니다.
	=> 가져오는 리스트 갯수를 말함.
		사용 방법 ) 가져오려는 API 주소 뒤에 &maxResults=가져오려는갯수 쓰면 갯수만큼 목록을 가져온다.
		ex) &maxResults=20 // 검색어 목록 중 20개를 가져옴

order
	string
	order 매개변수는 API 응답에서 리소스를 지시하는 데 사용할 메소드를 지정합니다. 기본값은 SEARCH_SORT_RELEVANCE입니다.
	=> 정렬 파라미터

	허용값은 다음과 같습니다.
	date ? 리소스를 만든 날짜를 기준으로 최근 항목부터 시간 순서대로 리소스를 정렬합니다.
	rating ? 높은 평가부터 낮은 평가순으로 리소스를 정렬합니다.
	relevance ? 검색 쿼리에 대한 관련성을 기준으로 리소스를 정렬합니다. 이 매개변수의 기본값입니다.
	title ? 제목에 따라 문자순으로 리소스를 정렬합니다.
	videoCount ? 업로드한 동영상 수에 따라 채널을 내림차순으로 정렬합니다.
	viewCount ? 리소스를 조회수가 높은 항목부터 정렬합니다.
	
	사용 방법 ) &order=date

===============================================

JSON 구조 확인 툴 : online json viewer
	구글에서 검색해서 "JSON Editor Online - view, edit and format JSON online" 들어가면 됨.
	북마크 해놓음 ^오^

online json viewer 툴 설명
	ex1) object {6} > 이 object 키는 오브젝트{}로 둘러싸여있고 각각 6개의 키값이 들어있음
	ex2) item [20] > 이 item 키는 어레이[]로 둘러싸여있고 안에는 각각 20개의 키값이 들어있음

===============================================

매개변수는 파라미터라거..

====================
GET
POST
CREATE
DELETE
==
요구사항/화면 주고 그걸 만들어보는 시험.
화면전환기능
===================

시험

200701 수요일 수업 내용 메모

헤더 셋팅


requestQueue = Volley.newRequestQueue(MainActivity.this);
위에거 아래에 Json~ 이거 안 씀
아래거 씀
	StringRequest stringRequest = new StringRequest(
		Request.Method.POST,
		URL,
		new Response.Listener<String>() {
		@오버라이드~~},
		new Resoponse.ErrorListener() {
		@오버라이드~~}
	){
		getH 쓰면 나오는 함수 엔터{
		// 헤더 셋팅 함수
			// 네이버 API의 헤더 셋팅 부분을 여기에 작성한다.
			// 1. 일단 리턴 지움
			// 2. 맵을 리턴해야 하니까 Map<String, String> params = new HashMap<String, String>(); 을 적음
			// 3. 키값, 밸류값을 집어넣음
				// 왼쪽에는 "컨텐트 타입 : ~"에서 : 왼쪽에 있는 걸 복붙하고, 오른쪽에는 appli~부터 ~UTF-8까지를 복붙한다.
				// 네이버 API에 -H라고 적혀있는 것들을 전부 .put()하면 된다.
			params.put(왼쪽,오른쪽);
			params.put(왼쪽,오른쪽);
			params.put(왼쪽,오른쪽);
			// 4. 이것을 리턴한다
			return params;
		}
		// 네이버에 요청할 파라미터 셋팅을 여기에 작성한다.
		getParams 쓰고 나오는 함수 엔터{
			1. 위의 Map~ 맨 위 초기화를 한 줄 가져온다.
			2. 요청변수를 써서 호출한다
			params.put("source","ko");
			params.put("target","zh-CN");
			params.put("text","안녕하세요");
			3. 리턴한다
			return params;
		}
	};
	// 실제로 네트워크로 API 호출(요청)
	requestQueue.add(request);
		// 여기서 요청한 것은 위의 onResponse - response에서 가져올 수 있다.
		// onResponse에서 가져온 response를 로그를 찍으면 데이터를 JSON형식으로 가져오는데, 이걸 분석(복붙 등)해서 가져오면 된다.
			// JSONObject jsonObject = new JSONObject(response);
				// 알트 엔터 -> try/catch 만들기
				// try 안에서 translatedText를 뽑아올 수 있게 된다.
	
	// 문자열로 JSON을 받아오는 클래스 : StringRequest Class
		// 헤더에 데이터를 넣어서 요청하는 방법 중 하나.
			// 다른 방법은 제이슨오브젝트, 제이슨 어레이
		// 문자열로 응답을 받는다는 뜻. 이 문자열을 제이슨으로 바꿔주면 됨.
	// 메서드 : POST로 되어있으므로 Method.POST를 씀.

======================

<<네이버 "파파고연동" 애플리케이션 정보>>
사용할 앱 패키지 주소
	com.tenisme.papago

애플리케이션 정보
	Client ID = sLEyD2Lq0gF6pFUiwkc3
	Client Secret = C_yFJFRAWm

파파고 NMT API 가이드
	curl "https://openapi.naver.com/v1/papago/n2mt" \
	-H "Content-Type: application/x-www-form-urlencoded; charset=UTF-8" \
	-H "X-Naver-Client-Id: sLEyD2Lq0gF6pFUiwkc3" \
	-H "X-Naver-Client-Secret: C_yFJFRAWm" \
	-d "source=ko&target=en&text=만나서 반갑습니다." -v

==============================================

어제 배운 것
리사이클러뷰에 스크롤 달기
1. 선행 : 리사이클러뷰 가져오기 
2. 아래 함수 작성
recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() {
            @Override
            public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) {
                super.onScrollStateChanged(recyclerView, newState);
            }
 
            @Override
            public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
                super.onScrolled(recyclerView, dx, dy);
 
                int lastPosition = ((LinearLayoutManager) recyclerView.getLayoutManager()).findLastCompletelyVisibleItemPosition();
                int totalCount = recyclerView.getAdapter().getItemCount();
 
                if(lastPosition+1 == totalCount){
                    //아이템 추가 ! 입맛에 맞게 설정하시면됩니다.
						// 뭔소린지는 만들어봐야 알 듯.
                }
            }
        });

============================================

목적 : StringRequest 로 데이터 받아오면, 
문자열이므로, 이를 JSON 객체로 Parsing해줘야 한다.

@Override
public void onResponse(String response) {
   if (!response.equals(null)) {
       Log.i("AAA", response);

       try {
           JSONObject jsonObject = new JSONObject(response);
           JSONObject message = jsonObject.getJSONObject("message");
           JSONObject result = message.getJSONObject("result");
           String text = result.getString("translatedText");
           Log.i("AAA", "translatedText : "+ text);
       } catch (JSONException e) {
           e.printStackTrace();
           Log.i("AAA", e.toString());
       }

   } else {
       Log.i("AAA", "Data Null");
   }
}

=======================

깃헙에 실습폴더 URL파일 클릭하면 업로드 링크 나옴.
200702 목요일 수업 내용 메모

Android 개발자 > 문서 > 가이드 > Spinner
	집합에서 하나의 값을 선택할 수 있는 빠른 방법을 제공한다.

7월 8일 평가는 두가지.
	포트폴리오, & (17페이지)문제 해결 시나리오(흐름)를 주면 시나리오 흐름대로 잘 구현했는지를 평가. 시나리오에 맞게 앱을 개발하는 것
	1. 포트폴리오 시험문제 - ★네트워크 통신(파파고로 통신-헤더 셋팅)해서 리사이클러뷰로 표시하는 것을 문제로 낼 것임.
	2. 문제 해결 흐름 시나리오는 시나리오대로 xml 화면 구현만 제대로 하면 됨.

위치 기반 API 사용하기
	관련 프로젝트 : Location 
	구글 맵 검색해서 들어가봄
	거기서 주소 카피해옴
	https://www.google.co.kr/maps/
		@37.053745,125.6553969,5z?hl=ko
		,앞이 위도(Lat), ,뒤가 경도(Lng)
		위 링크에서 37.053745가 위도, 125.6553969가 경도
		더조은컴퓨터 위도경도 따옴(아래)
		@37.5412538,126.8359649
		필요한 경로가 있으면 이렇게 구글 맵에서 따오면 됨.

에뮬레이터 GPS 셋팅하기
	에뮬레이터 들어가기
	왠만하면 테스트는 실제 폰에서. GPS가 잘 찍히는지 봐야하기 때문임.

==========네이버 맵 API 사용하기============

private LocationManager locationManager;
	// 얘를 통해서 폰의 로케이션 서비스를 가져올 수 있음.
private LocationListener locationListener;

// 내 위치를 가져오게 하고 싶을 때
1) locationManager = this.getSystemService(LOCATION_SERVICE);
> 알트 엔터 > 캐스트 > locationManager = (LocationManager) this.getSystemService(LOCATION_SERVICE);
	// 폰의 위치 정보를 담당하는 애가 LOCATION_SERVICE이고, 얘를 LocationManager로 바꿔준 것임.
2) locationListener = new LocationListener() 치면 알아서 오버라이드 함수들 쭉 깔림.
	// 여기서 제일 많이 쓰이는 것은 onLocationChanged(Location location) 임.
		// 폰의 위치가 바뀔 때마다 해주고 싶은 일을 여기에 작성.
		// 안드로이드가 폰의 위치가 바뀔 때마다 이 메소드를 호출한다는 뜻임.
		// 1. 위치가 바뀐 것을 감지해야 하므로, 바뀐 정보를 가져와야 한다.
3) locationManager.requestLocationUpdates(); 작성
	예시) locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 5000, 10,
                locationListener);
4) if(Activity~){여기를} 작성

네이버 클라우드 플랫폼 회원가입 후 지도 네이버 지도 API 사용할 것임.
	가이드센터 > API참조서 > 왼쪽 API가이드를 클릭해서 API 정보를 볼 수 있다.
네이버클라우드 플랫폼
	Access Key ID : HOPaXLpHaw2q4rLk7v4o
	Secret Key : aPV449VOFzLLRJhzZ3lcNGrYRWlsrcogTWPssxnK
네이버 클라우드 플랫폼 콘솔 > 프로덕트/서비스 > ....~)$#
REST API(HTTP형식) - Static Map을 이용할 것임.

Geocoding > 이거는 구글 걸로 사용하는 게 낫다.

"Location" 앱의
	Client ID
		X-NCP-APIGW-API-KEY-ID : ivwktksgpi
	Client Secret
		X-NCP-APIGW-API-KEY : QW3IRJLjkE1trszxs2lmcBMcVuNexpITr9hCx4Nl
	Location 프로젝트에서는 이걸 씀.
	Static Map API의 응답 형식은 Binary(PNG/JPG 이미지 형식) 이므로 Volley와 Glide 라이브러리를 같이 사용한다.

★ &center=127.1054221,37.3591614 // curl의 이 부분이 지도의 중심이 되는 부분으로, 나중에 이 부분에 (실시간으로 변하는)위도, 경도를 붙여 위치를 파악할 수 있게 만들 것이므로 curl 복붙 후 이 부분은 지운다.
	// 센터 앞은 lng(경도), 뒤는 lat(위도)

&level=16 // 화면 확대 정도 0~20까지 가능

w=768&h=1024 // 가로&세로 1~1024까지 가능

==============================================

nearbysearch API를 사용해 내 위치 기반으로 주변 상점 데이터 가져오기
구글은 웹브라우저에서 테스트하기 좋음.

관련 프로젝트 : SearchPlace
프로젝트 ID : searchplace-282106
프로젝트 번호 : 1068244160018

// nearbysearch API를 쓸 때 반드시 써야 하는 필수 파라미터 3가지
&key=API_KEY
	ex) &key=AIzaSyBVQoPwiWgyMt498eq2ObuNhL4KUBNcPls
	// 위 키는 이 프로젝트(앱) 전용 API 키.

&location=
	위치 정보 가져오기 (위도,경도 순서)
	ex) &location=37.544147,126.8357822

&radius=
	장소를 검색할 반경(미터 단위) 정의
	최대 50000m 까지 가능.

// 선택적 매개변수
&type=restaurant
	찾는 장소 지정 - 지원하는 링크(아래)	
	https://developers.google.com/places/web-service/supported_types?hl=ko
	ex) &type=restaurant
	
&keyword=
	특정 검색어 입력받아서 관련 장소 검색 가능

// 이 API는 MaxResult를 설정할 수 없고 무조건 20개로 고정되어 있다.

// 사진 파라미터 요청하기
	기본 주소 : https://maps.googleapis.com/maps/api/place/photo?

사진 요청 파라미터
	photoreference=[photo_reference]

// 나머지 작업은 papago 프로젝트 참고하기200703 금요일 수업 내용 메모

=========  깃허브 사용법 - 깃헙 54번  =================
	백업 기록을 쉽게 남길 수 있다
	나와 상대가 개발한 것을 각각 원하는 버전으로 합칠 수 있다

버전관리 시스템 : Git
Git도 리눅스 개발자가 만들었다.
클라우드 서버 : GitHub
사용할 프로그램 : GitHub Desktop (GUI방식)

깃헙 개인 메인 패이지에서 리포지토리 생성

커밋(Commit) - 버전 만들기(깃발 꽂기)
	버전을 만들 때 알아보기 쉽게 보통 수정한 내용으로 이름을 붙여준다.
	커밋 : 변경사항 덩어리
	커밋을 만드는 시기 :
		의미있는 변동사항을 커밋으로 만들어 저장한다.
		제대로 돌아가는 상태에서 저장해야 한다.
			★버그가 있는 상태에서는 커밋을 하면 안된다.
	어떻게 만드는가 :
		GUI > "커밋" 버튼 클릭
	커밋은 꾸준히 쌓인다.

푸시(Push) - 업로드
	내가 작업한 것을 깃헙 서버 저장소에 올리고 싶을 때.

풀(Pull) - 다운로드, 클론 만들기
	나&남이 작업해 올려놓은(푸시한) 것을 다른 장소에서 풀(가져올)해서 작업할 수 있다.

브랜치(Branch) - 협업(하나를 나눠서 작업)
	한 저장소에서 다른 개발자와 작업하고 싶을 때 만든다.
	원래 하던 작업을 나눠서 할 수 있다.
	공동 작업자끼리 하던 작업을 복사해서 작업하고 합칠 수 있다.
		합친다 : 머지(Merge) - 병합(나눈 것을 합치는 작업)
	합쳤다가 나눴다가 하면서 작업할 수 있다.

풀 리퀘스트 - 병합 요청 편지
	오픈소스 프로젝트에서 주로 사용한다.
	병합하기 전에 리뷰/컨펌을 받을 수 있다.
	참여한 사람들이 코드를 더 좋은 쪽으로 수정하고, 잘 짠 것은 작성 그룹에서 반영(머지)한다.

머지 방법 세가지
	Merge commit(병합 커밋) - 각자 다른 부분을 수정함
	Fast-forward(빨리 감기) - 누군가 한 명만 수정함
	Conflict(충돌) - 같은 부분을 수정함
		이 부분이 문제가 된다.
			깃헙이 알아서 골라주지 않으므로 직접 잘 머지해야 한다.
	RE-BASE 기능(명령어?)으로 충돌 없이 머지를 할 수 있다.

포크(Fork) - 권한 관련
	따로 등록하지 않은 사람은 저장소에 푸시할 수 없다.
	푸시 권한이 없을 땐 저장소 전체를 포크로 복제하고 커밋+푸시 후 원본 저장소로 풀 리퀘스트를 보낸다.

깃헙에 올라간 상태 : 스테이지 상태
	이걸 올리고 싶으면 커밋을 한다.
		커밋은 서버에 올리는 게 아니라 이정표(like 태그)를 찍는 것이다.
		커밋을 누르면 히스토리로 올라간다.
		서버에 올라간 거 아님.
	오른쪽 위에 퍼블리싱 브랜치 눌러주면 "푸시"가 된다.
		서버에 올라간다는 뜻이다.

===============================================

리사이클러뷰에 스크롤 설정하기 템플릿(리스트 페이징)
recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() {
            @Override
            public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) {
                super.onScrollStateChanged(recyclerView, newState);
            }
 
            @Override
            public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
                super.onScrolled(recyclerView, dx, dy);
 
                int lastPosition = ((LinearLayoutManager) recyclerView.getLayoutManager()).findLastCompletelyVisibleItemPosition();
                int totalCount = recyclerView.getAdapter().getItemCount();
 
                if(lastPosition+1 == totalCount){
                    //아이템 추가 ! 입맛에 맞게 설정하시면됩니다.
                }
            }
        });
200706 월요일 수업 내용 메모

=== 구글맵 구현하기 ===
1. 프로젝트 생성시 구글맵 액티비티 만들기
2. 링크 타고 들어가서 API 만들고 키 카피
3. 붙여넣기
4. 메인액티비티로 감 > 구글맵을 화면에 표현하고 싶으면 implements OnMapReadyCallback 이걸 만들어야 한다.
이 함수도 구현을 해줘야 한다.
@Override
    public void onMapReady(GoogleMap googleMap)
	위 함수에서 처음에 어디를 띄울지 결정한다.
안드로이드가 미리 준비해준 구글맵.
	안드로이드가 맵이 준비되고나서 처음 실행할 때 이걸 딱 실행시킨다.

역 물방울 모양 명칭 : 마커

1. 리스트를 누르면 새로운 지도 액티비티가 뜸.
	그 리스트 위치를 중심으로 마커가 가운데에 딱 뜸.

2. 지도 버튼을 액션바에 만든다.
	이 버튼을 누르면, 검색한 위치들이 전부 내 위치를 중심으로 마커를 붙여서 뜨게 한다.

깃헙 55번 실습

.svg > 벡터 이미지

// 시험
	네트워크에 데이터 요청해서 받아와서 리사이클러뷰에 요청해서 표시하는 것 나옴200707 화요일 수업 내용 메모

firestore에 저장하기(firebase)
	구글거.
	실시간 인터랙션 앱 개발을 위해 파이어베이스를 사용한다.
	ex) 실시간 쌍방 통신 앱
	파이어베이스를 이용해서 할 수 있는 것
		DB 설치 안하고 이용 가능.
			DB 이름 : 파이어스토어 (서버)
			문서 일일 각각 2M(약 2만글자)씩 읽고 쓰고가 무료
			한 글자 2바이트이므로, 하루 1만글자까지만 되는 거 유의.
			NoSQL
				저장 방식이 좀 다름. 테이블 조인이 없음.
				컬렉션 > 도큐먼트(키/밸류)로 저장
					컬렉션에 데이터를 저장함. 저장한 데이터를 도큐먼트라고 함. 도큐먼트는 키/밸류로 이루어짐.
					테이블을 만든다는 개념은 없지만 컬렉션을 테이블이라고 생각하면 됨.
				create table이 필요없음.
			json과 호환성이 좋음.
		API 호출/처리 기능
		API 인증(node.js) 백엔드 개발자는 이거 모르면 안됨.
		분석 : 앱 사용자 분석 데이터 제공해줌.
		버그 리포트
		푸시 알림 기능 : 서버에서 보냄. 서버를 할 줄 알아야 푸시도 쓸 수 있음.

안드로이드에서 firestore 설정하기
구글에서 firestore 검색
안드에서 새 프로젝트 작성함 : FireBase
작성한 프로젝트를 파이어스토어에 등록시킴
	콘솔에 프로젝트 자동 등록시키기
	안드 > 툴즈 > 파이어베이스 클릭 > 어시스턴트 창에 파이어베이스 창 뜸 > firebase 클릭 > connect to firebase 클릭 > 알아서 연결됨 > 프로젝트 추가(만들기) > 알아서 프로젝트 이름 뜸 > ~~~ > 2번 진행~~ > 

프로젝트 ID : firestore-88542

firebase 사용을 위해 gradle에 등록해야 하는 것(4가지)
android {
	defaultConfig {
        multiDexEnabled true // minSdkVersion 21 이상이면 이 코드 필요없음
    }
}

apply plugin: 'com.google.gms.google-services'

dependencies {
	implementation 'com.google.firebase:firebase-analytics:17.4.3'
    implementation 'com.google.firebase:firebase-firestore:21.4.3'
    implementation 'com.google.firebase:firebase-core:17.0.0'
}

안드 프로젝트 만들고 나서 Analytics 먼저 설정하고 다음이 파이어베이스 설정.

지금은 화면구현중. 안드로이드 코드로 DB 데이터 불러오는 작업중.

프로젝트 실습 CloudContacts

recreate();
별로인 듯 이거.

=======================  200708 수요일 수업 내용 메모

통신은 무조건 JSON(JSON쿼리)

다음주 월요일 시험(깃헙 07_데이터베이스구현)
	[1]데이터베이스 요구사항과 DBMS 선정 기준
		DBMS는 한 번 고르면 바꾸기(마이그레이션) 힘드므로 선택은 신중하게 한다.
		<표 1-1 일반적인 DBMS 선정 기준>
			보통 금융과 관련된 곳은 Oracle을 쓴다.
			회사에서는 보통 Aurora를 쓴다. 모바일 회사는 fireStore도 잘 쓴다.

우리가 쓸 거는 AWS의 RDS랑 EC2.

큰그림 - 서버쪽 개발은 이렇게 한다!
	내컴(Local)에서 비주얼스튜디오(node.js 쓰려고)를 설치함
	node.js <-SQL-> RDS
	node.js가 잘 돌아가면 이걸 깃헙에 올림
	깃헙을 EC2와 연결?
	이용자들은 EC2(웹서버)로 접속하고, EC2에 등록된 node.js문이 실행된다.

Android/07_데이터베이스구현/Back-end 개발 환경 설정.pdf

SQL 활용 배우기 시작함.
	이 범위는 객관식, 단답형으로 시험 볼 거임.

필요한 기능을 가진 함수, 클래스, 인터페이스를 직접 짜서 써먹을 줄 알기.

=======================  200709 목요일 수업 내용 메모

인터프린터 - cmd에서 서버 작업하는 거?

서버는 화면이 없음. 코드가 잘 적혔는지 알려면 로그 찍어서 확인해야 함.

웹 API가 작동하는 방식
	유저 <-Full Dom : URL-> 클라이언트 앱 <-Data(JSON) : URL-> 웹 서버 <--> 웹 API <-Fetch Data-> Data
	
백엔드 : Client, Network, Webservers, API Apps
	유저가 URL을 치면 해당 URL(코드)가 동작할 수 있도록 개발을 해주는 것이 백엔드 개발자임.

우리가 사용할 통신 규약 : HTTP
	HTTP : HyperText Transfer Protocol

=====================================  REST API

Request / Response
	Request(요청 방식)
		Http "Get" Request
			데이터를 가져오기만 할 때.
		Http "Post" Request
			클라이언트가 서버쪽에 데이터를 전달해줘야 할 때??
		Http "Put" Request
			데이터 교체, 업데이트 할 때.
		Http "Delete" Request
			데이터를 지울 때.
	Response
		Types of Response Formats
			JSON / XML
			possible - Plain Text
			not possible - image file

Client <-Response : Request-> Webserver(Application - node.js)

SQL - CRUD

.js > javascript 파일

자바스크립트에서 문자열을 표현할 때는 ' '나 " " 둘 다 사용해도 된다.
자바스크립트에서 문장 마침 세미콜론;은 찍어도 되고 안 찍어도 된다.

터미널 in 비주얼 스튜디오 코드
	명령어(파일 실행 방법)
		node .\node_test\hello.js
			이 폴더의 node_test 폴더의 hello.js 파일을 연다
		console.log("Welcome to the class");
		console.log("Hello");
		console.log(20+30);
		console.log("come"+"home");
		console.log(20+"hello"+100);
			이 javascript 코드의 터미널 결과물
				Welcome to the class
				Hello
				50
				comehome
				20hello100

자바스크립트 연산자
	+
		숫자일 때는 더하기
		문자열일 때는 문자열 붙이기
	-
		빼기
	*
		곱셈
	**
		승(제곱)
		ex) a ** 3 => a의 3승
	비교연산자
		==
		!=
		>
		>=
		<
		<=
	논리연산자
		&& => and연산자
		|| => or연산자
	★ ++a
		+1을 먼저 하고 저장은 나중에
			ex) // result = ++a; // a에 1을 먼저 더하고(a = a+1), a를 result에 저장하는(result = a) 작업을 수행한다 (더하기를 먼저 해라!)
			// console.log("a = "+a);
			// console.log("result = "+result);
			결과값
				a = 76
				result = 76
	★ a++
		저장을 먼저 하고 +1을 나중에
			ex) // result = a++; // a를 result에 먼저 저장하고(result = a), a는 a에 +1 더하는(a = a+1) 작업을 수행한다
			// console.log("result = "+result);
			// console.log("a = "+a);
			결과값
				result = 75
				a = 76
	★ --a
		-1을 먼저 하고 저장은 나중에
	★ a--
		저장을 먼저 하고 -1을 나중에
			ex) // result = b--; // b를 result에 저장하고(result = b), b는 b에 -1 빼는(b = b-1) 작업을 수행한다
			// console.log("result = "+result);
			// console.log("b = "+b);
			결과값
				result = 20
				b = 19

// 고등어 1마리에 3000원 => 사람의 언어
// "고등어" 1 "마리에" 3000 "원" => 컴퓨터의 언어
	// 컴퓨터는 데이터 타입을 분류해 작업을 처리한다.

변수 : "데이터"를 메모리에 저장하는 것
	데이터란?
		숫자, 문자, true/false
			node.js(javascript)에서 데이터 타입의 종류는 위 세개.

프로그래밍 : 사람의 언어를 컴퓨터가 이해해서 행동할 수 있게 사람의 언어를 번역해서 작성하는 것.

자바스크립트의 변수 선언/초기화
	(옛날타입) var 변수 = 값;
		ex) var price = 3000;
		var로 선언된 변수를 "글로벌 변수"라고 한다.
	(요즘타입) let 변수 = 값;
		ex) let price = 3000;
		let으로 선언하면 메모리 낭비를 막을 수 있다.
	사실 var나 let을 앞에 적지 않고도 변수 선언/초기화를 할 수 있다.
		다만 이렇게 쓰면 오류가 많이 나기 때문에, 되도록이면 앞에 var나 let을 써준다.

자바스크립트 로그 찍기
	console.log(내용);
		ex) console.log(20+"hello"+100);

문제 1
	넓이와 둘레길이를 구하는 코드를 만드세요. a는 11, b는 7일 때의 넓이와 둘레의 길이를 구하세요.
	넓이(area) 구하기 : a*b
	둘레(perimeter) 구하기 : 2*(a+b)

문제2
	a의 길이가 20으로 주어졌을 때, 표면적(area)와 부피(volume)을 구하세요
	표면적(area) 구하기 : 6a^2(제곱)
	부피(volume) 구하기 : a^3(3제곱)

문제3
	현재 속도가 90km/h다. 이를 mp/h로 계산하는 코드를 작성하세요.
	mph = 0.6214*kmh

node.js
	자바스크립트라는 프로그래밍 언어로 짠(만든, 동작하게 만든) "프레임워크".
	node.js에서 사용하는 언어는 자바스크립트.
	프론트엔드에서도 자바스크립트를 쓰기 때문에, 기업들은 node.js와 프론트엔드를(자바스크립트 코드를) 쓰고, 자바스크립트를 할 수 있는 사람을 찾는다.

undefined
	예시 설명
		let sky;
		console.log(sky);
		// 위 코드는 실행되지 않음.
		// error code : undefined => 선언은 되어있는데 데이터가 할당되어있지 않다(초기화가 되어있지 않다, 값을 저장하지 않았다)는 뜻임.

		let ground = "";
		console.log(ground);
		// 위 코드는 undefined가 아님.

문제4(true or false)
	a에는 3을 저장하고, b에는 7을 저장하고,
	c에는 9를 저장하고, d에는 10을 저장한다.
	다음 식을 작성하자.
	1. a는 5보다 크고, b는 8보다 작은가
	2. c가 7보다 크거나, d가 5보다 작은가

=====================================  아마존 rds

다중 AZ 배포
	프리 티어에서는 못 씀. 다국적 앱을 만들 경우 필수적.

개발용 DB, 서비스용 DB를 따로 두고 쓴다.

엔드포인트로 DB 접근 가능
	aws-mysql 엔드포인트 : aws-mysql.c8urw0tytlbj.ap-northeast-2.rds.amazonaws.com

워크벤치 접속시 Host name에 위의 엔드포인트를 입력하면 됨.

루트 유저로 엔드 유저를 만들어서, 엔드 유저 계정으로 루트 유저와 같은 rds에 접속하는 커넥션을 생성한다.
	엔드 유저는 my_test라는 database에만 접속할 수 있는 권한을 얻었기 때문에, 엔드 유저로 접속하면 my_test라는 database만 떠 있게 된다.

=====================================  실습 내용
=====
in workbench
DB만들기~엔드유저생성/권한주기
=====

# db 만들기
create database my_test
default character set utf8
default collate utf8_general_ci;

# database에 접속할 수 있는 유저 생성
# my_test 데이터베이스에만 접속할 수 있는 "유저 생성"
create user 'node_user'@'%' identified by '비밀번호';
	# 어디서든 원격 접속이 가능한 node_user라는 user를 만들고 identified by로 비밀번호를 부여한다
		# '유저아이디' 이름의 엔드 유저를 만들고 '접속가능경로'를 통해 접속이 가능하도록 설정한다 : '유저아이디'@'접속가능경로'
			# '유저아이디'@'%' => 이 유저 아이디는 '원격' 접속이 가능

# 유저 권한 설정
grant all on my_test.* to 'node_user'@'%';
	# node_user라는 엔드 유저는 원격 접속('%')을 통해 my_test db에 접속해 모든 테이블(.*)에서 모든 작업(all)을 할 수 있음. "db를 새로 만들거나 할 수는 없음."
	# db/테이블에서 실행 가능한 작업 권한 부여하기 : grant 가능한작업
		# grant all => 모든 작업(CRUD) 가능
    # 접속 가능한 db 설정하기 : on 데이터베이스.테이블 '데이터베이스'의 '테이블'에 접속 가능.
		# *은 모든 DB, .*은 모든 테이블을 의미함.
    # 권한을 줄 유저 설정하기 : to '유저아이디'@'접속가능경로'

=====================================  실습내용2
=====
in workbench
엔드유저로 접속해서 작업하기
=====

# node_user로 접속함
# 
create database node_db
default character set utf8
default collate utf8_general_ci;
# Error Code: 1044. Access denied for user 'node_user'@'%' to database 'node_db'
# 에러코드 뜨는 게 정상임. 루트가 db 생성 권한을 안 줌.

use my_test;

=====================================  실습내용3
=====
Visual Studio Code
삼항연산자 / 조건문 쓰기 / 함수의 정의&함수의 호출
=====

// 삼항연산자(=단순if문)
console.log(a>b ? 500:900);
console.log("");

// 조건문
if(true){true실행문}else{false실행문}

b = 120;
if(a>b){
    console.log("A가 B보다 크다.");
}else{
    console.log("A가 B보다 작다.");
}
console.log("");

a = 100;
if(a==30){
    console.log("1.");
}else if(a==50){
    console.log("2.");
}else{
    console.log("100.");
}
console.log("");

// 실습문제4
// 1번 학생의 점수가 83점입니다.
// 다음의 조건문을 작성하시오.
// 점수가 0보다 작거나 100보다 크면, "그런 점수 없음" 출력
// 점수가 80 이상이면, "83점은 A학점입니다." 출력
// 점수가 80점 미만이면, "43점은 B학점입니다." 출력
let score = 83;
if(score<0 || score>100){
    console.log("그런 점수 없음.");
}else if(score>=80){
    console.log(score+"점은 A학점입니다.");
}else{
    console.log(score+"점은 B학점입니다.");
}
console.log("");

// 함수(functions)의 정의 방법 1 : 컨벤셔널(오리지널)
function addNum(a, b){ // 스크립터너 : 변수 선언할 때 데이터 타입 안 써도 되는 거?
    let result = a + b;
    return result;
}
// 함수의 사용, 함수의 호출(functions call)
let ret = addNum(3, 4);
// 값 출력
console.log(ret);

// 함수(functions)의 정의 방법 2 : 변수에 함수를 저장해서 사용함.
 let addNum2 = function(a, b){
    let result = a + b;
    return result;
}
console.log("");

ret = addNum2(5, 6);
console.log(ret);
console.log("");

// 함수(functions)의 정의 방법 3 : es6 문법(최신 javascripts문법)
// function을 적지 않고 처리하는 방법이다.
let addNum3 = (a, b) => {
    let result = a + b;
    return result;
}
ret = addNum3(10, 20);
console.log(ret);
console.log("");

객체 : 클래스가 메모리로 올라온 상태

자바스크립트는 클래스(class) 키워드가 있지만 특별히 명시하지는 않는다.

=========================  MySQL 라이브러리 연동
=====
Visual Studio Code
MySQL 라이브러리를 설치하기
=====
Visual Studio Code 터미널에 아래 코드를 치고 엔터하면 됨.
npm install mysql

package-lock.json
	뭐 설치했는지 보여줌.

=====
Visual Studio Code
라이브러리 변수 사용 선언 / connection 만들기 / 연결(접속)해서 작성한 쿼리문 실행시키기 / 연결 종료하기 
=====

// 1. 라이브러리 사용을 위해 변수 선언
let mysql = require("mysql");
// require : 설치한 노드 라이브러리 중에서 mysql이라는 라이브러리를 이 파일에서 사용하겠다는 뜻이다.
    // 사용하려면 변수로 꼭 저장을 시켜줘야 한다.
    // 반드시 라이브러리 이름과 변수 이름을 일치시켜준다.

// 2. 워크벤치에서 커넥션을 create 해줄 때처럼 여기서도 connection을 만들어준다.
// () 안에는 json 형식으로 작성한다.
let connection = mysql.createConnection(
    {
        host : "aws-mysql.c8urw0tytlbj.ap-northeast-2.rds.amazonaws.com", // 접속 경로
        user : "node_user", // 엔드유저이름
        database : "my_test", // database 이름
        password : "비밀번호" // 비밀번호
    }
);

// 3. connection.query : 연결된 db를 사용해 쿼리 실행하기
    // 이 시점부터 연결된 상태가 됨.
    // function(error, results, fields){실행문} : 콜백함수. 쿼리문에 대한 결과를 이 함수 안에서 볼 수 있다.
connection.query("select count(*) from memo", function(error, results, fields){
    console.log(results);
});
// 4. 연결 종료
connection.end(); // 이거 써줘야 서버 연결이 끊김. 불러왔으면 종료를 꼭 해야됨. 이거 열라 중요함.

=======================  200710 금요일 수업 내용 메모
★★★ 이 날 실습한 거에서 시험 나올 예정  ★★★
자바스크립트는 json으로 오브젝트를 처리한다는 게 제일 중요하다.
json에 익숙해지는 것이 중요하다.

=====이론 공부
여기서 시험 거진 다 나옴. 책에 메모 다 해놓음. 나머지 두문제는 오늘 실습한 것들 중에서 2문제 나온댔음.
=====

=====어제 요약

undefined

if문

함수 만드는 방법 3가지

=====

json오브젝트랑 json어레이만 알면 자바스크립트 코드 짜는데 아무 문제가 없다.
json오브젝트, json어레이 "문법"

조건문, 반복문은 로직. 즉 자기 머리에서 나와야 한다.

데이터와 함수는 구분된다.

================================  JSON Object 예시

// json 오브젝트(객체) 생성
let football = {
    color : "Blue", // 이게 멤버변수라고 생각하면 됨. 여기서 "Blue"가 "데이터"
    size : 36, // 키 : 밸류(key : value)
    isActive : true,
    add : (x,y) => {
        let ret = x+y;
        return ret;
    }
} // <- 이 중괄호가 바로 json 오브젝트! 대괄호는 json Array!

let result = football.add(3,4);
console.log(result);
console.log("");

// 위 객체의 멤버변수에 접근하기
let color = football.color;
console.log(color);

위 함수를 자바 코드로 표현하면 아래와 같다.
class Football{
     String color;
     public Football(){
         color = blue;
     }
    int add(int x, int y){
       int ret = x+y;
       return ret;
    }
}

================================  JSON Array 예시

// 단일 데이터 처리(어레이 설명을 위한 예시)
let name = "James";

// JsonArray
    // Array(배열) : 데이터를 "여러개" 저장하기 위해서 사용.
// 이게 핵심임.
let names = [
    "James", // ,(콤마)로 구분
    "John",
    "Michael"
];
// Array 값 가져오기(어레이 데이터에 엑세스)
names[0]; // [0] => 인덱스
names[1];
names[2];

console.log(names[0]);
console.log(names[1]);
console.log(names[2]);

// array 안에 "객체(오브젝트)" 데이터를 여러개 저장하기
let employee = [
    {name : "James", age : 24},
    {name : "John", age : 25},
    {name : "Michael", age : 30}
];

employee[0];
employee[1];
employee[2];

console.log(employee[1]);
// 위 코드의 출력값
// { name: 'John', age: 25 }

// 이 Array의 오브젝트 안의 데이터에 접근하기
employee[0].name;
employee[0].age;

console.log(employee[0].name);
// 위 코드의 출력값
// James

let people = [
    {name : "Mike", age : 24, 
        pet : [
            {name : "A", type : "cat"},
            {name : "B", type : "dog"}
        ]}, // 앞의 오브젝트는 1명에 대한 데이터
    {name : "John", age : 30, 
        pet : [
            {name : "C", type : "cat"},
            {name : "D", type : "dog"}
        ]},
    {name : "Harry", age : 29, pet : []}
]
console.log(people[0]);
console.log("");
// 위 코드의 출력값
// { name: 'Mike', age: 24, pet: [ 'dog', 'cat' ] }

// 실습문제 1
// 첫번째 사람의 나이를 출력하시오
console.log(people[0].age);
// 두번째 사람의 이름을 출력하시오
console.log(people[1].name);
// 세번째 사람의 pet을 출력하시오
console.log(people[2].pet);
// 첫번째 사람의 첫번째 pet을 출력하시오
console.log(people[0].pet[0]);

// 실습문제 2
// 첫번째 사람의 두번째 pet 이름을 출력하시오
console.log(people[0].pet[1].name);
// 두번째 사람의 첫번째 pet은 어떤 동물인가?
console.log(people[1].pet[0].type);

// ★ 데이터 변경, 추가 ★ (중요)
names = [
    "James", // ,(콤마)로 구분
    "John",
    "Michael"
];
// 실습문제 3
// 두번째 데이터를 Mike로 변경하기
names[1] = "Mike";
console.log(names);
// 출력값
// [ 'James', 'Mike', 'Michael' ]

// Array에 데이터 추가하기
names.push("Chris");
console.log(names);

// 데이터 맨 앞에 추가하기 : unshift()
let arr1 = [1, 2, 3];
arr1.unshift(100);
console.log(arr1);

// ★★★ splice(start, count) - 추출 ★★★
    // start는 인덱스 숫자, count는 가져올 갯수임 주의.
// array에서 원하는 위치부터 데이터를 빼오고 싶을 때 사용하지만, 지우는 것도 가능함.
let arr2 = ["one", "two", "three", "four"];
// 두번째 데이터부터 데이터를 끝까지 가져온다
let ret_arr2 = arr2.splice(1,3);
console.log("arr2 : "+arr2);
console.log("ret_arr2 : "+ret_arr2);
console.log("");
// 맨 앞의 데이터를 지워본다

// Array 데이터 지우기 : 맨 뒤의 원소 삭제하기
names.pop();
console.log(names);

// array의 모든 원소를 하나로 합치기
let ret_names = names.join("-"); // join() 파라미터 영역에 넣는 문자열로 데이터들을 연결해준다
console.log(ret_names);
// 결과값
// James-Mike-Michael

// ★★★ filter(필터) ★★★
let ret_filter = names.filter(name => name.length > 4); // "이름"의 "길이"가 4보다 큰 것만 가져와라.
console.log(ret_filter);

테이블 확인은 워크벤치(GUI)에서 하자.

============================================

워크벤치에서 테스트해보고 잘 되는지 테스트해보고 .js에 쿼리문을 복붙한다.

워크벤치는 디버깅용.

테이블 생성 문제 나옴.
인덱스 생성 문제 나옴??

connect_test.js 좀 더 배움

깃헙 실습 : Node Mysql 실습 1~3

깃헙 sql 데이터 복붙 안하고 Raw 클릭 > 다른 이름으로 저장 > .sql로 저장해서 workbench에서 열어서 바로 등록해도 된다. 

insert 시 완료 메세지 중 중요한 것
affectedRows : 1 << 이게 0이 뜨거나 하면 이상한 것임.
	바꾸려고 시도한? 조회한? row 개수를 알려줌
insertId : 1001 << 이거 핵중요. 아이디값 검색시 매우 잘 쓰임.
	인서트 할 때만 insertId 항목이 뜸.
changed : n << 실제로 바뀐 row 개수를 알려줌
	affectedRows와 changed의 개수가 다를 수 있음.

조회 결과가 여러개일 경우 for문으로 값을 하나씩 불러와서 조회한다.

=======================  200713 월요일 수업 내용 메모

==================================  시험 문제 해설

localhost : 서버 컴으로만 접속 가능
% : 어디서든 원격 접속 가능

DDL : 
	update는 데이터와 관련된 SQL, 즉 DDL이 아니라 DML이다.

이번주 금요일 시험은 SQL.. 이번에 책 나눠준 거.

======================================  수업 내용

깃허브에서 새 리파지토리 생성 : node-mysql

vsc에서 새 리파지토리에서 새 폴더 생성 : js-test

js-test 폴더에서 파일 생성 : app.js

노드 .js 파일 실행하기 명령어 : node 파일명.js
	서버 개발자는 리눅스(터미널) 명령어를 할 줄 알아야 한다.

npm 사이트(npmjs.com) 이동
	npm이란?
		node.js로 작업할 때 필요한 라이브러리(패키지)를 모아놓은 곳.
			노드에서 http 통신할 때 필요한 라이브러리 등등이 있음.
		다양한 라이브러리들이 있다.
	node.js의 모듈을 배울 것임.

npm에서 fs 검색 > 첫번째거 클릭
	fs - Security holding package

npm에서 email validate 검색 > 이메일 체크 라이브러리들이 쭉 나옴

node.js 관련 검색은 구글에서 nodejs 키워드로 검색하면 된다.

nodejs.org은 nodejs 공식페이지.
	라이브러리(모듈) 검색은 npm, 그럼 여기서는..?-? 기본 제공 라이브러리와 API 정보 등을 확인할 수 있음.
		기본 제공 모듈은 nodejs.org에서 검색하고, 기타 오픈소스 모듈 등은 npmjs.com에서 검색해서 찾아 쓰자.

구글에서 writefildsync 검색해서 nodejs.org에서 fs.writefilesync 찾아봄.
	여기서 왼쪽에서 file system 클릭해서 fs.writefildsync 검색해서 클릭해서 API 페이지로 이동함.
	여기서 왼쪽 리스트는 노드의 기본 라이브러리들임.

★★★노드 라이브러리 사용 방법!!!

nodejs에서 파일 하나 만들기
	1) 라이브러리를 노드js에서 불러와야 한다.
	fs 라이브러리 불러와서 사용하는 방법
		const fs = require('fs')
			const(콘스턴트)는 상수 선언이다.
			const : 옛날 문법, 오리지날 문법.
			자바의 import ~와 같다.
				es6 문법으로 자바와 비슷한 문법으로 import할 수 있다.
					es6 npm 모듈 설치해서 써야한다. 이건 나중에 배울 거. 최신 문법. 보통은 require()를 쓴다.
	★★중요한 규칙 : 라이브러리 이름과 상수 이름은 통일시킨다.
	2) fs.writefilesync로 파일을 만든다.

★★★node.js에서는 라이브러리를 "모듈"이라고 부른다.

fs 모듈로 파일에 내용 추가하기 (예시)
	1) fs 모듈 불러오기
	2) try{}catch(err){}의 try 안에서 fs.appendFileSync() 사용하기
try {
    fs.appendFileSync('note.txt', '\n내용추가', 'utf8')
  } catch (err) {
    /* Handle the error */
  }
// note.txt 파일에 \n내용추가를 추가하는데 캐릭터셋은 utf-8로 함. 오류 나면 catch()에서 처리함.

===================  다른 파일에 있는 정보 불러오기 과정

js-test에 새 파일 만들기 : app2.js

내용
const name = 'Andrew'
console.log(name)

js-test에 새 파일 만들기 : utils.js

내용
console.log('util.js called')

app2.js 첫 줄에 ★require('./utils.js')★ 추가
	./ => 현재 디렉토리 안
	../ => 현재의 위에 있는 디렉토리 안

터미널에서 app2.js 실행 결과
util.js called
Andrew

★★★require('')
	파일이나 라이브러리를 불러오는 함수.
	안에 파일 경로나 라이브러리 이름을 적어준다.

가지고 있는 상수/상수 함수를 노출시키기 module.exports = 
	= 다른 파일이 가져다 쓸 수 있도록 하기
	내보내려는 파일에서 아래 코드 작성
	module.exports = 내보낼상수이름
		이렇게 쓰면 다른 파일에서 require()로 이 파일을 불러들인 다음 이 파일이 "노출시킨" 상수를 불러올 수 있다.

=============================================

npm에서 라이브러리 받아서 js-test에 깔기

프로젝트로 만들 폴더를 지정해서 터미널에 npm init 입력 > 엔터엔터엔터
	npm init -y
		-y : 엔터 안 쳐도 됨(전부 yes)
		npm init은 package.json을 만드는 명령어. 새로운 "프로젝트나 패키지를 만들 때" 사용

entry point app.js : app.js를 메인으로 실행시키겠다라는 뜻

디렉토리 하나 단위로 하나의 프로젝트라고 생각하면 됨.
	js-test 안에서 터미널에서 npm init을 침 > js-test가 하나의 노드 프로젝트가 되었다는 뜻임.

npm에서 ★validator★ 검색 > 첫번째 나오는 거에 들어감
	주로 "형식"이 맞는지 알아서 체크해주는 모듈임.
	서버에서 이메일/url 형식을 체크할 때는 이 모듈을 사용.

npm 인스톨 방법
Installation and Usage
	Server-side usage
		Install the library with "npm install(or i) validator"
터미널에 저 명령어 치면 이 라이브러리(모듈)이 설치됨.
패키지를 설치하면 node_modules폴더가 알아서 생성된다. 모듈을 추가하면 이 폴더 안에 알아서 생긴다.

★★★모듈 = 패키지 = 라이브러리★★★

실습 : chalk 패키지 설치해서 라이브러리 보면서 써먹기

=============================================
npm init > mysqljs 설치해서 접속 connection 파일을 만들고 export해서 다른 파일에서 가져다 쓰기
=============================================

새로운 디렉토리 만듦 : mysql-test

새 js파일 만들기 : index.js / mysql_connection.js

이 디렉토리로 이동해서 터미널에서 npm init 해서 npm 설치
	entry point를 mysql_connection.js로 설정함

npm에서x 구글에서 Mysqljs 검색해서 모듈을 찾아서 설치하기
	(mysqljs 즐찾해놓음)
	설치 명령어 npm i mysql

aws에 접속할 connection을 export하시오
	mysql_connection.js에서 aws 연결하는 코드 쓰기
		★상수 처리하기~
		const mysql = require("mysql")

		const connection = mysql.createConnection(
		{
			host : "aws-mysql.c8urw0tytlbj.ap-northeast-2.rds.amazonaws.com",
			user : "node_user",
			password : "패스워드",
			database : "my_test"
		}
		)
	
		module.exports = connection
		// mysql 패키지 불러온 거는 파일 불러올 때 알아서 실행되니까 connection에 알아서 적용되어 있어서 굳이 mysql은 안 불러오고 커넥션 함수만 가져다 써도 되는 건가.

export한 데이터를 index.js파일에서 사용하기
	const connection = require('./mysql_connection.js')
	끝.

connection.end()해서 접속 끊어주고 저장하고 테스트해보기

끝

===================  깃헙 실습 : Node Mysql 실습 3 풀이

-- 실습문제 2 자주 씀.
select concat(substring(title, 1, 10), "...") as "short title" from books;

-- 실습문제 4 ★이거 중요 : char_length()★ 시험 예상 ^.^
select title, char_length(title) as "character count" from books;

나중에 서버에서 페이징 처리할 때 SQL문에서 limit 써먹음.

node ~.js의 실행 결과는 json으로 가져온다.

=============================  node - mysql 실습 4

200713.sql / node-mysql\mysql-test\index.js 참고

어떤 테이블이든 왠만하면 id(not null auto_increment primary key) 컬럼을 넣어서 쓰는 게 좋다.

foreign key가 추가된 테이블은 연관된 id 키가 이상하게 입력되어 저장되는 것을 방지해준다.

그냥 평범한 join할 때는 맨 왼쪽에 배치하는 컬럼을 먼저 써주는 게 국룰..? ?_? 아무 상관없나

-- 실습문제 3 ★중요 문법 : ifnull() 실무에서 많이 씀★
select s.first_name as first_name, ifnull(p.title, "MISSING") as title, ifnull(p.grade, "0") as grade
from students as s left join papers as p on s.id = p.student_id order by s.id;

★★★컬럼 이름은 되도록이면 as ~ 로 줘야 나중에 안드로이드에서 json 파싱할 때 키값 가져오기가 매우 편하다.

======================================  기타 메모

책 받는 날 : 7/17 & 7/24

인터넷에 널려있는 정보들 잘 찾아서 쓰깅.

서버 개발자는 항상 워크벤치를 켜놓고 서버 상태를 보면서 개발한다.

터미널 강제 빠져나오기는 Ctrl+C 잊지말깅

내일은 http로 남의 api json으로 가져와서 우리 database에 저장하는 거 실습할 것임.

"공백" 문자열 개수에 포함되는 거 잊지 말기.

결과가 여러개로 돌아오는 것은 되도록 for 루프 써서 가져오기.

SQL문 여태 배운 거 마스터하기. 잘 쓸줄 알아야한다.

무조건 직접 실습 복습 타이핑 디버깅~!

안드로이드도 클라이언트으으

======================================  수업 요약

mysql 모듈 설치하기 전에 무조건
npm init 명령어로 초기화 시켜주기!!
설치한 모듈을 require()해서 사용할 수 있다.
AWS 접속 커넥션 파일을 하나 만들고 다른 데에서 require해서 사용한다.
	언제든지 다른 파일에서 이 파일을 호출해서 사용(접속) 가능!
	실무에서도 이렇게 쓴다.

=======================  200714 화요일 수업 내용 메모

==============================  SQL 활용 이론+실습

==========================  깃헙 node - mysql 실습 5

==========================  새 실습 폴더명 - weather

날씨 정보 API 가져다가 호출할 것임.
nodejs로 날씨 정보 받아와서 DB에 집어넣을 거임.

google에 weatherstack 검색 - 첫번째 클릭
	무료도 있고 라이센스도 있고 구럼.

observation_time : utc 기준 시간 표시
humidity : 습도 표시
cloudcover : 구름 낀 정도
feelslike : 체감온도

npm init -y 하시거

http 통신 가능하게 하는 라이브러리 설치할 거임.
npm 에서 postman-request 검색
	postman-request : Request - Simplified HTTP client
설치 명령어 : npm i postman-request

폴더에 app.js파일 만듦.
	mainactivity.java와 같은 것임.

구글에 HTTP status code 검색해봄.
서버 개발할 때는 HTTP 상태 코드를 보면서 개발한다.
	200 : 성공
	400 : 잘못된 요청
	401 : 권한 없음
	404 : 페이지 없음

// postman-request 기본 사용 포맷(json으로 가져오기)
request.get({url : 'http주소', json : true}, function (error, response, body) {
	if(error != null){console.log('error: '+error)}
    console.log('status code: '+response.statusCode)
    console.log('status: '+body.status)
}) // 안드로이드의 volley 라이브러리 사용과 같음.

==================  Node 실습 6 - 네트워크 데이터와 DB

-----  ★★★★★★★★★★★실습 목적(에 작업 방법 추가함)

1. 새폴더명 employee
	안에 app.js 만듦
2. NPM 수행 방법
	vsc 터미널에서 작업 - npm init
3. 서버에서 네트워크 데이터 호출 방법
	vsc 터미널에서 작업 - npm i postman-request
4. 데이터베이스 테이블 설계
	워크벤치에서 작업 - create table();
	mysql 모듈 설치 : vsc 터미널에서 작업 - npm i mysql
5. JSON 처리
	vsc의 app.js에서 작업 - postman-request 모듈을 사용해서 api 링크를 json으로 가져옴
6. Node 에서 DB 접속 처리
	vsc의 app.js에서 작업 - 기존에 만들었던 mysql_connection.js 파일을 가져와서 DB에 접속(aws DB서버에 일반유저로 접속함)
7. Node 에서 데이터 저장
	7-1. 인터넷 접속을 위해 postman-request 모듈을 추가
	7-2. api에서 json으로 파싱한 다음
	7-3. 쿼리문에 하나씩 데이터를 추가하고 그 쿼리를 쿼리함수에 담는 for문을 돌린다.
	7-4. i가 끝에 도달하면 connection.end()하는 if문을 for문 안에 추가한다.

-----------------------  Node - 네트워크 데이터와 DB

1. 다음 url 로 API 호출하여 데이터 가지고 와서
	http://dummy.restapiexample.com/api/v1/employees

2. employee_name, 
	employee_age, 
	employee_salary 

	위의 값으로 구성된 employee 테이블을 만들어서, 데이터를 DB에 저장하시오.

---------------------------------------------

=======================  200715 수요일 수업 내용 메모

nodejs로 웹서버 실행시키는 거 할 거임.

mvf 패턴?

===============  Node 실습 6 - 네트워크 데이터와 DB 해설

나중에 postman-request를 쓸 때 자신의 api 서버를 가져오는 건지(만드는 건지?) 남으 api를 가져오는 건지(request) 구분을 명확하게 해서 상수를 만들어야 한다.

---------------------------------------------

자바스크립트니까 json으로 처리하기~
	ex) {url : baseUrl+path, json : true}

request.get({url : baseUrl+path, json : true}, function (error, response, body){ 내용 })
	에서
    // response에는 http 통신을 통해 들어온 전체 데이터를 다 받는다
    // body에는 json 몸통만 들어온다(이걸 쓴다)

insert문을 여러번 쓰면 IO가 커져서 좋지 않다고 한다. 여러 데이터를 추가할 때는 insert문은 한 줄만 써주고 for문을 돌리자.

-------------------  ★nodejs 문자열 처리 방법(new!)★

// 문자열 처리 방법 1 (기존 방법)
// let insert_query = 'insert into employee values (default, "'+name+'", '+salary+', '+age+')'

// ★문자열 처리 방법 2 (새로운 방법) - 이게 더 좋음!★
	// `` <- 이걸 사용한다
		// `는 역슬래시 안 넣고 엔터 쳐도 하나의 문장으로 인식한다
	// ${} <- 이것도 사용한다
let insert_query = `insert into employee values (default, "${name}", ${salary}, ${age})`
	
connection.query(insert_query, [], function(error, results, fields){
	
	if(error != null){console.log('error: '+error)}
	console.log(results)

})

` 의 명칭 : Backquote, backtick, grave accent
${}의 명칭 : 잘몰겠. 그냥 샵중괄호라고 하자.

---------------------------------------------

반복되는 패턴이 무엇인지 바뀌는 지점이 어디인지 찾는 연습을 해보자.

==================================  SQL 활용 이론

이번주 금요일 시험은 필기시험임

한 컬럼에 프라이머리 키를 만들면 DBMS는 이 컬럼을 자동으로 "인덱스"로 만들어놓는다.

==========================  실습 : geocode 가져오기

네트워크 통신해서 geocode 가져오는 거 할 것임

geocoding 폴더 만듦

★실습 목적(에 작업 방법 추가함) 3번까지 진행함

구글에서 mapbox 검색 - mapbox.com 으로 들어가기

mapbox 가입/로그인
	Access tokens !
		이거랑 api 키 만드는 거 나중에 할 거임. 지금은 아님.

documentation 에서 사용 방법 열람 가능
	geocoding 검색 - API / search service 클릭하면 정보 열람 가능
		일반 주소를 위도/경도로 바꿔주는 것이 geocoding의 기능이다.
		get 방식이다.
		URL-encoded UTF-8
		파라미터설명
			limit - 갯수 제한. 디폴트는 5개, 최대 10개
	기본 주소
		https://api.mapbox.com
	기본 path
		1) 지역이름으로 가져오기
		/geocoding/v5/{endpoint}/{search_text}.json
		{search_text}.json
			지역 적으면 됨 ex)서울, 화곡역
			별다른 파라미터 없이 한글 그냥 적어도 검색됨
		2) 경도, 위도로 가져오기
		/geocoding/v5/{endpoint}/{longitude},{latitude}.json
		{endpoint}
			mapbox.places or mapbox.places-permanent
		{longitude},{latitude}.json
			경도(lng), 위도(lat) 순서임

문제 : 한글이 들어간 주소가 nodejs에서는 실행되지 않음

한글은 유니코드. utf-8로 바꿔줘야 함.

해결책 :
	encodeURI() 함수 사용
		유니코드 > UTF-8
		한글값 검색시 주소를 여기에서 한 번 걸러서 사용하면 된다

참고 : 
	decodeURI()
		UTF-8 > 유니코드

=====  실습 : youtube api로 정보 가져와서 DB 서버에 저장하기

실습 : 유튜브에서 내가 좋아하는 정보를 검색해 디비에 저장하기

폴더 : node-mysql\youtube
작업 한 번에 실행되는 쿼리 함수(.query())가 많으면 좋지 않다.
	커넥션을 연속으로 하는 것보다는 최대한 줄이는 게 좋다.
	즉 for루프 코드 안에 .query()를 넣지 않는 게 좋다.

if(error != null){
	console.log('error: '+error)
	// 에러 뜨면 리턴 넣어줘야 함. 아직 리턴 방법 모름.
}

&order=date << 날짜순 정렬

=============================  웹서버 만들기 할 거임

a.k.a 서버 개발, api 개발, api 만들기

먼저 환경설정을 해줘야 함. 서버(api) 개발을 위해서는 테스트 환경이 필요함.
	테스트 환경으로 제일 좋은 것 : POSTman
		서버 개발을 위한 플랫폼
		api 테스트를 하기 위해 이걸 씀.
	구글에 검색하기.
	Download Postman App 클릭 - 다운로드
	설치함 - google 연동 로그인함

상단 +버튼 눌러서 google api 호출하기
	get 선택하고 https://google.com 치고 send 클릭
		http 프로토콜 호출 방식(RestAPI)을 쓰기 위해 사용할 4가지
			get / post / put / delete
	중간 탭에서 params, headers, body를 많이 쓸 거임.

http 통신 프로토콜은 헤더와 바디로 구성되어있다.
	바디는 내용이 오고, 헤더는 http 통신 프로토콜의 헤더값이다.
		헤더 셋팅은 나중에 필요한 부분만 배울 것.
		나중에 헤더 보는 걸로 시험본단다.

비주얼 스튜디오 추가 셋팅
	깃헙에 뭐뭐 설치해야 하는지 올려놓으셨댔음.
vsc 와서 왼쪽에 extensions(네모 네개)버튼 클릭
1. bracket pair colorizer 검색 > install 버튼 클릭
	코드를 보기 쉽게 만들어준다.
2. ★dotenv 검색 > 설치
	dotenv : db정보 엔드포인트, 유저이름, 비밀번호, db이름을 코드에 그냥 써놓으면 안됨!!! 그 파일을 모아놓을 수 있게 해주고 문법 하이라이팅해주는 것???
3. expressSnippet 검색 > 설치
	expressSnippet : 웹서버랑 통신할 수 있도록 nodejs로 express 서버를 쓴다고..? 자동완성...?
4. JavaScript (ES6) code snippets 검색 > 설치
5. Prettier - Code formatter 검색 > 설치
	Prettier : json 코드를 예쁘게 보이게 해줌.

vsc > 셋팅 > format on save 검색 > 체크박스 체크표시

=======================================  새 실습

server-ex 폴더 만듦

파일 추가 server.js

npm init -y
	노드 프로젝트는 항상 시작을 이렇게.

서버를 내리지 않고 정보 변경할 수 있도록 만들기
	1) 패키지 설치
		nodejs express 구글 검색(정보 검색)
		Express - Node.js 웹 애플리케이션 프레임워크 클릭
			웹 애플리케이션 프레임워크란?
				웹 앱을 만들 수 있는 프레임워크.
		npm에서 express 검색해서 설치
			vsc > 터미널 > npm i express
		npm에서 dotenv 검색해서 설치
			vsc > 터미널 > npm i dotenv
		npm에서 nodemon 검색
			nodemon : 서버 파일 변경하면 서버를 껐다 켜지 않아도 (서버를 내리지 않아도) 코드를 변경하면 파일 변경한 걸 자동으로 알아서 바꿀 수 있도록 해주는 모듈.
			설치 방법
				1. npm install --save-dev nodemon
					한 번 해서 에러나면 같은 문장 함 더 치면 설치됨
				2. node server.js 실행시켜서 서버 다시 실행시키기
	2) 환경 설정 - 200716 목요일에 이어서
		[[1]]

======================================  기타 메모

nodejs로 DB 서버에 insert하는 새로운 3가지 방법
	a.k.a insert 쿼리(문자열) 처리 방법
	\node-mysql\employee\app.js에 있음

=======================  200716 목요일 수업 내용 메모

깃허브에 nodejs책.pdf 올려놓으셨음. 다운로드할 수 있음. 이거 보고 공부하라고 올려놓으심.

프로그래밍은 배우는 순서가 있다.

========================  <Node.js 교과서> 조현영 지음

깃헙 https://github.com/gilbutITbook/006982

서버는 한번만 개발하면 클라이언트는 여러개 만들 수 있다.

웹(브라우저) 프론트엔드 개발자는 html css js를 배운다.

웹브라우저에서만 실행할 수 있었던 것을 컴퓨터, 서버에서 실행할 수 있게 해준 것이 nodejs

노드는 상당히 빠르다.

이벤트 기반(event-driven) : 이벤트가 있을 때 뭘 하겠다.

-------------------

js-test에 파일 하나 만들어서 test.js 책 23페이지 실습함

function first() {
  // 함수의 정의
  second();
  console.log("첫번째");
}
function second() {
  third();
  console.log("두번째");
}
function third() {
  console.log("세번째");
}
first(); // 함수의 호출

의 실행 결과
	세번째
	두번째
	첫번째

--------------------

// ★non-blocking I/O 의 예시★ - test2.js

function run() {
  console.log("3초 후 실행");
}
console.log("시작");
setTimeout(run, 3000); // 3000밀리세컨 - 3초
console.log("끝");

실행 결과
	시작
	끝
	3초 후 실행

---------------------

2.1.6 프로미스 실습 - test3.js
일단은 이런 게 있다고 알아만 두기.

---------------------

async/await 실습 - 79페이지 - test4.js

---------------------

test5.js

url 파싱하기

const url = require("url");
const queryString = require("querystring");

const parsedUrl = url.parse(
  "https://www.gilbut.co.kr/?page=3&limit=10&category=nodejs&category=javascript"
); // url의 쿼리 부분(? 뒤) 문자열만 가져오는 함수
const query = queryString.parse(parsedUrl.query);
console.log("queryString.parse():", query);
console.log("queryString.stringify():", queryString.stringify(query)); // json에 stringify를 하면 json을 문자열로 보여준다.

실행결과
queryString.parse(): [Object: null prototype] {
  page: '3',
  limit: '10',
  category: [ 'nodejs', 'javascript' ]
}
queryString.stringify(): page=3&limit=10&category=nodejs&category=javascript

---------------------------------------

package.json에서 아래 문장을 지우고 새로 씀
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node server.js"
  },
이렇게 새로 씀
  "scripts": {
    "start": "NODE_ENV=production node server", // 상용 (production)서버는 이렇게 실행해라.
    "dev": "nodemon server" // 개발(자)모드. 개발 서버는 이렇게 실행시켜라. 명령어를 적어준 것과 같음.
  },
  node server / nodemon server

"author": "" // 제작자 이름 적으면 됨.

저장.

config 폴더 만듦
이 폴더 안에 config.env 파일 만듦
이 내용 입력함
---------------------------------
	// 환경에 대한 정보를 여기다 추가할 것임
	NODE_ENV = development; // 개발(developnemt) 모드라는 뜻
	PORT = 5000;
---------------------------------
여기에 나중에 접속 경로를 추가할 것임.

server.js로 감 - [[1]]과 연결됨
아래를 적음
-------------------------------------
// express : 웹 서버를 동작시키는 프레임워크
const express = require("express");
const dotenv = require("dotenv"); // config.js를 가져올 수 있게 해주는 모듈

// 환경 설정 파일의 내용을 로딩한다.
dotenv.config({ path: "./config/config.env" }); // config.js 파일을 여기에 불러옴

// 웹서버 프레임워크인 익스프레스를 가져온다.
const app = express();

// 환경설정 파일인 config.env 파일에 있는 내용을 불러오는 방법.
const PORT = process.env.PORT || 5000;

app.listen(PORT, () => {
  console.log(`Server running in ${process.env.NODE_ENV} mode on port ${PORT}`);
});

--------------------------------------

입력하고 저장하고 터미널에 명령어 npm run dev 입력
	(웹서버 실행 명령어임)
	npm run dev
		npm run : 실행하라
		dev : package.json 의 scripts의 "dev" 키값을 실행해라
			"dev" : nodemon server라고 적혀있으므로
			npm run dev = npm run nodemon server와 같다

여기서 에러나면 설정해줘야됨.
	깃허브 "API Server 개발 환경 셋팅" 참고
	dotenv 는 환경설정 파일을 놓을 수 있는 패키지다.
	# 윈도우즈에서 nodemon 실패하면, 다음처럼.하라.
	https://docs.google.com/presentation/d/1ogZK7WJYohnJVx5puxnM_Q78uGQ2GItgxgLs6BYD49Y/edit#slide=id.g8bff158ef0_0_103
	1) windows powershell을 관리자 권한으로 실행함.
	2) Set-ExecutionPolicy Unrestricted 실행 - Y 치고 엔터
	3) 터미널에서 npm i -D nodemon 쳐서 설치

구래도 안됨.. 구글에 win10 nodejs nodemon Error: listen EACCES: permission denied 검색해봄

해결함 .env 숫자 옆에 ;이 붙어있어서 안 됐었던 것임.

npm run start 해봄. 안 되는 게 정상임.
	"start": "NODE_ENV=production node server"에서 node 앞을 지워줘야 하는데 아직 안 지울 거임. 나중에 수정한다고 하셨음.

깃헙에 쓸데없는 파일을 올리지 말아라, 하는 방법.
	해당 폴더에 파일 만들기 .gitignore
		"여기 적힌 디렉토리/파일은 깃헙에 올리지 말라"는 뜻이다.
	파일에 적은 내용 예시
		node_modules/
		config/config.env
		기존에 올렸었으면 이그노어 해서 푸시해도 안 없어짐 주의.

postman 실행함
localhost:5000 적고 send

server.js에서 다시 편집
-----------------------------
// 각 경로별로 데이터를 가져올 수 있도록 router를 셋팅한다.
app.get("/", (req, res) => {
  res.send("Hello from express");
});
------------------------------
"/" 여기에는 path를 적는다.
	.com 뒤가 path다.
req,res : request(받는다), response(보낸다)의 줄임말

이제 json으로 "보낼" 것임. > api 서버 만들기가 됨. 여기가 body 부분임.
-----------------------------
// 각 경로별로 데이터를 가져올 수 있도록 router를 셋팅한다.
app.get("/", (req, res) => {
	res.status(200).json({ name: "홍길동", age: 24 });
});
------------------------------

401코드 : 로그인 안 하고 사용하려고 할 때 이 에러코드를 보냄.
	http 상태 코드를 어떻게 셋팅하는가. res.status(여기).json();에 리퀘스트 코드를 적으면 그 코드를 보낸다.(그 코드 상태가 된다)

localhost:5000에 path를 붙여준다.
	ex) localhost:5000/api/v1/bootcamps

// "클라이언트가 get으로 요청한다"
app.get("/api/v1/bootcamps/:id", (req, res) => {})
	:id 변경되어서 오는 값을 받는다고 쓸 때는 변수 id앞에 :를 적어주면 된다.
	그리고 이 변수는 {}안에서 "req.params.변수"로 호출할 수 있다.

========================  ★★★nodejs 서버 연결 정리

0. 환경설정
	0-0. 필요한 npm 설치
		npm init
		npm i -D nodemon
		
		npm i express
		npm i dotenv
		옵션 npm : npm i mysql
		아래처럼 합쳐서 써도 됨
			npm i express dotenv mysql
		
	0-1. pakage.json 파일 수정
		  "scripts": {
				"start": "node server",
				"dev": "nodemon server"
		  },
	0-2. config 폴더/ ~.env 환경설정 파일 만들기.
	0-3. routes 폴더/ ~.js 라우터 파일 만들기.
1. 패키지.json 셋팅
	"scripts": {
    "start": "node server",
    "dev": "nodemon server"
  }
2. config.env 설정
	NODE_ENV = development
	PORT = 5000
3. 라우터 파일을 기본 셋팅한다
	const express = require("express");
	// const { 함수1, 함수2, 함수3, 함수4 } = require(../controllers/~.js)
	const router = express.Router();
	// router.route("/").get(함수1).post(함수2).put(함수3).delete(함수4)
	module.exports = router;
3. server.js에서 express(웹프레임워크)와 dotenv를 불러온다.
	const express = require("express");
	const dotenv = require("dotenv");
4. 직접 만든 라우터 파일을 가져온다.
	const memos = require("./routes/~.js");
	4-1. 웹서버 "프레임워크"인 익스프레스를 express()로 가져와 app에 저장한다.
		const app = express();
	4-2. body를 파싱할 수 있도록 설정한다
		app.use(express.json());
5. dotenv로 .env파일을 불러온다
	dotenv.config({ path: "./config/config.env" });
6. 라우터 연결 : "사용할 url의 path"와 "라우터 파일"을 아래의 함수로 연결한다.
	app.use("/api/v1/프로젝트명", 라우터변수)
7. 환경설정 파일인 config.env 파일에 있는 내용 중 PORT를 불러와 저장한다.
	const PORT = process.env.PORT || 5000;
	// || 뒤에는 config.env에 저장한 포트 숫자를 똑같이 적는다.
6. express로 listen()함수를 만들어서 포트를 입력해서 서버를 구동시킨다.
	app.listen(PORT, () => {
    console.log(`Server running in ${process.env.NODE_ENV} mode on port ${PORT}`);
  });
7. 라우터 파일을 작성하기 위한 controllers 파일을 작성한다.
	7-0. 선행1 : db 폴더를 만들고 mysql_connection.js 파일을 만든다.(이하 복붙)
		// promise로 개발된 mysql2 패키지를 설치하고 로딩.
		const mysql = require("mysql2");

		// db-config.json에 저장된 중요 정보를 여기서 셋팅.
		const db_config = require("../config/db-config.json");

		// 커넥션 풀(Connection Pool)을 만든다.
		//   풀이 알아서 커넥션 연결을 컨트롤하기 때문에 커넥션 풀을 만든다.
		const pool = mysql.createPool({
		host: db_config.MYSQL_HOST,
		user: db_config.MYSQL_USER,
		password: db_config.DB_PASSWD,
		database: db_config.DB_NAME,
		waitForConnections: true,
		connectionLimit: 10,
		});

		// await으로 사용하기 위해 프라미스로 저장. 이렇게 해야 에러 처리 및 유지보수가 쉽다.
		const connection = pool.promise();

		module.exports = connection;

		// 커넥션은 컨트롤러에서 사용함.
	7-0. 선행2 : utils 폴더를 만들고 errorResponse.js 파일을 만든다.(이하 복붙)
		// Error 클래스는, nodejs의 express 패키지에 들어있는 클래스다.
		//   이를 상속하여 에러 처리가 가능하다.
		class ErrorResponse extends Error {
		constructor(message, statusCode) {
		super(message);
		this.statusCode = statusCode;
		}
		}

		module.exports = ErrorResponse;
		// 이것도 컨트롤러에서 처리한다.
	7-1. controllers 폴더 생성, 라우터 파일명과 같은 .js 생성
		7-1-0. db 폴더의 커넥션과 utils 폴더의 에러리스폰스 파일을 가져온다.
			const connection = require("../db/mysql_connection.js");
			const ErrorResponse = require("../utils/errorResponse.js");
		7-1-1. 이 파일 안에, 연결된 프로토콜이 할 행동들을 함수로 적어서 exports 처리한다.
		[작성 양식(예시)]
			// @desc    새로운 정보를 insert
			// @route   POST /api/v1/bootcamps
			// @access  Public
			exports.createBootcamp = async (req, res, next) => {
			  let title = req.body.title;
			  let subject = req.body.subject;
			  let teacher = req.body.teacher;
			  let start_time = req.body.start_time;

			  let query =
				"insert into bootcamp (title, subject, teacher, start_time) values ?";
			  let values = [];
			  values.push([title, subject, teacher, start_time]);

			  try {
				[rows, fields] = await connection.query(query, [values]);
				res.status(200).json({ success: true, user_id: rows.insertId });
				console.log(rows.insertId);
			  } catch (e) {
				next(new ErrorResponse("부트캠프 가져오는데 DB 에러 발생", 500));
			  }
			};
8. 라우터 파일에서 controllers의 함수를 불러온다.
	[작성 양식 예시]
		const {
		  getBootcamps,
		  getBootcamp,
		  createBootcamp,
		  updateBootcamp,
		  deleteBootcamp,
		} = require("../controllers/bootcamps.js");
9. 각 경로별로 데이터를 가져올 수 있도록 router를 셋팅한다.
	[작성 양식 예시]
		router.route("/").get(getMemos).post(createMemo);
		router
		  .route("/:id")
		  .get(getMemo)
		  .put(updateMemo)
		  .delete(deleteMemo);
n. middleware 폴더를 만들어 logger.js 파일과 error.js 파일을 만든다.
	logger.js 파일 셋팅하기
		// next 파라미터 실습
			// 5.5. 로그 찍는 로거 함수를 만든다. // 호출할 때마다 뭘 호출했는지 보여준다.
			const logger = (req, res, next) => {
			  console.log(
				`${req.method} ${req.protocol}://${req.get("host")}${req.originalUrl}`
			  );
			  next(); // ★ app.use(logger) (미들웨어) 밑에 있는 app.use()로 넘어가기 위해서는 next()를 적어야 한다. 적지 않으면 넘어가지 않는다.
			};

			module.exports = logger;
	error.js 파일 셋팅하기
		// 에러가 발생하면, 얘가 전담 처리한다.
		// 이 에러 핸들러가 직접 클라이언트에 에러를 response한다(보낸다).
		const errorHandler = (err, req, res, next) => {
		  res.status(err.statusCode || 500).json({
			success: false,
			error: err.message || "Server Error",
		  });
		};

		module.exports = errorHandler;
10. 연결해서 잘 접속되는지 postman으로 테스트한다.
	npm run dev

필요한 폴더 총 7개 직접 만드는 거 6개
	config
	- 환경설정 및 보안 내용
		config.env
		db-config.json
	controllers
	- routes의 액션 영역
		프로젝트명.js
		- routes 폴더의 프로젝트명.js와 이어짐
	db
	- db 관련 폴더
		mysql_connection.js
		- db 연결
	middleware
	- 용도에 맞는 미들웨어를 만들어 사용하는 폴더
		error.js
		- 에러 관련 미들웨어(에러 메세지 json 처리)
		logger.js
		- 로그 처리(호출할 때마다 어떤 api를 호출했는지 명시해줌)
	routes
	- 라우터 폴더
		프로젝트명.js
		- ??
	utils
		errorResponse.js
		- 에러를 받는 클래스를 만들어서 controllers에서 사용한다.
비동기로 들어와라? async
이거 다 처리할 때까지 기다려라(다음 거 실행하지 마라) await

=============================================

보통 폴더를 만들어서 라우터(함수)들을 분리해놓는다.
routes 폴더 만듦 > bootcamps.js 만듦

라우터의 액션들을 빼서 컨트롤러에 담아놓는다.
	컨트롤러 폴더 > 부트캠프.js 파일 만듦

next 파라미터는 미들 웨어랑 관련이 있다.
아래 내용 이해 잘 안 가니까 어케 검색해보고 뭐.. 해보기
--------------------------------------------
// next 파라미터 실습
// 5.5. 로그 찍는 로거 함수를 만든다.
const logger = (req, res, next) => {
  req.hello = "Hello World";
  console.log("미들웨어 실행됨.");
  next();
};
// 미들웨어 연결 : 로거 함수를 express에 연결.
//   express().use(logger)의 위치는 아래의 라우터 연결 전이어야 한다.
app.use(logger);

// 6. 라우터 연결 : "사용할 url의 path"와 "라우터 파일"을 app.use("url의 path", 라우터변수)으로 연결한다. 이걸 여러개 쓸 수 있다.
app.use("/api/v1/bootcamps", bootcamps);
--------------------------------------------

================================  깃헙 node 실습 7

화면 보고 서버를 구성한다. 안드 앱 만드는 게 아니다.

★웹브라우저는 get방식만 호출할 수 있음.

===================================  시험에 대해서

시험범위 깃헙에 올려놓으셨음.
	DDL / DML / DCL
	데이터 사전 테이블이 뭔지.
	뭐가 메타데이터인가. 무엇을 메타데이터라고 하는가.
	인덱스에 대해서.
	뷰
	서브쿼리를 딱 보고 해석해서 서브쿼리를 다른 dml문으로 바꿀 줄 알아야 함.

------------------- 시험범위 깃헙 메모 복붙
DDL : 테이블의 컬럼 변경

DML : 테이블에 데이터 인서트, 데이터 삭제, 데이터 업데이트 , 셀렉트

DCL : 유저 생성과 삭제 ,  권한 설정과 삭제,  트랜잭션 처리

데이터 사전 테이블

메타데이터

인덱스

뷰 

서브 쿼리
--------------------
13문제정도 나옴.

=======================  200717 금요일 수업 내용 메모

================================  깃헙 node 실습 7

nodemon
	개발할 때 사용하는 npm
	저장하면 바로 반영되는 장점.

/:id/:title/:content
	/ 뒤는 path.

WHATWG와 노드의 주소 체계 예시로 용어 설명
	http://localhost:5000/3/hello/nice_to_meet?color=0&
	http:// => 프로토콜
	localhost => 호스트네임 '~.com'까지
	:5000 => "포트번호". 원래는 :80포트를 쓴다. :80포트를 쓰면 포트 번호를 생략해서 쓴다.(암묵적으로 생략하면 :80이라고 알면 됨)
		개발 서버는 포트번호를 명시한다.
	/3~ => pathname(패스네임)
	?color=0& => "쿼리스트링(서치)"
		이 용어를 알아야 서버 개발을 할 수 있다.
	이게 GET방식 처리.

★★★POST방식은 어떻게 데이터를 전달하고 처리하는가.
	post나 put 방식은 데이터를 path 방식으로 받지(req) 않는다.
	post 데이터 전달은 body에 붙인다.

error하면 그냥 return하지 말고 에러메세지 데이터를 또 보내줘야 한다.

res.status().json() => 클라이언트에 "보내는(res)" 것.

파라미터가 뭘 받는지 모르겠으면 consol.log()로 찍어보면 된다.

---

.gitignore 파일 만들어주기

// 라우터 : 해당 주소가 오면 그 주소에 맞는 함수를 실행하시오.
	가 app.get() // 클라이언트에서 get방식으로 보내면(req) 이렇게 응답해라.
	ex) app.get("/api", (req, res) => {
		  res.status(200).json({ title: "API 서버 개발" });
		});
res.send()
	클라이언트에 보낸다(send).

클라이언트가 url로 요청(리퀘스트req) > 서버가 데이터를 응답에다가 보내라(res). 이 때 json으로 res하는 것이 api이다.
	클라이언트 ex) 웹브라우저, Postman
	서버 예시 : express 서버??

postman으로 예시
	send 버튼 클릭 : "요청(req)"

get, post, 등등 : 프로토콜.
	개발자는 데이터를 받아올 때 body{}안은 데이터 노출이 안 딘다

---

post인 경우 path로 데이터를 받아서 보내지 않고, 
	{ "title" : "제목", "comment" : "내용" }처럼 json으로 보낸다.
		위 json을 body라고 하고, post는 json으로 "받는다(req)."
	get은 path 뒤에 '?파라미터'로 설계한다.(바디에 담을 수 없다)
		일반적으로 get은 "쿼리스트링"으로 처리한다.
	post나 put은 바디로 처리한다(바디에 담아서 보낸다).
	(클라이언트 입장에서) 데이터 저장/변경 : post
	(클라이언트 입장에서) 데이터 받기 : get
	
json 작성시 문자열은 큰따옴표로 둘러줘야 한다. 특히 키값은 꼭 따옴표를 둘러주자.

req : 요청
res : 응답
	
// JSON.stringify(req) : req는 json 형식이므로 이 json을 "문자열"로 찍으라고 해주는 함수이다.

postman
	post 프로토콜에서 테스트용 바디 작성
		.post는 body가 있어야 한다.
	body > raw에서 json 바디 작성
		{"title": "새 메모", "comment" : "내용"}
	header 에서 작성
		key : Content-Type > value : application/json 입력
		하고 다시 send하면 돌아올 때 터미널에 json과 application/json이 표시된다.
		
postman에서 collections 만들기
	프로젝트 api 하나당 한 폴더씩 만든다.
	+ 클릭 > 폴더명 입력 > create
	여기에 파일별로 프로토콜 타입과 url 주소를 미리 셋팅해서 저장해놓고 편하게 찾아서 쓸 수 있다.
	폴더 우클릭 > Add request 클릭 > api 주소 이름(별칭) 입력 > create > 우측에서 프로토콜 타입과 api 입력 후 테스트해보고 Save로 저장하면 앞으로 이렇게 셋팅된 상태에서 api를 테스트해볼 수 있다.

---  콜백 펑션에서 바디 불러오기 예시
let title = req.body.title;
let content = req.body.content;

function 함수 = (파라미터) => { 행동 } : 애로우 펑션이라고 함.

======================================  기타 메모

인터페이스(api) 구현 어떻게 설계하는지 다음주에 배움.

시험 관련 규정
	능력단위 평가와 수료는 별개다.
	수료는 80퍼 이상 출석이면 그냥 수료.
	단, 기업체에서 능력단위 평가 성적표를 요구할 수 있음.
	능력단위 평가는 의무사항이지만 시험을 안 본다고 수료가 안 되거나 제적이 되거나 하진 않음.
		시험을 안 봐도 되지만 "안 봤다고 기록이 된다"는 점.
		또 "평가 포기서"도 제출해야 한다.
	★수료증 나갈 때 성적 현황 요청하면 떼줌.

=======================  200720 월요일 수업 내용 메모
  인터페이스(API) 구현 책 받기 전 메모
  pdf15페이지 설계서 확인하기
	인터페이스 설계서
		인터페이스 목록
		데이터 명세 : req에 어떤 데이터를 담아라 res에서 어떤 거를 줘라
			송신 : req
			수신 : res(반환값은 여기에 담아서 보낸다)
		[그림 1-1]
			이걸 제이슨으로 처리한다.
	시스템 인터페이스 설계서
		인터페이스 목록/명세
		상세 기능별 인터페이스 정의서
		[그림 1-2]
	정적, 동적 모형을 통한 인터페이스 설계서
		트랜잭션
			아토믹하다 : 흐름이 통째로 성공하든가 실패하든가. 그 단위를 트랜잭션이라고 함. 중간은 없음. 둘 중에 하나를 처리해야 한다.
			트랜잭션 개념으로 인터페이스를 설계한다.	
		[그림 1-3]
	데이터 정의를 통한 인터페이스 설계서
		이거 실습할 거임.
		★[그림 1-4] 이거 시험 나옴.(인터페이스 명세서를 nodejs에서 그대로 구현하는 거)
	수행 순서
		서버는 받는 거. 받아서 처리하는 게 서버.
			서버는 수신 후 처리.
		클라이언트 : 리퀘스트를 날리는 쪽. 송신/전달
		[그림 1-6]
			외부 모듈/내부 모듈 : 동적 모형
	인터페이스 정의서(중요)는 유지보수를 위해서 작성해야 한다.
		이 다음에 유지보수를 한다.
		서버 개발자는 화면계획서를 보고 인터페이스 개발을 한다.
		★[그림 1-5]★ 시험 예상인강..?
	
======================================  실습 수업

server-ex 폴더에서 실습함.

서버 개발할 때에는 로그 남기는 게 중요하다.

미들웨어 : 라우터한테 넘겨주기 전, 후 뭔가를 하고 싶을 때 app.use()로 쓰는 것
	활용예 : 로그찍기.
	morgan npm 설치함(로깅에 씀)
	npm i morgan

npm 설치하고 morgan 사용해서 로그 찍어보기

mysql2 - 프라미스 버전의 mysql
	promise로 개발된 mysql2 패키지
	npm install --save mysql2
	.createPool()
		connectionLimit:
			커넥션 개수만큼 자동으로 관리를 해준다.
			컨트롤러 함수가 끝나면 알아서 회수를 해간다.
			그거시 createPool 함수. 커넥션 end 함수가 필요없어진다.
	.promise()

sql .query() 사용시 콜백함수는 쿼리 실행 결과를 받아준다.

async
	await이 들어있는 함수 앞에 꼭 써줘야한다.
await
	await에 붙어있는 줄을 다 처리할 때까지 내려가지 말고 기다려라.
	
.js 는 자바스크립트
.json 은 JSON

커넥션 풀 설정(아래 세 줄 추가)
	waitForConnections: true,
	  connectionLimit: 10,
	  queueLimit: 0 // 안 써주면 0이 디폴트임.

try/catch 예시
exports.getBootcamps = async (req, res, next) => {
  // await을 품고 있는 함수는 앞에 async를 써줘야한다.
	  try {
		const [rows, fields] = await connection.query("select * from bootcamp");
		res.status(200).json(rows);
	  } catch (e) {
		res.status(500).jsen(e);
	  }
	};
  // await이 맞으면 아래줄을 실행하고(res를 보내고) 아니면 catch로 보낸다.

바디처리해주기~
	// body 파싱할 수 있도록 설정해주기
		app.use(express.json());

에러처리 전담마크하기
	디폴트로는 없는 경로로 불러오면 json으로 처리하지 않는다.
		이걸 처리하는 방법(견고한 서버 만들기)
			이걸 처리할 미들웨어를 하나 만들기.
				미들 웨어는 next()

★★★데이터를 전부 가지고 와야 그 중에서 골라서 작업할 수 있다는 것을 잊지 말자.

==============================  깃허브 Node 실습 8

====================  ★★★nodejs 서버 연결 정리 ver.2

만든 폴더 : contact
설치한 npm
	npm i express dotenv morgan
	npm i -D nodemon
	npm i --save mysql2

postman-request : 다른 쪽 서버 api 가져올 때 쓰는 거임. 여기서는 필요없음.

1. npm 설치
2. pakage.json 내용 변경
3. config 폴더 만들고 config.env 생성
4. server.js에서 express, dotenv require하기
	4-1. dotenv.config({path:'경로/파일명.env'})
	4-2. const app = express();
		   const PORT = process.env.PORT || 5000;
5. app.listen()으로 연결하기
	[예시]
		app.listen(PORT, () => {
		  console.log(`Server running in ${process.env.NODE_ENV} mode on port ${PORT}`);
		})
6. postman에서 컬렉션/리퀘스트 만들어서 테스트 준비하기
7. 연결 잘 되었는지 테스트 - npm run dev
8. .gitignore 파일 만들어서 깃헙 셋팅하기
	[예시]
		node_modules/
		config/
9. server.js에서 app.get()으로 api 경로(라우터) 추가
	- 라우트 파일 만들기 전 테스트용임
	[예시]
		// 모든 데이터 가져오기
		app.get("/api/v1/contacts", (req,res) => {
		res.status(200).json({ result: "ok" })}
		// 데이터 추가
		app.post("/api/v1/contacts", (req,res) => {
		res.status(200).json({ result: "ok" })}
		// 데이터 수정 - id값은 바디로 받는다
		app.put("/api/v1/contacts", (req,res) => {
		res.status(200).json({ result: "ok" })}
		// 데이터 삭제 - id값은 바디로 받는다
		app.delete("/api/v1/contacts", (req,res) => {
		res.status(200).json({ result: "ok" })}
10. 라우터(router) 폴더 만들고 api이름.js 파일 만들기
	10-1. express와 router 가져오기
		const express = require("express");
		const router = express.Router();
11. 9를 복붙해서 프로젝트명.js에 붙여넣기
	11-1. app을 router로 바꾸기
	11-2. 주소 수정하기
		"/기본주소"를 "/"만 남기거나 필요에 맞게 알맞게 수정
	11-3. module.exports = router;
12. server.js로 가서 아래 추가하기(API 경로 연결)
	const contact = require("./router/contact.js");
	app.use("/api/v1/contacts", contact);
13. 컨트롤러 클래스(폴더) 만들고 프로젝트명.js 파일 만들기
14. 워크벤치에서 테이블 만들고 select, insert문 테스트
16. 컨트롤러 파일에서 필요한 함수 만들기
	- 잘 접속되는지 테스트 해보고 본격적으로 만들도록, 일단 기본 형식만 만들어놓기
	[예시]
		// @desc    모든 주소록 가져오기
		// @route   GET /api/v1/contacts
		exports.getContacts = async (req, res, next) => {
		  res.status(200).json({success : true})
		};
17. 같은 이름의 라우트 파일에서 exports 위의 router.get()~를 다 지우고 컨트롤러를 가지고 옴
	[예시]
		const {getContacts, createContact, updateContact, deleteContact} = require("../controllers/contact.js")
18. 경로(라우트)와 함수를 연결한다
	[예시]
		router.route("/")
		  .get(getContacts)
		  .post(createContact)
		  .put(updateContact)
		  .delete(deleteContact);
19. 연결 잘 되었는지 테스트 - npm run dev
	19-1. 포스트맨에서 리퀘스트 api 페이지들 만들면서 접속 테스트 및 저장하기
20. 로그를 남기는 방법(로깅하기) - 로거 만들기 : 모건 활용
	로그 찍어주는 로거. 미들웨어(app.use()에 추가시키는 것).
	20-1. server.js에서 require('morgan')
	20-2. const app = express(); 밑줄에 로그 먼저 찍어주도록 미들웨어 달아주기
		[예시]
			app.use(morgan("dev"));
21. DB 셋팅
	21-1. config 폴더에 db-config.json 파일 만들기(복붙)
	21-2. db 폴더 만들고 mysql_connection.js 파일 만들기(복붙)
22. 컨트롤러 파일에서 상세 함수 작성
	22-0-1. server.js에서 바디를 파싱(body parser)할 수 있도록 설정하기
		app.use(express.json());
	22-0-2. 커넥션 가져오기(작성, 연결)
		const connection = require("../db/mysql_connection.js");
	22.1. 쿼리문 작성
	- select(get) / insert(post) / update(put) / delete(delete) 작성 (포스트맨-body 활용)
		22.1.1. 포스트맨에서 바디(테스트용) 작성
			[예시]
				{"name" : "하이", "phone" : "010-1212-3434"}
		22.1.2. 바디가 잘 받아지는지 포스트맨을 활용해 테스트하기
			console.log(req.body);
		22.1.3. ★파라미터(/:id) / 바디({"body" : }) / 쿼리(/search?keyword=)에서 데이터 가져오기
			[예시]
				let id = req.params.id; // 파라미터에서 불러오기
				let id = req.body.id; // 바디에서 불러오기
				let id = req.query.id; // 쿼리스트링에서 불러오기
	22-2. 프라미스(async, await)와 try/catch를 사용해 DB 접속문 생성
		let query = "select * from contact";
		try {
			[rows, fields] = await connection.query(query);
		} catch (e) {}
			22-3-1. await(동기)을 품은 함수 앞에 async(비동기) 붙여주기
	22-3. 정상 실행, 실행 에러시 코드 작성
		[예시]
			try {
				[rows, fields] = await connection.query(query);
				console.log(rows)
				res.status(200).json({success : true, items : rows})
			} catch (e) {
				res.status(500).json({success : false, message : "DB ERROR", error : e})
			}
	

=======================  200721 화요일 수업 내용 메모

로그인 기능 api 만들기
인증토큰 만들기

==============================  깃허브 Node 실습 8

커넥션 풀 : 커넥션을 관리해주는 애. 커넥션이 많이 붙으면 느려지기 때문에.

select * from ~.
	req에 데이터는 들어있지만, 클라이언트가 요청하는 데이터는 없다.

정상이면 여기로([rows, fields]) 리턴 받겠다 = 프라미스
	이상이 있으면 catch로 받는다
	프라미스를 사용하기 위해서 mysql2를 쓴다.

status 500 에러내기 : 없는 테이블 이름 적기

★바디로 전달되는 것은 req.body에 담겨져서 들어온다
	바디에 잘 들어오는지는 console.log(req.body);로 테스트

쿼리문을 await으로 받을 때 select에만 rows/fields를 쓰고, 나머지에는 result를 적어주자.
	fields는 rows의 정보를 담고있다.

json 키값 이름은 무조건 큰 따옴표로 둘러싸기!

페이징, 페이지네이션
	한번에 많은 데이터를 한번에 가져오는 것은 여러모로 무리가 있다.
		네트워크 낭비 + 시간 낭비
		속도 저하 및 데이터 용량 소모 많아짐
	데이터를 나눠서 요청하는 것을 페이징, 페이지네이션이라고 한다.
	보통 20~30개씩 가져옴.
	1번째부터 20개까지 보내주고, 그 다음부터는 21번째부터 40개까지 보내주고, ...
	=> 서버는 데이터를 끊어서 보내줘야 한다. = 페이징
		여기서 ~번째는 오프셋(인덱스)이다.
		[페이징 적용 예시]
			/api/v1/contacts?offset=0&limit=20

실습 : select * from contact에 페이징 적용하기

http 메소드 : GET 등등

hostname : localhost 등등


--
이번 주 시험
문제 해결
	서버쪽 nodejs 순서대로 하는 거
	npm 설치, 기본환경 설정 등등
	+ 인터페이스 정의서를 쓰시오 
		=> 기능(가져오기, 생성하기 등) 작성, url 주소 작성, 파라미터 작성
		모든 주소록 가져오기 나옴

==============================  server-ex 폴더 실습

부트캠프 과정에 대한 추가, 수정, 삭제, 조회 << 여태 만든 거
서비스를 이용할 사람들에 대한 정보 처리 << 오늘 할 거
	만들어야 할 서비스
		회원 서비스
			수강 신청/취소/즐겨찾기/즐찾삭제 가능
		비회원 서비스
			수강 열람 가능
	서비스를 이용할 사람들에 대한 정보 처리
		1. 유저의 정보를 저장할 테이블 생성
		2. API 연결 개발
			2.1. routes, controllers 폴더에 users.js 파일 생성
			2.2. server.js에서 users.js 라우터 연결
		3. API 서버에서 테이블을 처리

패스워드를 암호화해야한다.
패스워드 암호화/이메일중복 등은 서버(nodejs)에서 해결하면 됨.
	이메일 체크 npm 패키지 - npm validator 활용
		설치 : npm i validator
		활용 : validator.isEmail(email)
	이메일 중복 해결 방법 1 (추천)
		워크벤치에서 email 컬럼을 유니크(UQ) 컬럼으로 변경
		Error Code: 1062. Duplicate entry 'abc@naver.com' for key 'user.email_UNIQUE'
			중복된 키 입력이다. 라는 에러. DB에러.
	이메일 중복 해결 방법 2
		서버 가서 '정상 이메일 체크' 밑에 중복 체크 코드 작성, 워크벤치 가서 email 인덱스 설정

워크벤치에서 테이블을 만들고 다시 nodejs로 돌아옴

유저 관련된 거는 유저 파일로 새로 만들자.
	컨트롤러에 users.js를 생성함

여기에서 api정의를 먼저 하자.
	1. 회원가입 api : 세가지 유형 중에 하나 아무거나.
		// @route   POST /api/v1/users
		// @route   POST /api/v1/users/register
		// @route   POST /api/v1/users/signup

정보보안 패키지 설치 - npm bcrypt (비크립트)
	윈 32, 64 다 됨.
	npm i bcrypt
	hash
		단방향 암호화. 원복할(원래 값으로 되돌릴) 수 없음.
		비밀번호는 단방향 암호화를 해야 한다. 그래야 복호화가 불가능해져서 안전하다.
	패스워드 암호화 코드[예시]
		const hashedPasswd = await bcrypt.hash(passwd, 8) // 8번 암호화가 제일 빠르고 안전하다.
		이렇게 패스워드 만들면 맨 앞에 $2b$08$이 고정적으로 붙는다.

--  로그인 api 개발하기 실습.

패스워드 체크 코드 예시
	[방법1]
		let isMatch = await bcrypt.compare(passwd, rows[0].passwd);
	[방법2]
		let isMatch = bcrypt.compareSync(passwd, rows[0].passwd)
			sync는 await과 같은 의미이다.

에러 : cannot post /경로
	=> 이 경로가 지정되어있지 않다는 뜻.

async : 동시에 하게 해죠라.

------------------  패스워드 변경 API를 설계/개발하시오.

newPasswd
	카멜 스타일.

------  유저의 id값으로, 유저 정보를 가져오는 API 개발하시오.

json 객체에서 필요한 정보 제거하기
	delete rows[0].passwd

--  json web token 검색

보안이 필요할 때(ex.회원제) 토큰을 사용한다.

json web token 검색

npm i jsonwebtoken
	웹 토큰 생성 패키지

verify : 검증하다

--  ★토큰 루틴 예시★
// 회원가입이 필요없는 서비스는 토큰이 필요없다.

클라이언트 --(로그인/회원가입)--> 서버(api에서 토큰만듦)
안드로이드 <--(토큰 전달)-- (토큰 생성 및 DB 저장 작업)

클라이언트 --(토큰 입력)--> 서버
안드로이드 <--(정상 데이터)-- (토큰 검증)

------- 로그인 api에서 가입시 토큰을 제공해주는 기능을 추가.

--  사용 예시
const jwt = require("jsonwebtoken");
const token = jwt.sign({ id: 1 }, process.env.ACCESS_TOKEN_SECRET);
// { id : 1 } 뒤의 "" : 솔트, 시드값. 이 값으로 특별하게 암호화를 한다. 이 값으로 검증을 한다. 이게 노출되면 안 된다.

-------------------------------  실습문제(워크벤치)

-- 각 기계별로 로그인하는 사람들이 있으므로, 그에 맞게 로그인 할 때마다 토큰을 생성해서 저장해야 한다. 이 기능을 만들자.
	=> 기기별로 토큰을 저장하라는 뜻임.

create table token (
	id int not null auto_increment primary key,
    token varchar(500),
	user_id int,
    foreign key (user_id) references user(id) on delete cascade
);

// 프라이머리 키(id)는 꼭 만들어주기!

-----------------------------------  미들웨어 설정

미들웨어를 줄줄이 만들어서 걸어놓을 수 있다.
뭘 걸어놓는 것인가 ?-?
app.use()를 줄줄이 달아놓으면 미들웨어를 달아놓는다고 하는 건가.

app.use(a, b)의 핵심
	a를 받으면(req) b를 보낸(res)다

중간에서 가로채게 해서 뭘 할 수 있듬.
	next()를 적지 않으면 다음 app.use()로 넘어가지 않음을 이용하기.
	[예시]
		app.use((req, res, next) => {
		  // 사이트 접속 막기
		  // res.status(503).send("사이트 점검중입니다.");

		  // 특정 메소드 막기
		  // if (req.method === "GET") {
		  //   // === : isEqual()
		  //   res.json({ alert: "GET requests are disabled" });
		  // } else {
		  //   next(); // 처리하고 밑으로 넘겨라. 이거 없으면 안 넘김.
		  // }
		});

======================================  시험 관련

금요일 시험은 오후에 보기로 함. 아마도 2시 10분.
시험 2개. 문제 해결 시나리오 / 시험지 문제.
	문제 해결 시나리오 - api 만들기.
	필기는 책에서 냄. 시험 전날에 정리해주신다고 하셨음.

======================================  기타 메모

기업들도 2~3가지 핵심 기능위주로 런칭한다. 모든 기능을 다 만들고 출시하지 않는다.

개발에 필요한 문서 : 화면 기획서, api 계획서?

안드로이드 웹/앱 프로그래머

=================  200722~23 수~목요일 수업 내용 메모

---  ★
url : http:// ~.com
header에는 token을 담아 보내고
body에는 data를 담아 보낸다.
server의 역할
	1. token validation // 토큰 밸리데이션. 인증 미들웨어. 오늘 할 거. 중간에 끼어들음 => 미들웨어임. 
		클라이언트가 정보를 보낼 때 유효한 토큰인지 아닌지를 인증해야 한다.
	2. route // 어제까지 한 거
---

미들웨어 폴더에 auth.js 파일 만듦

아래 코드 테스트용으로 적음
	const auth = (req, res, next) => {
	  console.log("인증 미들웨어");
	  next();
	};

	module.exports = auth;

인증 미들웨어는 보통 라우트 파일이나 컨트롤러 파일에 쓴다.
	사용하고 싶은 api (그룹) 앞에 쓰면 된다.

인증이 필요한 api에 'auth, '를 추가한다.
	router.route("/:id").get(auth, getMyInfo);

헤더에 토큰 담아서 넘겨주기 실습
	회원 정보 조회 API에서
	토큰 복사 -> 헤더 탭 클릭 -> 키 셋팅
		키값 : Authorization
		value : Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjE5LCJpYXQiOjE1OTU0MDI1NDN9.jWeoloAbfSkou0KaqC-_SWr8b6BhqgiWuYYOYWOmBuw
			Bearer : 전송자, 베어러 토큰
				rfc 표준
				토큰값 앞에 토큰의 유형을 적어주는 것이 표준이다.
			ex) eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjE5LCJpYXQiOjE1OTU0MDI1NDN9.jWeoloAbfSkou0KaqC-_SWr8b6BhqgiWuYYOYWOmBuw

토큰 정보 빼내기 (제대로 정리 안 된 상태임)
	auth.js로 감
	클라이언트가 보낸 헤더 정보를 여기서 받을 거임.
	헤더에서 토큰값 빼오는 방법
		let token = req.header("Authorization");
		token = token.replace("Bearer ", ""); // "Bearer "를 뺀다.
		console.log(token);
	빼온 토큰값 decode해서 user_id값 빼오기
		let user_id;
		try {
		const decoded = jwt.verify(token, process.env.ACCESS_TOKEN_SECRET);
		console.log(decoded);
		user_id = decoded.user_id;
		} catch (e) {
		res.status(401).json({ error: "형식에 맞지 않는 토큰" });
		}
	빼온 user_id값으로 DB에서 유저 정보 select하기
		let query = `select * from token where user_id = ${user_id}`;

		try {
		[rows, fields] = await connection.query(query);
		console.log(rows);
		} catch (e) {
		res.status(401).json({ error: "인증 먼저 하십시오" });
		}
	가져온 토큰과 가져온 유저 아이디가 잘 맞는지를 반복문을 돌면서 체크한다.
		for (let i = 0; i < rows.length; i++) {
		if (rows[i].user_id == user_id && rows[i].token == token) {
		  next(); // 정상이라는 뜻이므로 next()
		  return;
		}
		}
	여기까지 인증이 안 된 사람한테는 메세지를 res한다.
	- 리턴값 넣지 않음.
		res.status(401).json({ error: "인증이 안 된 토큰입니다." });
	auth함수 exports하기.
		module.exports = auth;

--------------------------  실습 : memo-server 폴더

워크벤치에서 새 테이블 2개 생성 및 기존 memo 테이블 수정.
-- 내가 쓴 메모는 나만 볼 수 있도록 만들 것임.
-- crud를 해당 유저 아이디로 처리.
-- 유저 아이디/비번을 저장할 memo_user 테이블도 생성.
-- 유저 인증 정보를 저장하는 memo_token 테이블도 생성.
-- memo 테이블에 user_id 컬럼 추가.

api 만들러 가야징 -> controllers로 가야징

★insert 쿼리문에서 insert한 데이터의 id 가져오기
	result.insertId

auth 미들웨어를 만들어서 인증 후 메모를 볼 수 있도록 만들기

0. 사전 작업
	0.0. 터미널에서 디렉토리 이동
	0.1. npm 패키지 추가 설치
		npm i jsonwebtoken - 토큰 생성/인증
		npm i chalk - 컬러풀 터미널 :3
		npm i bcrypt - 암호화값 생성/인증
		npm i mysql2 - async/await(promise) 사용을 위해
		npm i morgan - 네트워크 상태 로그 찍기
		validator는 이메일 인증을 안 할 거라 일부러 설치 안 함.
	0.2. db 커넥션 파일 수정 (바뀐 부분만 적음)
		const mysql = require("mysql2");
		const pool = mysql.createPool({
		  ...
		  waitForConnections: true,
		  connectionLimit: 10,
		})
		const connection = pool.promise();
	0.3. server.js에 morgan require하고 기본코드 작성
		const morgan = require("morgan")
		app.use(morgan("combined"))
1. auth 미들웨어 만들기
	1.1. 미들웨어 폴더(middleware) 생성
	1.2. 미들웨어 파일 생성 -> auth.js
	1.3. 일단 대충 가져올 거 가져오고 콜백 함수 만들어서 콘솔 로그 쓰고 exports 처리함.
2. 유저 처리를 위해 routes/controllers 폴더에 users.js 파일 추가 후 연결 테스트를 위해 기본 셋팅하기
	2.1. 라우트, 컨트롤러 각 파일에 기본 셋팅하기
		2.1.1. 컨트롤러 파일 기본 셋팅
		- 필수 require : connection(db 연결 파일), 암호화값 생성/인증(bcrypt), 토큰 생성/인증(jsonwebtoken)
			const connection = require("../db/mysql_connection.js");
			const bcrypt = require("bcrypt");
			const jwt = require("jsonwebtoken");
			const chalk = require("chalk");

			// @desc    회원가입
			// @route   POST /api/v1/memos
			// parameters   user_id, password
			exports.createUser = async (req, res, next) => {
			  console.log("회원가입 API 실행");
			};

			// @desc    로그인
			// @route   POST /api/v1/memos/login
			// @parameters  user_id, password
			exports.loginUser = async (req, res, next) => {
			  console.log("로그인 API 실행");
			};

			// @desc    사용자 개인 정보 조회
			// @route   GET /api/v1/memos
			// @public  auth
			exports.getUserInfo = async (req, res, next) => {
			  console.log("회원 정보 조회 API 실행");
			};

			// @desc    패스워드 변경
			// @route   PUT /api/v1/memos/change_password
			// @parameters  user_id, password
			// @public  auth
			exports.changePasswd = async (req, res, next) => {
			  console.log("패스워드 변경 API 실행");
			};
		2.1.2. 라우트 파일 기본 셋팅 - 여기서 auth를 가져온다.
		- 필수 require : 인터넷 연결(express), auth(사용자 인증 미들웨어 파일)
		- 토큰 인증이 필요한 함수 앞에 auth 추가하기
			const express = require("express");
			const auth = require("../middleware/auth.js");

			const {
			  createUser,
			  loginUser,
			  getUserInfo,
			  changePasswd,
			} = require("../controllers/users.js");

			const router = express.Router();

			router.route("/signup").post(createUser);
			router.route("/login").post(loginUser);
			router.route("/my_info").get(auth, getUserInfo);
			router.route("/change_password").put(auth, changePasswd);

			module.exports = router;
3. server.js에서 새로 만든 라우트 연결하기
	const users = require("./routes/users.js");
	app.use("/api/v1/memos/user/", users);
4. 포스트맨 memo-server 컬렉션 안에 해당 API용 폴더 만들어서 추가 후 연결 테스트하기
	3.0. 환경설정 셋팅 예시
		[manage environments]
			url : Initial value에 localhost:5100
			authToken : Current value에 임시 auth값 지정 후 save
		[콜렉션 폴더 우클릭 - Edit]
			Authorization -> Bearer Token -> {{authToken}} 입력 후 확인버튼
	4.1. 토큰값이 필요한 API에 Authorization 셋팅
		Authorization -> Inherit auth from parent 선택
	4.2. 계정생성/로그인 api의 auth 셋팅에 주의하기.
		4.1.1. Authorization - No Auth 셋팅
		4.1.2. Tests 셋팅
			if(pm.response.code === 200) {
				pm.environment.set('authToken', pm.response.json().token)
			}
	이렇게 셋팅하면 서버에서 res받은 token값을 자동으로 업데이트해서 편하게 테스트할 수 있도록 해준다.
5. 기능(함수) 상세 작성하기
	5.1. auth.js 파일(인증 기능) 함수 상세 작성
	5.2. 컨트롤러 파일 함수 상세 작성
	5.3. 라우터/컨트롤러의 memos.js 파일 수정하기
	- auth가 필요한 함수 부분을 수정한다.

----------------------------  포스트맨 토큰 설정 방법

깃헙 - 포스트맨 토큰 테스트 환경 셋팅 

----------------------------------  내일 시험 관련

시험 2가지

종이로 푸는 거
	는 교재에서 10문제 중에 8문제 냄.
	시험 범위 깃헙에 올려주심.
	나머지 2문제는 실습할 때 같이 했으면 알 수 있는 거..
	1. 인터페이스 명세서란 v-
	2. 인터페이스 명세서의 각 항목 용어 v-
	3. EAI 구축 유형 v-
	4. 인터페이스의 데이터 포맷들 v-
	5. 컴포넌트 명세서 v-
	6. JSON과 XML v- - [ ] JSONArray 시험 예상 ^-^
	7. HTTP 상태코드 v-
	8. 암호화 알고리즘 종류 v- - hash 단방향 암호화 시험 예상 ^-^

문제 해결 시험
	server.js에 서버 돌아가도록 셋팅하기
	api 4개 돌아가도록 셋팅하기
		라우트 폴더와 컨트롤러 폴더에 잘 셋팅.
	토큰 인증은 안 나옴. - work
	설치할 거
		npm init
		npm install --save-dev nodemon : 노드몬 설치
		npm i express : 네트워크 사용
		npm i mysql2 : async/await(promise) 사용을 위해
		npm i dotenv
		npm i morgan : 네트워크 상태 로그 찍기
	만들 폴더/파일
		server.js
		config/config.js : memo-server에서 복사
		config/db_config.js : memo-server에서 복사
		db/mysql_connection.js : memo-server에서 복사
		.gitignore : memo-server에서 복사
		controllers/contact.js
		routes/contact.js
	컨트롤러 기능 작성 형식
		// @desc	기능
		// @url	메소드(GET) Path(/api/v1/contact/..)
		// @request	송신(req.params.id)
		// @response	수신(result)

---  기타 메모

유튜브는 nosql을 쓰기 때문에 해시 키(문자열)을 아이디로 쓴다. 고로 nodejs에서 offset(인덱스)이나 limit(표시 개수)로 불러올 수 없다. 그래서 쓰는 게 '넥스트 페이지 토큰' 기능이다.

온라인으로 버그를 처리(기록)하는 프로그램들
	bugzilla : 버그질라. 제일 유명한 것. 무료/유료 정책
	redmine : 레드마인. 오픈소스. 이것도 많이 씀. 작은 기업들이 주로 씀.
		redmine.org
	이외에 monday.com, 잔디(국산)도 있음.

=======================  200727 월요일 수업 내용 메모

--------------------------------------  시험 해설

페이징, 페이지네이션

컨트롤러 전부 작성한 다음, 인덱스로 잡아야 할 컬럼이 무엇인지 잘 체크하고 워크벤치에서 인덱스를 설정해준다.
	- 이게 서버 개발의 최종 마무리? 준비?이다.
	- where, order by, group by 등.
	- like "% %" 컬럼의 인덱스 잡기 : 인덱스 타입을 FULLTEXT로 설정해줘야 한다.
	- index 설정시 인덱스 타입을 INDEX로 설정했을 때 인덱스 키의 기본 order를 셋팅해줄 수 있다.

------------------------------  server-ex에서 실습

로그아웃, 패스워드 분실 처리

memo-server의 auth.js에서 join 쿼리문 참고하기 (server-ex에는 join 안 되어있음)

401 : 인증 오류

--------------------------------------  회원 탈퇴

트랜잭션 사용해서 탈퇴 처리 - mysql
	데이터의 무결성

트랜잭션 사용을 위한 커넥션 정의
	// try/catch 위(밖)에서
	const conn = await connection.getConnection();
트랜잭션 시작
	try{
		await conn.beginTransaction();}
트랜잭션 저장(완료) - beginTransaction()과 같은 try 안에서
	try{
		...
		await conn.commit();}
트랜잭션 취소
	catch(e){
		await conn.rollback();}
pool에 커넥션 반납
	finally{
		await conn.release();}

-----------------------------------  이메일 날리기

구글에 sendgrid 검색
	30일에 4만개까지 무료, 이후 일 100개까지 무료

회원가입함. 프리 어카운트 쓸 거임.
iamchoma@gmail.com hwa~3

초기 화면에서 첫번째 Start 누름 > Web API 클릭 > Node.js 선택 > 2) Create an API Key 에서 프로젝트 이름 작성(first-project) > api key 복붙 > 3번, 4번 실행 > 

잘 안 돼서 mailtrap으로 바꿔서 재가입함. 구글 연동 로그인함.
config.env에서 6가지를 셋팅하고(값들은 맨 아래 두개를 빼고 mailtrap에서 복붙함)
	SMTP_HOST = smtp.mailtrap.io
	SMTP_PORT = 2525
	SMTP_USER = 
	SMTP_PASSWD = 
	FROM_EMAIL = iamchoma@gmail.com
	FROM_NAME = tenisme
utils 폴더에 sendemail.js 파일을 만듦
	sendemail.js 참고
controllers에서 sendEmail 함수를 셋팅함
	미완성

--------------------------------------  기타 메모

UI구현 240시간 잡혀있는 시간이 프로젝트 하는 시간.

통합 구현 - 안드랑 서버랑 합치는 거

무조건 뭔가를 직접 만들어야 한다는 생각은 하지 말고, 라이브러리나 api 등등을 먼저 찾아보자.





















~여기부터~